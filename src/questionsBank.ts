import { Question, PersonaStage } from './types';

/**
 * THE 1,000 QUESTIONS: PYTHON EXERCISES REPOSITORY
 * UNIQUE HIGH-VARIANCE EDITION: Each question is distinct with proper difficulty progression.
 * Level 1-2: Basics (Variables, Types, Basic Operations)
 * Level 3-4: Conditionals and Loops
 * Level 5-6: Functions and Data Structures
 * Level 7-8: Advanced Functions, Comprehensions, String Methods
 * Level 9-10: Classes, OOP, Exceptions, Modules, Advanced Topics
 */

const varNames = ['data', 'val', 'item', 'result', 'count', 'node', 'point', 'user', 'speed', 'temp', 'alpha', 'beta', 'gamma', 'delta', 'omega', 'phi', 'zeta', 'mu', 'nu', 'pi'];

// --- LEVEL 1: PLANKTON (Variables, Types, Strings, Comments) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level1Patterns = [
  // 1-10: Basic Type Identification
  (_i: number) => ({ 
    q: `What is type(42)?`, 
    o: ["<class 'int'>", "<class 'float'>", "<class 'str'>", "None"], 
    c: 0, 
    e: "Whole numbers are integers.",
    de: `The type() function returns the type (class) of any object in Python. When you call type(42), Python identifies that 42 is an integer literal. In Python, integers are objects of the built-in int class. 

Key concepts:
• Integers (int) represent whole numbers: -3, 0, 42, 1000
• Unlike some languages, Python integers have unlimited precision
• type() returns <class 'type_name'> format
• This is fundamental for understanding Python's object-oriented nature where everything is an object

Example: type(42) returns <class 'int'> because 42 is an integer literal. You can verify this: isinstance(42, int) returns True.`
  }),
  (_i: number) => ({ 
    q: `What is type(3.14)?`, 
    o: ["<class 'float'>", "<class 'int'>", "<class 'str'>", "None"], 
    c: 0, 
    e: "Decimal numbers are floats.",
    de: `Floating-point numbers in Python are represented by the float type. Any number with a decimal point is automatically a float, even if it's a whole number like 3.0.

Key concepts:
• float represents real numbers (decimals): 3.14, 2.0, -0.5, 1e10
• Floats use double-precision (64-bit) representation
• Division always produces float in Python 3: 10 / 2 = 5.0
• Float precision can cause rounding issues: 0.1 + 0.2 ≈ 0.30000000000000004

Example: type(3.14) returns <class 'float'>. Even 3.0 is a float, not an int. To create an integer from a float, use int(3.14) which truncates to 3.`
  }),
  (_i: number) => ({ 
    q: `What is type("hello")?`, 
    o: ["<class 'str'>", "<class 'int'>", "<class 'list'>", "None"], 
    c: 0, 
    e: "Text in quotes is a string.",
    de: `Strings in Python are sequences of characters enclosed in quotes. Python supports both single quotes ('hello') and double quotes ("hello") - they're identical. Strings are immutable sequences of Unicode characters.

Key concepts:
• str (string) represents text data
• Strings are immutable - you can't modify them in place
• Strings support indexing: "hello"[0] = 'h'
• Strings support slicing: "hello"[1:3] = 'el'
• Triple quotes (''' or """) create multi-line strings
• Python has no separate 'char' type - single characters are strings of length 1

Example: type("hello") returns <class 'str'>. Strings are one of Python's most powerful data types with many built-in methods like .upper(), .split(), .find(), etc.`
  }),
  (_i: number) => ({ 
    q: `What is type(True)?`, 
    o: ["<class 'bool'>", "<class 'int'>", "<class 'str'>", "None"], 
    c: 0, 
    e: "True is a boolean value.",
    de: `Boolean values in Python are represented by the bool type, which is actually a subclass of int. True and False are the only two boolean values, and they're actually instances of int (True == 1 and False == 0).

Key concepts:
• bool represents truth values: True and False
• bool is a subclass of int: isinstance(True, int) returns True
• True equals 1, False equals 0 in numeric contexts
• Many values are "truthy" (evaluate to True) or "falsy" (evaluate to False)
• Falsy values: False, None, 0, "", [], {}, (), set()
• Everything else is truthy

Example: type(True) returns <class 'bool'>. Interestingly, bool(1) is True and bool(0) is False, showing the relationship between bools and integers.`
  }),
  (_i: number) => ({ 
    q: `What is type(None)?`, 
    o: ["<class 'NoneType'>", "<class 'null'>", "<class 'void'>", "None"], 
    c: 0, 
    e: "None has its own special type.",
    de: `None is Python's null value - it represents the absence of a value. None is a singleton object (there's only one None object in Python) and has its own type called NoneType.

Key concepts:
• None represents "no value" or "nothing"
• NoneType is the type of None - there is only one None object
• None is falsy: bool(None) is False
• Functions without a return statement implicitly return None
• Use None to indicate missing or undefined values
• None != False, None != 0, None != "" - it's a distinct value
• Common use: optional parameters default to None

Example: type(None) returns <class 'NoneType'>. None is often used as a default value: def func(x=None): pass. Checking for None should use 'is': if x is None: (not x == None).`
  }),
  (_i: number) => ({ 
    q: `What is type([])?`, 
    o: ["<class 'list'>", "<class 'tuple'>", "<class 'dict'>", "None"], 
    c: 0, 
    e: "Square brackets create a list.",
    de: `Lists are ordered, mutable sequences of items enclosed in square brackets. Lists can contain items of any type, including mixed types. They're one of Python's most versatile data structures.

Key concepts:
• Lists are ordered collections: items have a defined order
• Lists are mutable: you can modify them after creation
• Lists can contain duplicates
• Lists are heterogeneous: [1, "hello", 3.14, [1,2]] is valid
• Lists support indexing and slicing like strings
• Common methods: .append(), .extend(), .insert(), .remove(), .pop()
• Empty list [] is falsy; non-empty lists are truthy

Example: type([]) returns <class 'list'>. Lists are created with [] or list(). You can access elements: [1, 2, 3][0] = 1. Lists are mutable: my_list = [1, 2]; my_list.append(3) changes my_list to [1, 2, 3].`
  }),
  (_i: number) => ({ 
    q: `What is type(())?`, 
    o: ["<class 'tuple'>", "<class 'list'>", "<class 'dict'>", "None"], 
    c: 0, 
    e: "Parentheses create a tuple.",
    de: `Tuples are ordered, immutable sequences enclosed in parentheses. Like lists, they can contain items of any type, but unlike lists, they cannot be modified after creation. This immutability makes them hashable (can be used as dictionary keys).

Key concepts:
• Tuples are ordered collections like lists
• Tuples are immutable: once created, cannot be changed
• Tuples are created with () or tuple()
• Empty tuple () requires parentheses: () not just ,
• Single-item tuple needs trailing comma: (1,) not (1)
• Tuples are faster than lists for iteration
• Tuples can be used as dictionary keys (lists cannot)
• Tuple unpacking: a, b = (1, 2)

Example: type(()) returns <class 'tuple'>. Note that empty parentheses () create an empty tuple. For a single-item tuple, you need (1,) - the comma is required, otherwise (1) is just the number 1.`
  }),
  (_i: number) => ({ 
    q: `What is type({})?`, 
    o: ["<class 'dict'>", "<class 'list'>", "<class 'set'>", "None"], 
    c: 0, 
    e: "Curly braces create a dictionary.",
    de: `Dictionaries are unordered collections of key-value pairs. An empty {} creates an empty dictionary. Dictionaries are Python's implementation of hash tables, allowing very fast lookups by key.

Key concepts:
• Dictionaries store key-value pairs: {'name': 'Alice', 'age': 30}
• Keys must be immutable (strings, numbers, tuples)
• Values can be any type
• Dictionaries are mutable and unordered (Python 3.7+ maintains insertion order)
• Empty dict {} is falsy; non-empty dicts are truthy
• Access values: my_dict['key'] or my_dict.get('key')
• Dictionary methods: .keys(), .values(), .items()

Example: type({}) returns <class 'dict'>. Empty curly braces {} create an empty dictionary. To check if empty: if not my_dict: print("empty"). Dictionaries are incredibly useful for representing structured data and mappings.`
  }),
  (_i: number) => ({ 
    q: `What is type({1, 2, 3})?`, 
    o: ["<class 'set'>", "<class 'list'>", "<class 'dict'>", "None"], 
    c: 0, 
    e: "Curly braces with values create a set.",
    de: `Sets are unordered collections of unique elements. When you use curly braces with values (not key-value pairs), Python creates a set. Sets are useful for membership testing, removing duplicates, and mathematical set operations.

Key concepts:
• Sets contain unique elements only - duplicates are automatically removed
• Sets are unordered (no indexing)
• Sets are mutable (can add/remove elements)
• Sets support set operations: union, intersection, difference
• Sets use hash tables for O(1) membership testing
• Empty set must be created with set(), not {} (that's a dict)
• Sets can contain only hashable (immutable) elements

Example: type({1, 2, 3}) returns <class 'set'>. Note the difference: {} is a dict, {1, 2, 3} is a set. Sets automatically remove duplicates: {1, 1, 2, 2} becomes {1, 2}. Use sets for fast membership testing: if item in my_set: (very fast).`
  }),
  (_i: number) => ({ 
    q: `What is type(b'hello')?`, 
    o: ["<class 'bytes'>", "<class 'str'>", "<class 'list'>", "None"], 
    c: 0, 
    e: "b prefix creates bytes object.",
    de: `The b prefix before a string literal creates a bytes object - an immutable sequence of bytes (integers from 0-255). Bytes represent binary data, while strings represent text. In Python 3, there's a clear distinction between text (str) and binary data (bytes).

Key concepts:
• bytes represents binary data (sequences of bytes 0-255)
• bytes objects are immutable like strings
• b prefix creates bytes from ASCII string: b'hello'
• Use bytes for binary data: file I/O, network protocols, binary formats
• Strings (str) are for text; bytes are for binary data
• Convert str to bytes: "hello".encode() → b'hello'
• Convert bytes to str: b'hello'.decode() → "hello"
• bytes only accepts ASCII in literal form

Example: type(b'hello') returns <class 'bytes'>. Bytes are essential for working with binary files, network communication, and data serialization. The bytes type helps Python 3 distinguish between text and binary data, preventing encoding errors.`
  }),
  
  // 11-20: Variable Naming Rules
  (_i: number) => ({ 
    q: `Is 'my_variable' a valid variable name?`, 
    o: ["Yes", "No", "Only in Python 2", "Only in classes"], 
    c: 0, 
    e: "Variables can contain letters, numbers, and underscores.",
    de: `Python variable names must follow specific rules: they can contain letters (a-z, A-Z), digits (0-9), and underscores (_), but cannot start with a digit. 'my_variable' follows all these rules perfectly.

Rules for valid Python identifiers:
• Can contain letters (a-z, A-Z), digits (0-9), and underscores (_)
• Cannot start with a digit
• Are case-sensitive: myVar, MyVar, and MYVAR are different
• Cannot be Python keywords (if, def, class, etc.)
• No spaces or special characters except underscore
• No length limit (though keep them reasonable!)

Example: my_variable = 42 is valid. This style (lowercase with underscores) is called "snake_case" and is recommended by PEP 8 (Python's style guide) for variable names.`
  }),
  (_i: number) => ({ 
    q: `Is '2variable' a valid variable name?`, 
    o: ["No", "Yes", "Depends", "Only in functions"], 
    c: 0, 
    e: "Variable names cannot start with a number.",
    de: `Python identifiers cannot start with a digit. This rule prevents ambiguity between variable names and numeric literals. If Python allowed names starting with digits, it would be impossible to distinguish between the variable 2variable and the number 2 followed by the variable variable.

Why this rule exists:
• Prevents confusion with numeric literals
• Makes parsing unambiguous: is 2var a variable or "2" + "var"?
• Standard across most programming languages
• Makes code more readable

Workarounds:
• Use letter prefix: two_variable, var2, number2_variable
• Use descriptive names: second_variable, variable_2

Example: 2variable = 5 raises SyntaxError. Use variable2 or two_variable instead.`
  }),
  (_i: number) => ({ 
    q: `Is 'my-variable' a valid variable name?`, 
    o: ["No", "Yes", "Only in Python 2", "Only in classes"], 
    c: 0, 
    e: "Hyphens are not allowed in variable names.",
    de: `Hyphens (-) are not allowed in Python variable names because the hyphen character is the subtraction operator. Python would interpret my-variable as "my" minus "variable" (which would cause a NameError unless both are defined).

Allowed separators:
• Underscore (_): my_variable ✓
• CamelCase: myVariable ✓
• PascalCase: MyVariable ✓

Not allowed:
• Hyphen: my-variable ✗ (interpreted as subtraction)
• Space: my variable ✗ (syntax error)
• Dot: my.variable ✗ (attribute access, not variable name)

Example: my-variable = 5 raises SyntaxError because Python sees "my" - "variable". Use my_variable or myVariable instead.`
  }),
  (_i: number) => ({ 
    q: `Is 'class' a valid variable name?`, 
    o: ["No", "Yes", "Only in Python 2", "Only in modules"], 
    c: 0, 
    e: "'class' is a reserved keyword.",
    de: `'class' is one of Python's reserved keywords (also called reserved words). Keywords have special meaning in Python and cannot be used as variable, function, or class names. They're part of Python's syntax.

Python keywords (cannot be used as identifiers):
• Control flow: if, else, elif, for, while, break, continue, pass, return
• Functions/classes: def, class, lambda, yield
• Logic: and, or, not, in, is
• Exception handling: try, except, finally, raise, assert
• Import: import, from, as
• Type checking: isinstance, type
• And others: del, global, nonlocal, with, async, await, etc.

How to check: import keyword; print(keyword.kwlist) shows all keywords.

Example: class = 5 raises SyntaxError. Use class_name, cls, or klass instead.`
  }),
  (_i: number) => ({ 
    q: `Is 'def' a valid variable name?`, 
    o: ["No", "Yes", "Only in Python 2", "Only in modules"], 
    c: 0, 
    e: "'def' is a reserved keyword.",
    de: `'def' is a Python keyword used to define functions. It cannot be used as a variable name because it has a specific syntactic purpose in Python. When Python sees 'def', it expects a function definition to follow.

The 'def' keyword:
• Used to define functions: def my_function(): pass
• Part of Python's syntax, not a function itself
• Cannot be reassigned or used as an identifier
• Short for "define" - indicates the start of a function definition

Why keywords are reserved:
• Prevents conflicts with language syntax
• Ensures code is unambiguous
• Maintains language consistency

Example: def = 5 raises SyntaxError. Use func, definition, or define_func instead if you need a variable name.`
  }),
  (_i: number) => ({ 
    q: `Is 'if' a valid variable name?`, 
    o: ["No", "Yes", "Only in Python 2", "Only in modules"], 
    c: 0, 
    e: "'if' is a reserved keyword.",
    de: `'if' is a Python keyword used for conditional statements. It cannot be used as a variable name because it's part of Python's control flow syntax.

The 'if' statement:
• Used for conditional execution: if condition: code
• Followed by optional elif and else clauses
• Evaluates the condition's truthiness
• One of Python's most fundamental control structures

Common alternatives if you need a variable name:
• condition, check, flag, state
• Use descriptive names: is_valid, has_permission

Example: if = 5 raises SyntaxError. If you need to store a condition, use: condition = True or check = False instead.`
  }),
  (_i: number) => ({ 
    q: `Is 'MyVariable' a valid variable name?`, 
    o: ["Yes", "No", "Only if lowercase", "Only in classes"], 
    c: 0, 
    e: "Variable names are case-sensitive and can start with uppercase.",
    de: `Python variable names are case-sensitive and can start with any letter (uppercase or lowercase). 'MyVariable' follows PascalCase naming convention, which is valid but typically reserved for class names per PEP 8.

Naming conventions in Python (PEP 8):
• snake_case: for variables and functions (my_variable, calculate_total)
• PascalCase: for classes (MyClass, DataProcessor)
• UPPER_CASE: for constants (PI, MAX_SIZE)
• _leading_underscore: private/internal use (_internal_method)
• __double_underscore__: name mangling or special methods (__init__)

Case sensitivity:
• myVariable, MyVariable, MYVARIABLE are all different
• Python is case-sensitive: age ≠ Age ≠ AGE

Example: MyVariable = 42 is valid. However, PEP 8 recommends using snake_case for variables (my_variable) and reserving PascalCase for classes.`
  }),
  (_i: number) => ({ 
    q: `Is '_private' a valid variable name?`, 
    o: ["Yes", "No", "Only in classes", "Error"], 
    c: 0, 
    e: "Underscore at start is valid (convention for private).",
    de: `A single leading underscore is a Python naming convention indicating that a name is intended for internal use. It's valid syntax and serves as a signal to other programmers (and tools) that this should be treated as non-public.

Underscore conventions:
• _single_leading: "internal use" convention (not enforced by Python)
• __double_leading: triggers name mangling in classes (class-specific)
• __double_leading_trailing__: Python special methods (__init__, __str__)
• single_trailing_: avoids conflict with keywords (class_ instead of class)

Private convention:
• _private_var suggests "don't use this outside the module/class"
• Not actually private - Python has no true privacy
• More of a contract/agreement between developers
• Import controls: from module import * won't import _names

Example: _private = 42 is valid. It's a convention, not a rule - it tells other developers "this is for internal use, use at your own risk."`
  }),
  (_i: number) => ({ 
    q: `Is '__special__' a valid variable name?`, 
    o: ["Yes", "No", "Only in classes", "Error"], 
    c: 0, 
    e: "Double underscores are valid (used for special methods).",
    de: `Names with double leading and trailing underscores (__special__) are reserved for Python's special methods and attributes. While technically you can use them, it's strongly discouraged as they're part of Python's "magic methods" system.

Special methods (magic methods):
• __init__: constructor, called when object is created
• __str__: string representation, used by str() and print()
• __repr__: developer representation, used by repr()
• __len__: length, used by len()
• __add__: addition operator, used by +
• __eq__: equality, used by ==
• And many more...

Important notes:
• These are method names, not variable names
• They're called automatically by Python in certain contexts
• Don't create variables with these names unless you understand the consequences
• Using them might interfere with Python's internal mechanisms

Example: __special__ = 42 is technically valid but dangerous. It could interfere with Python's name mangling or special method resolution.`
  }),
  (_i: number) => ({ 
    q: `Is 'variable name' (with space) a valid variable name?`, 
    o: ["No", "Yes", "Only in Python 2", "Only in functions"], 
    c: 0, 
    e: "Spaces are not allowed in variable names.",
    de: `Spaces are not allowed in Python identifiers because they're used to separate tokens in the language. Python uses whitespace (spaces, tabs) for indentation and token separation, so including spaces in names would make parsing impossible.

Why spaces aren't allowed:
• Spaces are used for indentation (Python's way of grouping code)
• Spaces separate tokens: if x > 5 (spaces separate 'if', 'x', '>', '5')
• Would cause parsing ambiguity
• Makes code unreadable and unparsable

Solutions:
• Use underscore: variable_name
• Use CamelCase: variableName
• Use descriptive single words: variablename (not recommended if unclear)

Token separation example:
• variable name = 5 would be parsed as: variable, name, =, 5
• Python would see two separate identifiers and raise SyntaxError

Example: variable name = 5 raises SyntaxError. Use variable_name = 5 or variableName = 5 instead.`
  }),
  
  // 21-30: String Basics
  (_i: number) => ({ 
    q: `What is len("hello")?`, 
    o: ["5", "4", "6", "Error"], 
    c: 0, 
    e: "len() counts every character.",
    de: `The len() function returns the number of items in a sequence or collection. For strings, it counts every character, including spaces, punctuation, and special characters. It's one of Python's most commonly used built-in functions.

How len() works:
• len(string) counts characters: len("hello") = 5
• Counts all characters: len("a b") = 3 (includes space)
• Works on many types: lists, tuples, dicts, sets, strings
• Returns integer (0 or positive)
• Raises TypeError for non-sequence types (like int)

String indexing visualization:
"hello" has indices: h(0), e(1), l(2), l(3), o(4)
Length = 5, valid indices: 0-4

Example: len("hello") returns 5. Note: len("") returns 0 (empty string). Also: len("Python!") = 7 (includes the exclamation mark).`
  }),
  (_i: number) => ({ 
    q: `What does "Hello" + "World" result in?`, 
    o: ["HelloWorld", "Hello World", "Error", "None"], 
    c: 0, 
    e: "String concatenation joins strings without spaces.",
    de: `The + operator performs string concatenation in Python, joining strings end-to-end. It doesn't automatically add spaces - strings are joined exactly as they are, with no separator unless you explicitly provide one.

String concatenation:
• + operator joins strings: "Hello" + "World" = "HelloWorld"
• Creates a new string (strings are immutable)
• No automatic spacing - you must add spaces manually
• Can concatenate multiple strings: "A" + "B" + "C" = "ABC"
• + only works with strings (must convert other types first)

To add spaces:
• "Hello" + " " + "World" = "Hello World"
• "Hello " + "World" = "Hello World" (space after first string)
• "Hello" + " World" = "Hello World" (space before second string)

Alternatives:
• join() method: " ".join(["Hello", "World"]) = "Hello World"
• f-strings: f"{'Hello'} {'World'}" = "Hello World"

Example: "Hello" + "World" results in "HelloWorld" (no space). For a space, use: "Hello" + " " + "World" or "Hello " + "World".`
  }),
  (_i: number) => ({ 
    q: `What does "Hi" * 3 result in?`, 
    o: ["HiHiHi", "Hi3", "Error", "None"], 
    c: 0, 
    e: "String multiplication repeats the string.",
    de: `The * operator can multiply strings by integers, repeating the string the specified number of times. This is a convenient way to create repeated patterns or padding.

String multiplication:
• string * integer repeats the string
• "Hi" * 3 = "HiHiHi" (string repeated 3 times)
• integer * string works the same: 3 * "Hi" = "HiHiHi"
• string * 0 = "" (empty string)
• string * negative number = "" (empty string)
• Only works with integers (not floats)

Common use cases:
• Creating separators: "-" * 50 creates a line of dashes
• Padding: " " * 10 creates 10 spaces
• Patterns: "ab" * 3 = "ababab"
• Visual formatting in output

Important: string * string doesn't work (raises TypeError). You can only multiply strings by integers.

Example: "Hi" * 3 results in "HiHiHi". Also: 5 * "=" = "=====" (useful for creating visual separators).`
  }),
  (_i: number) => ({ 
    q: `What is "Python"[0]?`, 
    o: ["P", "p", "Error", "None"], 
    c: 0, 
    e: "String indexing starts at 0.",
    de: `Python uses zero-based indexing, meaning the first character has index 0, not 1. This is consistent across all Python sequences (lists, tuples, strings). Understanding zero-based indexing is fundamental to Python programming.

Zero-based indexing:
• First character is at index 0: "Python"[0] = 'P'
• Second character is at index 1: "Python"[1] = 'y'
• Last character is at index len(string) - 1
• Index out of range raises IndexError

String "Python" indices:
P(0), y(1), t(2), h(3), o(4), n(5)
Length = 6, valid indices: 0-5

Why zero-based?
• Mathematically elegant: index represents offset from start
• Consistent with pointer arithmetic in lower-level languages
• Standard in most programming languages (C, Java, JavaScript, etc.)
• Makes slicing more intuitive: string[:3] gets first 3 characters (indices 0,1,2)

Example: "Python"[0] returns 'P'. To get the last character using positive indexing: "Python"[5] = 'n' (length 6, so index 5).`
  }),
  (_i: number) => ({ 
    q: `What is "Python"[-1]?`, 
    o: ["n", "P", "Error", "None"], 
    c: 0, 
    e: "Negative indexing starts from the end.",
    de: `Python supports negative indexing, allowing you to access elements from the end of a sequence. Index -1 is the last element, -2 is second-to-last, and so on. This is extremely useful for accessing the end of sequences without calculating length.

Negative indexing:
• -1 = last character: "Python"[-1] = 'n'
• -2 = second-to-last: "Python"[-2] = 'o'
• -len(string) = first character: "Python"[-6] = 'P'
• -0 is the same as 0 (no separate meaning)

String "Python" with negative indices:
P(-6), y(-5), t(-4), h(-3), o(-2), n(-1)
Positive:  0     1     2     3     4     5

Advantages:
• Don't need to know string length
• Easy access to last/few elements
• Common pattern: string[-1] for last character
• Works with any sequence (lists, tuples)

Example: "Python"[-1] returns 'n' (last character). "Python"[-2] returns 'o' (second-to-last). This is more convenient than "Python"[len("Python")-1].`
  }),
  (_i: number) => ({ 
    q: `What is "Python"[1:4]?`, 
    o: ["yth", "Pyth", "Python", "Error"], 
    c: 0, 
    e: "Slicing [1:4] gets characters from index 1 to 3.",
    de: `String slicing extracts a substring using the syntax string[start:stop]. The start index is inclusive, the stop index is exclusive - meaning it includes the start but stops before the stop index. This "exclusive end" convention is important to understand.

Slicing syntax: string[start:stop]
• start: inclusive (includes this index)
• stop: exclusive (stops before this index)
• Result includes indices: start, start+1, ..., stop-1
• Does NOT include index 'stop'

"Python"[1:4] breakdown:
• Start at index 1: 'y'
• Stop before index 4 (don't include index 4)
• Includes indices 1, 2, 3: 'y', 't', 'h'
• Result: "yth"

Visualization:
"Python" = P(0), y(1), t(2), h(3), o(4), n(5)
[1:4] includes:       y(1), t(2), h(3)
Result: "yth"

Key concept: The number of characters = stop - start = 4 - 1 = 3 characters.

Example: "Python"[1:4] returns "yth". To include 'o', use [1:5]. Remember: slicing never modifies the original string (strings are immutable).`
  }),
  (_i: number) => ({ 
    q: `What is "Python"[:3]?`, 
    o: ["Pyt", "Python", "P", "Error"], 
    c: 0, 
    e: "Slicing [:3] gets first 3 characters.",
    de: `When you omit the start index in a slice [:stop], Python assumes 0 (start from beginning). This is a common pattern for getting the first N characters of a string.

Slicing with omitted start:
• [:stop] is equivalent to [0:stop]
• Gets characters from beginning up to (but not including) stop
• [:3] = first 3 characters (indices 0, 1, 2)
• [:0] = "" (empty string - no characters before index 0)

"Python"[:3] breakdown:
• Omitted start defaults to 0
• Stop before index 3
• Includes indices 0, 1, 2: 'P', 'y', 't'
• Result: "Pyt"

Common patterns:
• [:n] = first n characters
• [n:] = everything from index n to end
• [:] = entire string (copy)
• [::-1] = reversed string

Example: "Python"[:3] returns "Pyt" (first 3 characters). This is often used to get prefixes or truncate strings to a maximum length.`
  }),
  (_i: number) => ({ 
    q: `What is "Python"[3:]?`, 
    o: ["hon", "Python", "Pyt", "Error"], 
    c: 0, 
    e: "Slicing [3:] gets from index 3 to end.",
    de: `When you omit the stop index in a slice [start:], Python assumes the end of the string. This gets everything from the start index to the last character, inclusive.

Slicing with omitted stop:
• [start:] gets from start index to end
• Includes the start index and everything after
• [3:] = from index 3 to last character (inclusive)
• [len(string):] = "" (empty - nothing after last index)

"Python"[3:] breakdown:
• Start at index 3: 'h'
• Continue to end (no stop specified)
• Includes indices 3, 4, 5: 'h', 'o', 'n'
• Result: "hon"

Common patterns:
• [n:] = everything from index n onward
• [-n:] = last n characters
• [1:] = everything except first character
• [:-1] = everything except last character

Example: "Python"[3:] returns "hon" (from index 3 to end). Combined with [:n], you can easily split strings: first = string[:n]; rest = string[n:].`
  }),
  (_i: number) => ({ 
    q: `What is "Python"[::2]?`, 
    o: ["Pto", "Python", "Pyt", "Error"], 
    c: 0, 
    e: "[::2] gets every 2nd character.",
    de: `Slicing with a step value [start:stop:step] allows you to skip characters. The step (third value) determines the increment between indices. A step of 2 means take every second character.

Extended slicing: string[start:stop:step]
• start: starting index (default: 0 or beginning)
• stop: ending index (default: end)
• step: increment between indices (default: 1)
• [::2] = start at 0, go to end, step by 2

"Python"[::2] breakdown:
• Start: 0 (default)
• Stop: end (default)
• Step: 2 (every 2nd character)
• Indices: 0, 2, 4: 'P', 't', 'o'
• Result: "Pto"

Common step values:
• [::1] = normal (every character) - same as [:]
• [::2] = every 2nd character (even indices)
• [1::2] = every 2nd character starting at 1 (odd indices)
• [::3] = every 3rd character
• [::-1] = reverse (negative step reverses direction)

Example: "Python"[::2] returns "Pto". To get odd-indexed characters: "Python"[1::2] = "yhn". The step value is very powerful for pattern extraction.`
  }),
  (_i: number) => ({ 
    q: `What is "Python"[::-1]?`, 
    o: ["nohtyP", "Python", "Error", "None"], 
    c: 0, 
    e: "[::-1] reverses the string.",
    de: `Using a negative step value in slicing reverses the direction of iteration. [::-1] is the idiomatic Python way to reverse a string (or any sequence). It's concise, readable, and efficient.

Reverse slicing: [::-1]
• Start: omitted (defaults to end when step is negative)
• Stop: omitted (defaults to beginning when step is negative)
• Step: -1 (go backwards)
• Reverses the entire string

"Python"[::-1] breakdown:
• Step is -1, so go backwards
• Start at end, go to beginning
• Indices visited: 5, 4, 3, 2, 1, 0
• Characters: 'n', 'o', 'h', 't', 'y', 'P'
• Result: "nohtyP"

Negative step behavior:
• With negative step, defaults are reversed
• [::-1] = reverse entire sequence
• [::-2] = reverse, taking every 2nd character
• [5:0:-1] = from index 5 down to (but not including) 0

Alternatives (less Pythonic):
• ''.join(reversed("Python")) - works but verbose
• Manual loop - unnecessary complexity

Example: "Python"[::-1] returns "nohtyP". This is the most Pythonic way to reverse a string. Note: [::-1] creates a new string (original unchanged, since strings are immutable).`
  }),
  
  // 31-40: Comments and Multi-line Strings
  (_i: number) => ({ 
    q: `Which symbol starts a single-line comment?`, 
    o: ["#", "//", "/*", "--"], 
    c: 0, 
    e: "Python uses # for comments.",
    de: `Python uses the hash symbol (#) to start single-line comments. Everything from the # to the end of the line is ignored by the Python interpreter. This is Python's only way to create comments - there are no multi-line comment blocks like /* */ in C/Java.

How comments work:
• # starts a comment - everything after it on that line is ignored
• Comments don't affect program execution
• Comments are for humans, not the interpreter
• Can be at the start of a line or after code on the same line
• No closing symbol needed - ends at the end of the line

Comparison with other languages:
• Python: # comment (like shell, Perl, Ruby)
• C/Java: // comment or /* comment */
• HTML: <!-- comment -->
• SQL: -- comment or /* comment */

Example: # This is a comment
x = 5  # This is also a comment (inline)
print(x)  # Comments explain code
`
  }),
  (_i: number) => ({ 
    q: `Correct way to write a multi-line string?`, 
    o: ["'''String'''", "'String'", '"String"', "/String/"], 
    c: 0, 
    e: "Triple quotes allow multi-line strings.",
    de: `Triple quotes (three single quotes ''' or three double quotes """) allow you to create multi-line strings in Python. These preserve newlines and whitespace, making them perfect for documentation strings, formatted text, and strings spanning multiple lines.

Triple quote syntax:
• '''text''' - triple single quotes
• """text""" - triple double quotes
• Both work identically
• Preserves newlines and spacing
• Can span multiple lines
• Useful for docstrings (documentation)

Why use triple quotes:
• Regular quotes: 'text' or "text" must be on one line
• Triple quotes allow line breaks inside the string
• Perfect for documentation strings (docstrings)
• Can include both single and double quotes inside

Example:
text = """This is
a multi-line
string"""

Common uses:
• Docstrings: def func(): """Function documentation"""
• SQL queries: query = """SELECT * FROM table"""
• Long formatted messages
• Multi-line JSON or XML

Note: Triple quotes create strings, not comments. They're executed like any string literal.
`
  }),
  (_i: number) => ({ 
    q: `What is the purpose of comments in Python?`, 
    o: ["Document code", "Execute code", "Create variables", "Import modules"], 
    c: 0, 
    e: "Comments document code and are ignored by Python.",
    de: `Comments in Python serve to document and explain code for human readers. They are completely ignored by the Python interpreter during execution - they don't affect program behavior at all. Good comments make code more maintainable and understandable.

Purposes of comments:
• Explain complex logic or algorithms
• Document function purposes and parameters
• Clarify non-obvious code decisions
• Provide usage examples
• Note potential issues or TODOs
• Explain why something is done a certain way

What comments do NOT do:
• They don't execute code
• They don't create variables
• They don't import modules
• They don't affect program execution
• They're stripped out before execution

Types of comments:
• Inline comments: x = 5  # Set x to 5
• Block comments: # Calculate total
                  # Add all items
• Documentation strings (docstrings): """Function description"""

Best practices:
• Write comments that explain WHY, not WHAT
• Keep comments up-to-date with code changes
• Don't state the obvious: # x = 5 (unnecessary)
• Explain complex logic: # Use binary search for O(log n) lookup

Example: Comments help future readers (including yourself) understand the code's purpose and logic.
`
  }),
  (_i: number) => ({ 
    q: `Can you write a comment after code on the same line?`, 
    o: ["Yes", "No", "Only in Python 2", "Only in functions"], 
    c: 0, 
    e: "Comments can be inline after code using #.",
    de: `Yes, you can write comments after code on the same line using the # symbol. This is called an "inline comment." Everything from the # to the end of the line is treated as a comment and ignored. This is very common in Python programming.

Inline comment syntax:
• Code followed by # followed by comment
• Space before # is recommended for readability
• Comment continues until end of line
• Only that line is affected

Examples:
x = 5  # Assign 5 to x
result = calculate()  # Get the calculation result
# Multiple inline comments work too:
y = 10  # Set y to 10  # (only first # is needed, rest ignored)

Best practices:
• Leave at least one space before #
• Keep inline comments brief
• Use for clarification, not obvious statements
• PEP 8 recommends inline comments sparingly

Common uses:
• Explain variable assignments: x = 5  # User's age
• Clarify calculations: total = price * 1.1  # Add 10% tax
• Note special cases: if x < 0:  # Handle negative values
• Suppress linter warnings: x = unused_var  # noqa

Example: name = "Alice"  # User's name (inline comment). The code executes, the comment is ignored.
`
  }),
  (_i: number) => ({ 
    q: `What does '''triple quotes''' create?`, 
    o: ["Multi-line string", "Comment", "Error", "Variable"], 
    c: 0, 
    e: "Triple quotes create multi-line strings.",
    de: `Triple quotes (''' or """) create a multi-line string literal in Python. They do NOT create comments - they create actual string objects that can be stored in variables, returned from functions, or used in expressions. This is an important distinction.

What triple quotes create:
• Multi-line string object (type: str)
• Can be assigned to variables
• Can be used in expressions
• Preserves newlines and formatting
• Executed like any string literal

Common misconception:
• Triple quotes look like comments but they're NOT
• They create string objects that exist in memory
• If assigned to nothing, they're created but immediately discarded
• Used inside functions/classes become docstrings

Examples:
# String variable:
text = '''This is
a multi-line
string'''

# Docstring (special use):
def my_func():
    """This is a docstring - still a string!"""
    pass

# Both create strings:
s1 = '''single'''
s2 = """double"""  # Same result

Important: Triple-quoted strings are often used as docstrings, which are special strings that Python automatically associates with functions, classes, and modules for documentation purposes.
`
  }),
  (_i: number) => ({ 
    q: `Is # a comment or string delimiter?`, 
    o: ["Comment", "String delimiter", "Both", "Neither"], 
    c: 0, 
    e: "# starts a comment, not a string.",
    de: `The # symbol is a comment marker, not a string delimiter. It tells Python to ignore everything from that point to the end of the line. It's used only for comments, not for defining strings.

What # does:
• Starts a single-line comment
• Ignored by Python interpreter
• Not used to create strings
• No closing symbol needed

String delimiters in Python:
• Single quotes: 'text'
• Double quotes: "text"
• Triple single quotes: '''text'''
• Triple double quotes: """text"""
• Raw strings: r"text"
• f-strings: f"text"

Important distinction:
• # text = comment (ignored)
• "text" = string (executed, creates string object)

Examples:
# This is a comment - ignored
text = "This is a string"  # This comment is also ignored
# But the string above IS executed

Inside strings, # has no special meaning:
text = "Price is $#100"  # The # is part of the string
comment = "This is a # comment"  # # inside string is just a character

Example: # starts a comment. To create a string, use 'text' or "text", not #.
`
  }),
  (_i: number) => ({ 
    q: `Can triple quotes be used for comments?`, 
    o: ["No, they create strings", "Yes", "Only in Python 2", "Only in classes"], 
    c: 0, 
    e: "Triple quotes create strings, not comments.",
    de: `No, triple quotes cannot be used for comments - they create string literals. While unassigned triple-quoted strings are often used informally as multi-line "comments," they're actually executed as string objects (though they're immediately discarded if not assigned). This is inefficient compared to real comments.

The reality:
• Triple quotes create string objects (even if unassigned)
• Strings are created in memory, then discarded
• This uses resources (minimal but not zero)
• Real comments (#) are completely ignored - zero overhead

Common misconception:
# People sometimes do this thinking it's a comment:
"""
This is NOT a comment
It's a string that's created and discarded
"""

# Better way (actual comment):
# This is a comment
# Multi-line comments require multiple # lines

Why not use triple quotes as comments:
• Creates unnecessary string objects
• Not truly ignored like comments
• Can cause issues in some contexts
• Not the Pythonic way

The Pythonic way for multi-line comments:
• Use # on each line
• Or use triple-quoted strings as docstrings (inside functions/classes)

Example: """This looks like a comment but creates a string""" - use # This is a real comment instead for actual comments.
`
  }),
  (_i: number) => ({ 
    q: `What happens to code after # on a line?`, 
    o: ["Ignored by Python", "Executed", "Creates error", "Creates variable"], 
    c: 0, 
    e: "Everything after # is ignored.",
    de: `Everything after the # symbol on a line is completely ignored by the Python interpreter. It's treated as a comment and stripped out before execution. This means you can write anything after # and it won't affect your program - it won't execute, create variables, or cause errors (unless it's part of a string that contains #).

Comment behavior:
• # marks the start of a comment
• Everything from # to end of line is ignored
• Not parsed, not executed, not stored
• Can contain any characters (no syntax rules apply)
• The line continues but only code before # runs

Examples:
x = 5  # This comment is ignored
# This entire line is a comment
x = 5  # x = 10  # This won't execute! x stays 5

Important exceptions:
• If # is inside a string, it's part of the string, not a comment:
  text = "Price is #100"  # The # is part of the string
  
• If # is inside triple quotes, it's part of the string:
  text = """Line 1  # This is still part of string"""

• Only # outside of string literals starts comments

Example: x = 5  # This code would cause an error if executed - but it's ignored! So x = 5, not the error.
`
  }),
  (_i: number) => ({ 
    q: `Can you nest triple-quoted strings?`, 
    o: ["Yes, with different quote types", "No", "Only in Python 2", "Only in functions"], 
    c: 0, 
    e: "You can nest with different quote types.",
    de: `Yes, you can nest triple-quoted strings by using different quote types. If you use ''' for the outer string, you can use """ for an inner string, and vice versa. This allows you to include quotes of one type inside a string delimited by the other type.

Nesting rules:
• Outer ''' can contain """ inside
• Outer """ can contain ''' inside
• Cannot nest same type: ''' ... ''' ... ''' won't work (ends at first matching triple)
• Mixing quote types is the solution

Examples:
# Nested with different types:
text = '''Outer string with """inner string""" inside'''
text2 = """Outer with '''inner''' inside"""

# This won't work (same type):
# text = '''Outer with '''inner''' inside'''  # ERROR! Ends at second '''

Why this works:
• Python finds matching triple quotes to end the string
• Different quote types don't match
• Allows nesting without escaping

Alternative (escaping):
• You can escape quotes: text = '''Outer with \'\'\'inner\'\'\' inside'''
• But using different quote types is cleaner

Common use cases:
• Embedding code examples with quotes
• Multi-level nested strings
• Complex documentation strings

Example: text = '''Documentation with "quoted" and """triple quoted""" examples inside''' - works because different quote types don't conflict.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between ' and " for strings?`, 
    o: ["No difference", "Single is shorter", "Double is faster", "Single is deprecated"], 
    c: 0, 
    e: "Both work identically in Python.",
    de: `There is no functional difference between single quotes (') and double quotes (") for creating strings in Python. They work identically - both create the same string object. The choice between them is purely stylistic and based on convenience.

No difference in:
• Functionality: 'text' == "text"  # True
• Performance: Identical
• Memory usage: Identical
• Syntax rules: Both work everywhere

So why have both?
• Convenience: Use 'text' when string contains "
• Convenience: Use "text" when string contains '
• Style consistency: Pick one and stick with it
• Avoid escaping: Use the opposite quote type

Examples:
text1 = 'He said "Hello"'  # No escaping needed
text2 = "It's a string"  # No escaping needed
text3 = 'It\'s a string'  # Escaping needed with same quotes
text4 = "He said \"Hello\""  # Escaping needed with same quotes

PEP 8 (Python style guide) says:
• Be consistent within a module
• Use triple double quotes for docstrings
• Pick one style and stick with it

Common convention:
• Single quotes for short strings
• Double quotes for strings with single quotes inside
• Triple double quotes for docstrings

Example: 'Hello' and "Hello" create identical strings. Choose based on what characters are inside the string to minimize escaping.
`
  }),
  
  // 41-50: Type Conversions
  (_i: number) => ({ 
    q: `Result of int("42")?`, 
    o: ["42", '"42"', "Error", "float"], 
    c: 0, 
    e: "int() converts numeric strings to integers.",
    de: `The int() function converts a value to an integer. When given a string containing numeric characters, it parses the string and returns the integer value. This is essential for converting user input (which comes as strings) to numbers for calculations.

int() conversion:
• int("42") = 42 (converts string to integer)
• int("42") returns 42 (an integer, not a string)
• The result is type int, not type str
• Leading/trailing whitespace is allowed: int(" 42 ") = 42

What int() accepts:
• Numeric strings: int("42") = 42
• Float strings: int("3.14") = 3 (truncates)
• Floats: int(3.14) = 3 (truncates towards zero)
• Whitespace: int("  42  ") = 42 (strips whitespace)

What causes errors:
• Non-numeric strings: int("hello") raises ValueError
• Empty strings: int("") raises ValueError
• None: int(None) raises TypeError

Common use:
• User input: age = int(input("Enter age: "))
• String parsing: num = int("42")
• Type conversion: result = int(3.14)

Example: int("42") returns 42 (integer). Note: This is the number 42, not the string "42". To convert back: str(42) = "42".
`
  }),
  (_i: number) => ({ 
    q: `Result of float(42)?`, 
    o: ["42.0", "42", "int", "None"], 
    c: 0, 
    e: "float() adds decimal precision.",
    de: `The float() function converts a value to a floating-point number (decimal number). When given an integer, it adds .0 to make it a float. This is important because floats and ints are different types in Python.

float() conversion:
• float(42) = 42.0 (converts integer to float)
• Adds decimal precision (even if .0)
• Result is type float, not type int
• 42.0 is different from 42 in type, though equal in value

What float() accepts:
• Integers: float(42) = 42.0
• Numeric strings: float("3.14") = 3.14
• Integer strings: float("42") = 42.0
• Already floats: float(3.14) = 3.14 (no change)
• Scientific notation: float("1e5") = 100000.0

Why use float():
• Division always produces float: 10 / 2 = 5.0
• Need decimal precision: float(42) = 42.0
• Consistency: float(5) = 5.0
• Parsing decimal strings: float("3.14") = 3.14

Type differences:
• 42 is int, 42.0 is float
• 42 == 42.0 is True (values are equal)
• type(42) != type(42.0) (types are different)
• 42 is 42.0 is False (different objects)

Example: float(42) returns 42.0 (a float). This is useful when you need decimal precision or are working with division which always produces floats in Python 3.
`
  }),
  (_i: number) => ({ 
    q: `Result of str(42)?`, 
    o: ['"42"', "42", "Error", "None"], 
    c: 0, 
    e: "str() converts values to strings.",
    de: `The str() function converts a value to its string representation. When given a number, it converts it to a string containing the numeric characters. This is the opposite of int() or float() - it converts from numbers to strings.

str() conversion:
• str(42) = "42" (converts integer to string)
• Creates a string representation of the value
• Result is type str, not the original type
• Works with any type (numbers, lists, objects, etc.)

What str() accepts:
• Integers: str(42) = "42"
• Floats: str(3.14) = "3.14"
• Booleans: str(True) = "True"
• Lists: str([1, 2]) = "[1, 2]"
• None: str(None) = "None"
• Almost anything!

Common uses:
• String formatting: "Age: " + str(42)
• Displaying numbers: print(str(42))
• Conversion for concatenation: "Number: " + str(num)
• f-strings alternative: f"Number: {42}" (automatic conversion)

String concatenation:
• "Age: " + 42 raises TypeError (can't concatenate)
• "Age: " + str(42) = "Age: 42" (works!)

Modern alternative:
• f-strings: f"Age: {42}" = "Age: 42" (automatic conversion)
• .format(): "Age: {}".format(42) = "Age: 42"

Example: str(42) returns "42" (a string). This allows you to combine numbers with text: "I am " + str(age) + " years old".
`
  }),
  (_i: number) => ({ 
    q: `Result of bool(0)?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "0 is False, non-zero is True.",
    de: `The bool() function converts a value to a boolean (True or False). When given the integer 0, it returns False because 0 is "falsy" in Python - it evaluates to False in boolean contexts.

bool() truthiness:
• bool(0) = False (zero is falsy)
• bool(1) = True (non-zero is truthy)
• bool(-1) = True (even negatives are truthy)
• Only 0 is False; all other numbers are True

Falsy values in Python:
• 0 (zero integer)
• 0.0 (zero float)
• False (boolean False)
• None (None value)
• "" (empty string)
• [] (empty list)
• {} (empty dict)
• set() (empty set)
• () (empty tuple)

Truthy values:
• All non-zero numbers: 1, -1, 3.14, 0.1, etc.
• All non-empty sequences: [1, 2], "hello", etc.
• True (boolean True)
• Most objects

Why this matters:
• Used in if statements: if value: (checks truthiness)
• Used in loops: while value: (continues if truthy)
• Used in boolean operations: value and other
• Used in comprehensions: [x for x in items if x]

Common pattern:
• Check if number is non-zero: if number: ...
• Check if list is non-empty: if items: ...
• Check if string is non-empty: if text: ...

Example: bool(0) returns False. This is used in conditional statements: if number: print("Non-zero") only prints when number is not 0.
`
  }),
  (_i: number) => ({ 
    q: `Result of bool(1)?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Non-zero numbers are Truthy.",
    de: `The bool() function converts a value to a boolean. When given the integer 1 (or any non-zero number), it returns True because non-zero numbers are "truthy" in Python - they evaluate to True in boolean contexts.

Truthiness of numbers:
• bool(1) = True (non-zero is truthy)
• bool(42) = True (any positive non-zero)
• bool(-1) = True (even negatives are truthy)
• bool(0.1) = True (even tiny numbers)
• Only 0 (and 0.0) is False

Why numbers are truthy:
• Represents "something exists" vs "nothing"
• Useful for checking if value is non-zero
• Common pattern: if count: ... (only if non-zero)
• Natural way to check for presence/absence

Boolean conversion:
• In if statements: if number: (automatically converts)
• In while loops: while count: (checks truthiness)
• In boolean operations: number and other
• Explicit conversion: bool(number)

Common uses:
• Check if counter is non-zero: if count: print("Has items")
• Check if value exists: if result: process(result)
• Guard clauses: if not value: return early

Edge cases:
• bool(0) = False (only zero is falsy)
• bool(0.0) = False (float zero too)
• bool(0j) = False (complex zero)
• All others are True

Example: bool(1) returns True. This allows natural checking: if user_count: print(f"{user_count} users") only prints when there are users.
`
  }),
  (_i: number) => ({ 
    q: `Result of bool("")?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Empty strings are Falsy.",
    de: `Empty strings ("") are falsy in Python - they evaluate to False in boolean contexts. This is because an empty string represents "no content" or "absence of text," which is naturally False.

String truthiness:
• bool("") = False (empty string is falsy)
• bool("hello") = True (non-empty is truthy)
• bool(" ") = True (space is a character!)
• Only "" is False; all other strings are True

Why empty strings are falsy:
• Represents "no text" vs "has text"
• Useful for checking if string has content
• Common pattern: if text: ... (only if non-empty)
• Natural way to check for presence

Important distinction:
• "" is falsy (no characters)
• " " is truthy (contains a space character!)
• "\n" is truthy (contains newline)
• Only truly empty string is falsy

Common uses:
• Check if input exists: if user_input: ...
• Validate strings: if not name: raise ValueError
• Guard clauses: if not message: return
• Process only non-empty: if text: process(text)

Checking for empty:
• if not text: (True when empty)
• if text == "": (explicit check)
• if len(text) == 0: (length check)
• if text: (most Pythonic - checks truthiness)

Example: bool("") returns False. This is used to validate input: if not name: print("Name required") - only prints when name is empty.
`
  }),
  (_i: number) => ({ 
    q: `Result of bool("hello")?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Non-empty strings are Truthy.",
    de: `Non-empty strings are truthy in Python - they evaluate to True in boolean contexts. Any string containing at least one character (even a single space) is truthy, representing "has content."

String truthiness:
• bool("hello") = True (non-empty is truthy)
• bool("a") = True (even single character)
• bool(" ") = True (space is a character!)
• bool("\n") = True (newline is a character!)
• Only "" (empty) is False

Why strings are truthy:
• Represents "has text" vs "no text"
• Useful for checking if string has content
• Common pattern: if text: ... (only if non-empty)
• Natural validation pattern

Important notes:
• Any non-empty string is True
• Even whitespace-only strings are True: bool("   ") = True
• Only truly empty string "" is False
• Single character strings are True: bool("a") = True

Common uses:
• Validate input: if username: save(username)
• Check if text exists: if message: send(message)
• Process only non-empty: if user_input: process()
• Guard clauses: if not text: return

Checking for non-empty:
• if text: (most Pythonic)
• if len(text) > 0: (explicit length check)
• if text != "": (explicit comparison)
• if text.strip(): (checks if has non-whitespace)

Example: bool("hello") returns True. This allows natural validation: if email: send_email(email) only sends when email has content.
`
  }),
  (_i: number) => ({ 
    q: `Result of bool([])?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Empty lists are Falsy.",
    de: `Empty lists ([]) are falsy in Python - they evaluate to False in boolean contexts. This is because an empty list represents "no items" or "absence of data," which is naturally False.

List truthiness:
• bool([]) = False (empty list is falsy)
• bool([1, 2]) = True (non-empty is truthy)
• bool([0]) = True (even if contains 0, list itself is truthy!)
• Only [] is False; all other lists are True

Why empty lists are falsy:
• Represents "no items" vs "has items"
• Useful for checking if list has content
• Common pattern: if items: ... (only if non-empty)
• Natural way to check for presence

Important distinction:
• [] is falsy (no elements)
• [0] is truthy (has one element, even though it's 0!)
• [False] is truthy (has one element, even though it's False!)
• Only truly empty list is falsy

Common uses:
• Check if list has items: if items: process(items)
• Validate lists: if not data: return []
• Guard clauses: if not results: return None
• Process only non-empty: if numbers: calculate(numbers)

Checking for empty:
• if not items: (True when empty)
• if items == []: (explicit check)
• if len(items) == 0: (length check)
• if items: (most Pythonic - checks truthiness)

Example: bool([]) returns False. This is used to check for empty collections: if not items: print("No items to process") - only prints when list is empty.
`
  }),
  (_i: number) => ({ 
    q: `Result of bool([1, 2])?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Non-empty lists are Truthy.",
    de: `Non-empty lists are truthy in Python - they evaluate to True in boolean contexts. Any list containing at least one element is truthy, regardless of what those elements are (even if the elements themselves are falsy).

List truthiness:
• bool([1, 2]) = True (non-empty is truthy)
• bool([0]) = True (even if contains 0!)
• bool([False]) = True (even if contains False!)
• bool([[]]) = True (even if contains empty list!)
• Only [] (empty) is False

Why lists are truthy:
• Represents "has items" vs "no items"
• Useful for checking if list has content
• Common pattern: if items: ... (only if non-empty)
• Natural validation pattern

Important distinction:
• The list's truthiness is independent of its contents
• [0] is True because the list has elements, even though 0 is falsy
• [False] is True because the list has elements, even though False is falsy
• [None] is True because the list has elements

Common uses:
• Check if list has items: if results: display(results)
• Validate data: if numbers: calculate_average(numbers)
• Process only non-empty: if users: send_notifications(users)
• Guard clauses: if not items: return early

Checking for non-empty:
• if items: (most Pythonic)
• if len(items) > 0: (explicit length check)
• if items != []: (explicit comparison)

Example: bool([1, 2]) returns True. This allows natural checking: if products: show_products(products) only displays when there are products to show.
`
  }),
  (_i: number) => ({ 
    q: `Result of bool(None)?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "None is Falsy.",
    de: `None is falsy in Python - it evaluates to False in boolean contexts. None represents the absence of a value or "no value," which naturally evaluates to False.

None truthiness:
• bool(None) = False (None is falsy)
• None is a singleton object (only one None exists)
• Used to represent "no value" or "undefined"
• Common default value for optional parameters

Why None is falsy:
• Represents "nothing" vs "something"
• Useful for checking if value exists
• Common pattern: if value: ... (only if not None)
• Natural way to check for presence

Important distinction:
• None != False (None is not the same as False)
• None != 0 (None is not the same as 0)
• None != "" (None is not the same as empty string)
• But all are falsy: if not None: passes

Common uses:
• Check if value exists: if result: process(result)
• Validate parameters: if not value: raise ValueError
• Guard clauses: if value is None: return
• Optional parameters: def func(x=None): ...

Checking for None:
• if value is None: (most Pythonic - use 'is')
• if value == None: (works but not recommended)
• if not value: (checks if falsy, not specifically None)
• if value is not None: (checks if not None)

Example: bool(None) returns False. This is used to check for missing values: if user is None: print("No user") - only prints when user is None.
`
  }),
  
  // 51-60: Basic Arithmetic Operations
  (_i: number) => ({ 
    q: `What is 10 / 2 in Python 3?`, 
    o: ["5.0", "5", "0", "Error"], 
    c: 0, 
    e: "The / operator always returns a float in Python 3.",
    de: `In Python 3, the division operator (/) always returns a floating-point number, even when the result is a whole number. This is different from Python 2, where / performed integer division. The result is 5.0, not 5.

Division in Python 3:
• 10 / 2 = 5.0 (always returns float)
• 10 / 3 = 3.3333333333333335 (float)
• 5 / 1 = 5.0 (even whole numbers become floats)
• This change was made to prevent unexpected integer division

Python 2 vs Python 3:
• Python 2: 10 / 2 = 5 (integer division)
• Python 3: 10 / 2 = 5.0 (true division - always float)
• Python 2 & 3: 10 // 2 = 5 (floor division - integer)

Why this change:
• Prevents confusion about division behavior
• Makes division mathematically consistent
• Eliminates unexpected integer truncation
• More intuitive for most use cases

Getting integer results:
• Use // (floor division): 10 // 2 = 5
• Use int(): int(10 / 2) = 5
• But // is preferred for clarity

Example: 10 / 2 returns 5.0 (a float). If you need an integer, use 10 // 2 = 5 (floor division).
`
  }),
  (_i: number) => ({ 
    q: `What is 10 // 3?`, 
    o: ["3", "3.33", "4", "Error"], 
    c: 0, 
    e: "// is floor division.",
    de: `The // operator performs floor division (also called integer division or truncating division). It divides two numbers and returns the largest integer less than or equal to the result. For positive numbers, this means it truncates toward zero.

Floor division:
• 10 // 3 = 3 (fits 3 times, remainder 1)
• Returns integer (or float if operands are floats)
• Rounds down (toward negative infinity)
• Works with negative numbers too

How it works:
• 10 ÷ 3 = 3.333... → floor = 3
• 10 // 3 = 3 (largest integer ≤ 3.333)
• Similar to int(10 / 3) but different with negatives

With negatives:
• -10 // 3 = -4 (rounds down, away from zero)
• int(-10 / 3) = -3 (truncates toward zero)
• // rounds toward negative infinity, int() truncates toward zero

Use cases:
• Getting whole number of divisions
• Splitting items into groups
• Converting to integer after division
• Time calculations (hours, minutes)

Related:
• 10 % 3 = 1 (remainder after 10 // 3)
• divmod(10, 3) = (3, 1) (returns both // and %)

Example: 10 // 3 returns 3. This represents how many complete groups of 3 can be made from 10.
`
  }),
  (_i: number) => ({ 
    q: `What is 2 ** 3?`, 
    o: ["8", "6", "9", "Error"], 
    c: 0, 
    e: "** is the exponentiation operator.",
    de: `The ** operator performs exponentiation (raising a number to a power). It's Python's built-in operator for calculating powers, making it convenient and readable. 2 ** 3 means "2 to the power of 3" which equals 8.

Exponentiation syntax:
• 2 ** 3 = 8 (2 raised to the power of 3)
• base ** exponent = base ^ exponent (mathematically)
• Right-associative: 2 ** 3 ** 2 = 2 ** (3 ** 2) = 2 ** 9 = 512
• Works with floats: 2.5 ** 2 = 6.25

How it works:
• 2 ** 3 = 2 × 2 × 2 = 8
• 2 ** 0 = 1 (any number to power 0 is 1)
• 2 ** -1 = 0.5 (negative powers give fractions)
• 10 ** 2 = 100 (10 squared)

Common uses:
• Powers of 2: 2 ** 10 = 1024
• Squaring: x ** 2
• Cubing: x ** 3
• Scientific notation: 10 ** 6 = 1,000,000
• Calculating areas/volumes

Alternatives:
• math.pow(2, 3) = 8.0 (always returns float)
• pow(2, 3) = 8 (built-in function, can return int)
• 2 ** 3 is preferred (more readable and Pythonic)

Precedence:
• ** has highest precedence (right-associative)
• 2 ** 3 ** 2 = 2 ** 9 = 512 (not 8 ** 2 = 64)

Example: 2 ** 3 returns 8. This is Python's way of calculating 2 to the power of 3.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 % 3?`, 
    o: ["1", "3", "0", "Error"], 
    c: 0, 
    e: "% is the modulo operator (remainder).",
    de: `The % operator is the modulo operator - it returns the remainder after division. When you divide 10 by 3, you get 3 groups of 3 with 1 left over. That remainder (1) is what the modulo operator returns.

Modulo operation:
• 10 % 3 = 1 (remainder when 10 is divided by 3)
• 10 ÷ 3 = 3 with remainder 1
• Returns what's left after floor division
• Works with floats too: 10.5 % 3 = 1.5

How it works:
• Divide first number by second
• Return the remainder after division
• 10 % 3: 10 ÷ 3 = 3 remainder 1, so 10 % 3 = 1
• 10 % 5: 10 ÷ 5 = 2 remainder 0, so 10 % 5 = 0

Common uses:
• Checking even/odd: n % 2 (0 = even, 1 = odd)
• Wrapping values: index % length (keeps index in range)
• Finding divisors: n % d == 0 (d divides n)
• Time calculations: seconds % 60 (seconds within minute)
• Hashtables: hash % size (bucket index)

With negatives:
• -10 % 3 = 2 (sign of result matches divisor)
• Python's % follows mathematical definition
• Different from some languages (like C)

Related operators:
• 10 // 3 = 3 (floor division - how many times it fits)
• 10 % 3 = 1 (remainder - what's left)
• divmod(10, 3) = (3, 1) (returns both // and %)

Example: 10 % 3 returns 1. This is useful for checking divisibility: if number % 3 == 0: print("Divisible by 3").
`
  }),
  (_i: number) => ({ 
    q: `What is -5?`, 
    o: ["Negative five", "Error", "5", "None"], 
    c: 0, 
    e: "Unary minus creates negative number.",
    de: `The unary minus operator (-) negates a number, creating its negative counterpart. It's called "unary" because it operates on a single operand (unlike binary operators like + which operate on two). -5 is the negative version of 5.

Unary minus:
• -5 = negative five
• Negates the value: -5 is the opposite of 5
• Creates a negative number from a positive
• Can negate variables too: -x

How it works:
• -5 means "negative 5" or "minus 5"
• Changes the sign: positive → negative
• -(-5) = 5 (double negation returns original)
• Works with floats: -3.14 = -3.14

Use cases:
• Representing negative values
• Subtracting (can write x - y as x + -y)
• Inverting signs: -balance (opposite of balance)
• Temperature below zero: -10°C
• Debt/losses in finance

With variables:
• x = 5
• -x = -5 (negates x's value)
• -(-x) = x (double negation)

Important notes:
• -5 is not "subtract 5" (that requires two operands)
• -5 is a literal (a complete expression)
• Can use in expressions: 10 + -5 = 5

Comparison:
• -5 (unary minus) - negates a number
• 10 - 5 (binary minus) - subtraction operation

Example: -5 is negative five. This represents the value five below zero. In Python, -5 is a complete expression that evaluates to negative five.
`
  }),
  (_i: number) => ({ 
    q: `What is +5?`, 
    o: ["Positive five", "Error", "-5", "None"], 
    c: 0, 
    e: "Unary plus is allowed but doesn't change value.",
    de: `The unary plus operator (+) is allowed in Python but doesn't change the value of a number. It's essentially a no-op (no operation) - it returns the number unchanged. +5 is just 5. However, it can be useful for code clarity or in certain expressions.

Unary plus:
• +5 = 5 (doesn't change value)
• Creates no-op: +x returns x unchanged
• Valid syntax but has no effect
• Less commonly used than unary minus

Why it exists:
• Symmetry with unary minus
• Code clarity (emphasize positive value)
• Type hints/annotations
• May convert to int/float in some contexts

Behavior:
• +5 = 5 (no change)
• +(-5) = -5 (applying + doesn't negate)
• +(3.14) = 3.14 (works with floats too)
• +x = x (for any number x)

Use cases:
• Code clarity: +balance (emphasize positive)
• Type conversion in expressions
• Consistency in code style
• Mathematical notation

Rare but valid:
• x = +5 (assigns 5, not different from x = 5)
• result = +value (does nothing, but valid)
• print(+10) (prints 10, same as print(10))

Comparison:
• +5 = 5 (unary plus - no change)
• -5 = -5 (unary minus - negates)

Example: +5 is simply 5. While valid syntax, it has no effect. Most Python code doesn't use unary plus unless needed for clarity or specific use cases.
`
  }),
  (_i: number) => ({ 
    q: `What is 2 * 3 + 4?`, 
    o: ["10", "14", "18", "Error"], 
    c: 0, 
    e: "Multiplication before addition (PEMDAS).",
    de: `Python follows the standard order of operations (PEMDAS: Parentheses, Exponents, Multiplication/Division, Addition/Subtraction). Multiplication has higher precedence than addition, so 2 * 3 is calculated first, then 4 is added to the result.

Order of operations (PEMDAS):
• Parentheses first
• Exponents (powers) next
• Multiplication and Division (left to right)
• Addition and Subtraction (left to right)

Step-by-step:
• 2 * 3 + 4
• First: 2 * 3 = 6 (multiplication first)
• Then: 6 + 4 = 10 (addition second)
• Result: 10

Operator precedence:
• ** (exponentiation) - highest
• *, /, //, % (multiplication, division) - medium-high
• +, - (addition, subtraction) - medium
• Parentheses override precedence

To change order:
• Use parentheses: (2 * 3) + 4 = 10 (same result)
• Or: 2 * (3 + 4) = 2 * 7 = 14 (different result!)

Common mistakes:
• 2 * 3 + 4 ≠ 2 * 7 (would be 14)
• Must do multiplication first: 2 * 3 = 6, then 6 + 4 = 10

Best practice:
• Use parentheses for clarity, even when not needed
• Makes code more readable
• Prevents errors and misunderstandings

Example: 2 * 3 + 4 evaluates to 10. Multiplication (2 * 3 = 6) happens before addition (6 + 4 = 10) due to operator precedence.
`
  }),
  (_i: number) => ({ 
    q: `What is (2 + 3) * 4?`, 
    o: ["20", "14", "18", "Error"], 
    c: 0, 
    e: "Parentheses change order of operations.",
    de: `Parentheses override the normal order of operations in Python. When you use parentheses, the expression inside is evaluated first, regardless of operator precedence. (2 + 3) * 4 calculates 2 + 3 first (which equals 5), then multiplies by 4 to get 20.

Parentheses effect:
• (2 + 3) * 4
• First: (2 + 3) = 5 (parentheses evaluated first)
• Then: 5 * 4 = 20 (multiplication)
• Result: 20

Without parentheses:
• 2 + 3 * 4 = 2 + 12 = 14 (multiplication first)
• Parentheses change the result!

How parentheses work:
• Highest precedence (evaluated first)
• Override normal operator precedence
• Can nest: ((2 + 3) * 4) / 2
• Used for clarity even when not needed

Common uses:
• Change order: (a + b) * c (add first, then multiply)
• Group expressions: (x + y) * (x - y)
• Function arguments: func(a + b, c * d)
• Clarity: (2 * 3) + 4 (makes intent clear)

Best practices:
• Use parentheses for clarity
• Even when not needed, they improve readability
• Prevents operator precedence errors
• Makes code easier to understand

Example: (2 + 3) * 4 evaluates to 20. The parentheses force addition to happen first (2 + 3 = 5), then multiplication (5 * 4 = 20), giving a different result than 2 + 3 * 4 = 14.
`
  }),
  (_i: number) => ({ 
    q: `What is 2 ** 2 ** 3?`, 
    o: ["256", "64", "512", "Error"], 
    c: 0, 
    e: "Exponentiation is right-associative: 2**(2**3) = 2**8 = 256.",
    de: `Exponentiation in Python is right-associative, meaning it groups from right to left. 2 ** 2 ** 3 is evaluated as 2 ** (2 ** 3), not (2 ** 2) ** 3. This matches mathematical convention for powers.

Right-associativity:
• 2 ** 2 ** 3 = 2 ** (2 ** 3)
• NOT (2 ** 2) ** 3
• Groups from right to left
• Matches mathematical convention

Step-by-step:
• 2 ** 2 ** 3
• First: 2 ** 3 = 8 (rightmost exponentiation)
• Then: 2 ** 8 = 256 (left exponentiation)
• Result: 256

If it were left-associative:
• (2 ** 2) ** 3 = 4 ** 3 = 64 (different result!)

Mathematical convention:
• a^b^c = a^(b^c) (standard math notation)
• Python follows this convention
• Right-associative for exponentiation

Other operators:
• Most operators are left-associative: 10 - 5 - 2 = (10 - 5) - 2 = 3
• Exponentiation is right-associative: 2 ** 3 ** 2 = 2 ** (3 ** 2) = 512

Best practice:
• Use parentheses for clarity: 2 ** (2 ** 3)
• Makes intent explicit
• Prevents confusion

Example: 2 ** 2 ** 3 evaluates to 256. It's calculated as 2 ** (2 ** 3) = 2 ** 8 = 256, following right-associativity.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 / 0?`, 
    o: ["ZeroDivisionError", "0", "infinity", "None"], 
    c: 0, 
    e: "Division by zero raises ZeroDivisionError.",
    de: `Dividing by zero in Python raises a ZeroDivisionError exception. This is mathematically undefined and Python prevents this operation by raising an error. You cannot divide any number by zero - it's not valid mathematically or in Python.

Division by zero:
• 10 / 0 raises ZeroDivisionError
• 10 // 0 raises ZeroDivisionError
• 10 % 0 raises ZeroDivisionError
• Any division by zero causes an error

Why this happens:
• Mathematically undefined (can't divide by zero)
• Python prevents invalid operations
• Raises exception to signal the error
• Must be handled or program crashes

The error:
• Exception type: ZeroDivisionError
• Message: "division by zero"
• Stops program execution unless caught
• Common mistake in calculations

Handling the error:
• Use try-except to catch it
• Check before dividing: if divisor != 0:
• Provide default values for edge cases
• Validate input to prevent division by zero

Example handling:
try:
    result = 10 / 0
except ZeroDivisionError:
    result = None  # Handle the error

Prevention:
• Check before dividing: if y != 0: x / y
• Validate input: assert divisor != 0
• Use default values: x / y if y != 0 else 0

Example: 10 / 0 raises ZeroDivisionError. This must be caught with try-except or prevented by checking that the divisor is not zero before dividing.
`
  }),
  
  // 61-70: Type Mixing and Operations
  (_i: number) => ({ 
    q: `Value of type(3.14 + 1)?`, 
    o: ["<class 'float'>", "<class 'int'>", "<class 'str'>", "None"], 
    c: 0, 
    e: "Adding an int to a float results in a float.",
    de: `When you add an integer to a float in Python, the result is always a float. Python automatically promotes the integer to a float before performing the addition. This is because floats have higher precision and can represent both integers and decimals.

Type promotion:
• 3.14 + 1 = 4.14 (int is promoted to float)
• type(3.14 + 1) = <class 'float'>
• Integer is converted to float: 1 → 1.0
• Result is always float when mixing types

Why this happens:
• Float can represent ints: 1.0 represents 1
• Int cannot represent floats: 1 cannot represent 1.5
• Float has higher precision
• Promotes to preserve information

Rule:
• int + float = float
• float + int = float
• int + int = int
• float + float = float

Examples:
• 3 + 1.5 = 4.5 (float)
• 10 + 2.0 = 12.0 (float)
• 5 + 5 = 10 (int - both ints)

Best practice:
• Be aware of type promotion
• Explicit conversion if needed: int(3.14 + 1) = 4
• Check types if important: isinstance(result, float)

Example: type(3.14 + 1) returns <class 'float'>. The integer 1 is promoted to 1.0, and the result 4.14 is a float.
`
  }),
  (_i: number) => ({ 
    q: `What does "A" represent in Python?`, 
    o: ["A single character string", "An integer", "A list", "A char type"], 
    c: 0, 
    e: "Python doesn't have a 'char' type; single characters are strings.",
    de: `In Python, single characters like "A" are strings of length 1. Python doesn't have a separate 'char' type like C, Java, or C++ do. Every character is a string, even if it's just one character long.

Python's string type:
• "A" is a string of length 1
• No separate char type
• All characters are strings
• Consistent with Python's philosophy

Type checking:
• type("A") = <class 'str'>
• len("A") = 1 (single character)
• "A"[0] = "A" (accessing first character)
• Still a string, not a char

Why no char type:
• Simplifies the language
• Consistent handling of strings
• No need to convert between char and string
• Easier to work with

Comparison with other languages:
• C/Java: char 'A' (separate type)
• Python: str "A" (always string)
• No conversion needed between types

Working with single characters:
• "A" is already a string
• Can use string methods: "A".lower() = "a"
• Can concatenate: "A" + "B" = "AB"
• Can iterate: for char in "ABC":

Important:
• "A" and 'A' are identical (both strings)
• Single characters are not special
• Treat like any other string

Example: "A" represents a single character string. There's no char type - it's just a string with one character. This simplifies Python's type system.
`
  }),
  (_i: number) => ({ 
    q: `How do you find the data type of a variable?`, 
    o: ["type(variable)", "what(variable)", "kind(variable)", "check(variable)"], 
    c: 0, 
    e: "type() returns the class of an object.",
    de: `The type() function is Python's built-in way to find the data type (class) of any variable or value. It returns the class object that represents the type. This is essential for debugging, type checking, and understanding what kind of data you're working with.

type() function:
• type(variable) returns the class of the variable
• Works with any object in Python
• Returns <class 'type_name'> format
• Essential for type checking

How to use:
• type(42) = <class 'int'>
• type("hello") = <class 'str'>
• type([1, 2]) = <class 'list'>
• type(x) where x is a variable

Common uses:
• Debugging: check what type a variable is
• Type checking: if type(x) == int:
• Understanding code: see what an object is
• Validation: verify expected types

Alternative: isinstance()
• isinstance(x, int) returns True/False
• More flexible (checks inheritance)
• Preferred for type checking
• Works with subclasses

Examples:
• type(5) = <class 'int'>
• type(3.14) = <class 'float'>
• type("text") = <class 'str'>
• type([1, 2]) = <class 'list'>

Best practice:
• Use type() for exact type checking
• Use isinstance() for type checking (more Pythonic)
• Use type() for debugging/exploration

Important:
• type() returns the class object
• Can compare: type(x) == int
• But isinstance(x, int) is preferred

Example: type(variable) returns the class of the variable. This is the standard way to inspect the type of any object in Python.
`
  }),
  (_i: number) => ({ 
    q: `Which quotes are valid for strings?`, 
    o: ["Both ' and \"", "Only '", "Only \"", "Only `"], 
    c: 0, 
    e: "Python supports both single and double quotes.",
    de: `Python supports both single quotes (') and double quotes (") for creating strings. They work identically - there's no functional difference. The choice between them is a matter of style and convenience, especially when your string contains one type of quote.

Valid string delimiters:
• Single quotes: 'text'
• Double quotes: "text"
• Triple single: '''text'''
• Triple double: """text"""
• Both work identically

Why both exist:
• Convenience when string contains quotes
• Use 'text' when string has "
• Use "text" when string has '
• Avoids escaping quotes

Examples:
• 'He said "Hello"' (no escaping needed)
• "It's a string" (no escaping needed)
• 'It\'s a string' (escaping needed)
• "He said \"Hello\"" (escaping needed)

Style guide (PEP 8):
• Be consistent within a module
• Pick one style and stick with it
• Triple double quotes for docstrings
• Use opposite quote when string contains quote

Comparison:
• 'text' == "text" → True (identical)
• type('text') == type("text") → True
• No performance difference
• No functional difference

Best practice:
• Choose one style per module
• Use opposite quote to avoid escaping
• Triple quotes for multi-line strings

Example: Both 'text' and "text" are valid and identical in Python. Choose based on what quotes your string contains to minimize escaping.
`
  }),
  (_i: number) => ({ 
    q: `What is "2" + "3"?`, 
    o: ["23", "5", "Error", "None"], 
    c: 0, 
    e: "String concatenation, not addition.",
    de: `The + operator with strings performs concatenation (joining strings together), not mathematical addition. When both operands are strings, + concatenates them end-to-end. "2" + "3" results in "23" (the string "two-three"), not 5 (the number five).

String concatenation:
• "2" + "3" = "23" (concatenates, doesn't add)
• Joins strings together
• Creates new string
• No mathematical addition

Why this happens:
• Both operands are strings
• + with strings means concatenate
• Python doesn't auto-convert
• Type determines behavior

To get 5:
• Convert first: int("2") + int("3") = 5
• Or: float("2") + float("3") = 5.0
• Must explicitly convert strings to numbers

Common mistake:
• "2" + "3" ≠ 5 (it's "23")
• Must convert: int("2") + int("3") = 5
• Remember: strings concatenate, numbers add

When concatenation happens:
• str + str = concatenation
• str + int = TypeError (can't mix types)
• Must convert: str + str(int)

Example: "2" + "3" returns "23" (string concatenation). To add numbers, convert strings first: int("2") + int("3") = 5.
`
  }),
  (_i: number) => ({ 
    q: `What is int("2") + int("3")?`, 
    o: ["5", "23", "Error", "None"], 
    c: 0, 
    e: "Convert strings to ints before adding.",
    de: `To perform mathematical addition on numeric strings, you must first convert them to numbers using int() or float(). int("2") + int("3") converts both strings to integers first, then adds them to get 5 (the number five).

Type conversion:
• int("2") = 2 (string → integer)
• int("3") = 3 (string → integer)
• 2 + 3 = 5 (integer addition)
• Result: 5 (integer)

Step-by-step:
• int("2") converts "2" to 2
• int("3") converts "3" to 3
• 2 + 3 performs integer addition
• Result is 5 (not "23" or "5")

Why convert:
• Strings concatenate with +
• Numbers add with +
• Must convert to get mathematical addition
• int() parses numeric strings

Common pattern:
• User input comes as strings
• input() returns strings
• Must convert: int(input("Enter number: "))
• Then perform math

Alternatives:
• float("2.5") + float("3.5") = 6.0
• For decimals, use float()
• int() truncates decimals

Example: int("2") + int("3") returns 5. The strings are converted to integers first, then added mathematically. This is how you perform addition on numeric strings.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello" == "Hello"?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "String comparison is case-sensitive.",
    de: `String comparison in Python is case-sensitive, meaning uppercase and lowercase letters are considered different. "hello" and "Hello" are not equal because 'h' and 'H' are different characters. Python compares strings character by character, and case matters.

Case sensitivity:
• "hello" == "Hello" → False
• Case matters in comparisons
• 'h' ≠ 'H' (different characters)
• Must match exactly (case and characters)

Why case-sensitive:
• 'A' and 'a' are different Unicode characters
• Reflects real-world differences
• More precise comparison
• Standard in most languages

Case-insensitive comparison:
• Use .lower(): "hello".lower() == "Hello".lower() → True
• Use .upper(): "hello".upper() == "Hello".upper() → True
• Use .casefold(): "hello".casefold() == "Hello".casefold() → True
• Compare normalized versions

Common use:
• User input: if input().lower() == "yes":
• Case-insensitive matching
• Password checking (usually case-sensitive)
• Username validation (case-sensitive typically)

Best practices:
• Be aware of case sensitivity
• Normalize before comparing if needed
• Use .lower() or .casefold() for case-insensitive
• Document your case sensitivity rules

Example: "hello" == "Hello" returns False. Python string comparison is case-sensitive. For case-insensitive comparison, use "hello".lower() == "Hello".lower() which returns True.
`
  }),
  (_i: number) => ({ 
    q: `What is "apple" < "banana"?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Strings are compared lexicographically.",
    de: `String comparison in Python uses lexicographic (dictionary) ordering. Strings are compared character by character from left to right, using the Unicode/ASCII value of each character. "apple" comes before "banana" alphabetically, so "apple" < "banana" is True.

Lexicographic comparison:
• "apple" < "banana" → True (alphabetical order)
• Compares character by character
• Uses Unicode/ASCII values
• Same as dictionary order

How it works:
• Compare first characters: 'a' vs 'b'
• 'a' < 'b' (ASCII 97 < 98)
• If equal, compare next character
• Continue until difference found

Examples:
• "apple" < "banana" → True
• "apple" < "app" → False (longer prefix is "greater")
• "A" < "a" → True (uppercase before lowercase in ASCII)
• "apple" < "Apple" → False (depends on first character)

Unicode order:
• Uppercase before lowercase: "A" < "a"
• Numbers before letters: "1" < "a"
• Special characters have specific positions
• Follows ASCII/Unicode ordering

Use cases:
• Sorting strings: sorted(["banana", "apple"]) = ["apple", "banana"]
• Searching: binary search on sorted list
• Range checking: if "apple" <= word <= "banana"
• Dictionary ordering

Important:
• Case matters: "A" < "a" is True
• Length matters: "app" < "apple" is True
• Character order follows Unicode

Example: "apple" < "banana" returns True because "apple" comes before "banana" in dictionary order. This is how Python sorts and compares strings.
`
  }),
  (_i: number) => ({ 
    q: `What is "a" in "abc"?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in operator checks substring membership.",
    de: `The in operator checks if a substring is contained within a string. It returns True if the substring is found anywhere in the string, False otherwise. "a" in "abc" checks if "a" is a substring of "abc", which it is, so it returns True.

Substring membership:
• "a" in "abc" → True ("a" is in "abc")
• Returns boolean (True/False)
• Checks if substring exists
• Case-sensitive check

How it works:
• Searches for substring in string
• Returns True if found
• Returns False if not found
• Can find multi-character substrings too

Examples:
• "a" in "abc" → True
• "bc" in "abc" → True (multi-character substring)
• "d" in "abc" → False (not found)
• "A" in "abc" → False (case-sensitive)

Case sensitivity:
• "A" in "abc" → False (case matters)
• "a" in "ABC" → False (case matters)
• Use .lower() for case-insensitive: "A".lower() in "abc".lower() → True

Common uses:
• Validation: if "@" in email:
• Checking prefixes: if "http" in url:
• Filtering: [s for s in strings if "error" in s]
• Pattern matching: if keyword in text:

Related operators:
• not in: "x" not in "abc" → True
• Opposite of in
• Useful for negative checks

Example: "a" in "abc" returns True because "a" is a substring of "abc". The in operator is very useful for checking if strings contain certain patterns or characters.
`
  }),
  (_i: number) => ({ 
    q: `What is "a" not in "xyz"?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "not in checks if substring is absent.",
    de: `The not in operator is the opposite of in - it returns True if the substring is NOT found in the string. "a" not in "xyz" checks if "a" is absent from "xyz", which it is, so it returns True. This is useful for negative checks.

not in operator:
• "a" not in "xyz" → True ("a" is not in "xyz")
• Opposite of in operator
• Returns True when substring is absent
• Returns False when substring is present

How it works:
• Checks if substring is NOT in string
• True if not found
• False if found
• Same case-sensitivity as in

Examples:
• "a" not in "xyz" → True (not found)
• "x" not in "xyz" → False (found)
• "hello" not in "hello world" → False (found)
• "abc" not in "xyz" → True (not found)

Logical relationship:
• "a" not in "abc" = not ("a" in "abc") = not True = False
• "a" not in "xyz" = not ("a" in "xyz") = not False = True
• These are equivalent

Common uses:
• Validation: if " " not in username: (no spaces allowed)
• Guard clauses: if char not in valid_chars: return
• Filtering: [s for s in strings if "error" not in s]
• Negative checks: if invalid_pattern not in text:

Best practice:
• Use not in for negative checks (more readable)
• Clearer than not ("a" in "xyz")
• More Pythonic

Example: "a" not in "xyz" returns True because "a" is not found in "xyz". This is the negation of the in operator.
`
  }),
  
  // 71-80: String Methods - Case Operations
  (_i: number) => ({ 
    q: `What is "Python".upper()?`, 
    o: ["PYTHON", "python", "Python", "Error"], 
    c: 0, 
    e: "upper() converts string to uppercase.",
    de: `The upper() method converts all characters in a string to uppercase (capital letters). It returns a new string with all lowercase letters converted to uppercase, leaving non-alphabetic characters unchanged. This is useful for case-insensitive comparisons and formatting.

upper() method:
• "Python".upper() = "PYTHON"
• Converts all lowercase to uppercase
• Non-alphabetic characters unchanged
• Returns new string (original unchanged)

How it works:
• Scans string character by character
• Converts 'a'-'z' to 'A'-'Z'
• Leaves 'A'-'Z', numbers, symbols unchanged
• Creates new string (strings are immutable)

Examples:
• "Python".upper() = "PYTHON"
• "hello123".upper() = "HELLO123"
• "Hello World!".upper() = "HELLO WORLD!"
• "Python".upper() = "PYTHON" (no change needed)

Common uses:
• Case-insensitive comparison: "Hello".upper() == "hello".upper()
• Standardizing input: user_input.upper()
• Display formatting: titles.upper()
• Normalizing data

Best practice:
• Use with == for case-insensitive checks
• Or use .casefold() for Unicode-aware comparison
• Remember: creates new string (immutable)

Example: "Python".upper() returns "PYTHON". All lowercase letters are converted to uppercase, while numbers and symbols remain unchanged.
`
  }),
  (_i: number) => ({ 
    q: `What is "PYTHON".lower()?`, 
    o: ["python", "PYTHON", "Python", "Error"], 
    c: 0, 
    e: "lower() converts string to lowercase.",
    de: `The lower() method converts all characters in a string to lowercase (small letters). It returns a new string with all uppercase letters converted to lowercase, leaving non-alphabetic characters unchanged. This is one of Python's most commonly used string methods.

lower() method:
• "PYTHON".lower() = "python"
• Converts all uppercase to lowercase
• Non-alphabetic characters unchanged
• Returns new string (original unchanged)

How it works:
• Scans string character by character
• Converts 'A'-'Z' to 'a'-'z'
• Leaves 'a'-'z', numbers, symbols unchanged
• Creates new string (strings are immutable)

Examples:
• "PYTHON".lower() = "python"
• "HELLO123".lower() = "hello123"
• "Hello World!".lower() = "hello world!"
• "Python".lower() = "python"

Common uses:
• Case-insensitive comparison: "Hello".lower() == "HELLO".lower()
• Normalizing user input: input().lower()
• Converting to lowercase for storage
• Matching/searching regardless of case

Best practice:
• Use for case-insensitive comparisons
• Normalize input before processing
• Store lowercase for consistency
• Remember: creates new string

Example: "PYTHON".lower() returns "python". All uppercase letters are converted to lowercase, while numbers and symbols remain unchanged.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".capitalize()?`, 
    o: ["Hello", "hello", "HELLO", "Error"], 
    c: 0, 
    e: "capitalize() makes first letter uppercase.",
    de: `The capitalize() method capitalizes the first character of a string and makes the rest lowercase. It returns a new string where only the first letter is uppercase and all other letters are lowercase. This is useful for formatting names, titles, or sentence beginnings.

capitalize() method:
• "hello".capitalize() = "Hello"
• First character → uppercase
• All other characters → lowercase
• Returns new string

How it works:
• Converts first character to uppercase
• Converts all other characters to lowercase
• Works on first character only
• Creates new string

Examples:
• "hello".capitalize() = "Hello"
• "HELLO".capitalize() = "Hello"
• "hELLO".capitalize() = "Hello"
• "hello world".capitalize() = "Hello world" (note: only first letter)

Important note:
• Only capitalizes first character
• "hello world".capitalize() = "Hello world" (not "Hello World")
• For each word, use .title() instead

Common uses:
• Formatting names: "john".capitalize() = "John"
• Sentence beginnings: "hello".capitalize() = "Hello"
• Single-word titles
• User input formatting

Best practice:
• Use for single words or sentence starts
• Use .title() for multi-word titles
• Remember: only affects first character

Example: "hello".capitalize() returns "Hello". The first letter 'h' becomes 'H', and all other letters become lowercase (none in this case).
`
  }),
  (_i: number) => ({ 
    q: `What is "hello world".title()?`, 
    o: ["Hello World", "hello world", "HELLO WORLD", "Error"], 
    c: 0, 
    e: "title() capitalizes each word.",
    de: `The title() method capitalizes the first letter of each word in a string and makes the rest lowercase. It returns a new string in "title case" where each word starts with an uppercase letter. This is useful for formatting titles, headings, or names.

title() method:
• "hello world".title() = "Hello World"
• First letter of each word → uppercase
• Rest of each word → lowercase
• Returns new string

How it works:
• Splits string by whitespace
• Capitalizes first letter of each word
• Makes rest of each word lowercase
• Joins words back together

Examples:
• "hello world".title() = "Hello World"
• "HELLO WORLD".title() = "Hello World"
• "hELLO wORLD".title() = "Hello World"
• "hello-world".title() = "Hello-World" (hyphen separates words)

Word boundaries:
• Words are separated by whitespace
• "hello-world".title() = "Hello-World" (hyphen treated as separator)
• "hello_world".title() = "Hello_World" (underscore treated as separator)

Common uses:
• Formatting titles: "python tutorial".title() = "Python Tutorial"
• Headings in documents
• Names and titles: "john smith".title() = "John Smith"
• Display formatting

Best practice:
• Use for multi-word titles
• Use .capitalize() for single words or sentences
• Be aware of word boundaries

Example: "hello world".title() returns "Hello World". The first letter of each word ("hello" and "world") is capitalized, creating title case formatting.
`
  }),
  (_i: number) => ({ 
    q: `What is "HeLLo".swapcase()?`, 
    o: ["hEllO", "hello", "HELLO", "Error"], 
    c: 0, 
    e: "swapcase() swaps case of all characters.",
    de: `The swapcase() method swaps the case of all alphabetic characters in a string. Uppercase letters become lowercase, and lowercase letters become uppercase. Non-alphabetic characters remain unchanged. It returns a new string with swapped cases.

swapcase() method:
• "HeLLo".swapcase() = "hEllO"
• Uppercase → lowercase
• Lowercase → uppercase
• Non-alphabetic unchanged
• Returns new string

How it works:
• Scans string character by character
• 'A'-'Z' → 'a'-'z' (uppercase to lowercase)
• 'a'-'z' → 'A'-'Z' (lowercase to uppercase)
• Numbers, symbols unchanged
• Creates new string

Examples:
• "HeLLo".swapcase() = "hEllO"
• "HELLO".swapcase() = "hello"
• "hello".swapcase() = "HELLO"
• "HeLLo123!".swapcase() = "hEllO123!" (numbers and symbols unchanged)

Common uses:
• Toggling case: convert uppercase to lowercase and vice versa
• Text transformations
• Formatting variations
• Special display effects

Best practice:
• Less commonly used than .upper() or .lower()
• Useful for toggling case
• Remember: creates new string

Example: "HeLLo".swapcase() returns "hEllO". Each letter's case is swapped: 'H'→'h', 'e'→'E', 'L'→'l', 'L'→'l', 'o'→'O'.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".islower()?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "islower() checks if all characters are lowercase.",
    de: `The islower() method returns True if all alphabetic characters in the string are lowercase and there is at least one alphabetic character. It returns False otherwise. Non-alphabetic characters are ignored in the check.

islower() method:
• "hello".islower() = True (all alphabetic lowercase)
• Returns boolean (True/False)
• Ignores non-alphabetic characters
• Requires at least one alphabetic character

How it works:
• Checks if all 'a'-'z' characters exist (lowercase)
• Ignores numbers, symbols, spaces
• Returns False if no alphabetic characters
• Returns False if any 'A'-'Z' exists

Examples:
• "hello".islower() = True
• "HELLO".islower() = False (has uppercase)
• "hello123".islower() = True (numbers ignored)
• "123".islower() = False (no alphabetic characters)
• "".islower() = False (empty string)

Edge cases:
• "hello WORLD".islower() = False (has uppercase)
• "123".islower() = False (no letters)
• "hello!".islower() = True (symbols ignored)

Common uses:
• Validation: check if string is all lowercase
• Input validation
• Format checking
• Data validation

Best practice:
• Use for validation checks
• Combine with .lower() for normalization
• Remember: requires at least one letter

Example: "hello".islower() returns True because all alphabetic characters ('h', 'e', 'l', 'l', 'o') are lowercase.
`
  }),
  (_i: number) => ({ 
    q: `What is "HELLO".isupper()?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "isupper() checks if all characters are uppercase.",
    de: `The isupper() method returns True if all alphabetic characters in the string are uppercase and there is at least one alphabetic character. It returns False otherwise. Non-alphabetic characters are ignored in the check.

isupper() method:
• "HELLO".isupper() = True (all alphabetic uppercase)
• Returns boolean (True/False)
• Ignores non-alphabetic characters
• Requires at least one alphabetic character

How it works:
• Checks if all 'A'-'Z' characters exist (uppercase)
• Ignores numbers, symbols, spaces
• Returns False if no alphabetic characters
• Returns False if any 'a'-'z' exists

Examples:
• "HELLO".isupper() = True
• "hello".isupper() = False (has lowercase)
• "HELLO123".isupper() = True (numbers ignored)
• "123".isupper() = False (no alphabetic characters)
• "".isupper() = False (empty string)

Edge cases:
• "HELLO world".isupper() = False (has lowercase)
• "123".isupper() = False (no letters)
• "HELLO!".isupper() = True (symbols ignored)

Common uses:
• Validation: check if string is all uppercase
• Input validation
• Format checking (e.g., acronyms)
• Data validation

Best practice:
• Use for validation checks
• Combine with .upper() for normalization
• Remember: requires at least one letter

Example: "HELLO".isupper() returns True because all alphabetic characters ('H', 'E', 'L', 'L', 'O') are uppercase.
`
  }),
  (_i: number) => ({ 
    q: `What is "Hello World".istitle()?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "istitle() checks if string is titlecased.",
    de: `The istitle() method returns True if the string is in title case (each word starts with an uppercase letter and the rest are lowercase). It returns False otherwise. A string is titlecased if uppercase characters may only follow uncased characters and lowercase characters may only follow cased characters.

istitle() method:
• "Hello World".istitle() = True (titlecased)
• Returns boolean (True/False)
• Checks if each word starts with uppercase
• Rest of each word must be lowercase

How it works:
• Checks if first letter of each word is uppercase
• Checks if rest of each word is lowercase
• Word boundaries are whitespace or non-alphabetic
• Returns False if any word doesn't match

Examples:
• "Hello World".istitle() = True
• "Hello world".istitle() = False ("world" not capitalized)
• "HELLO WORLD".istitle() = False (all uppercase)
• "Hello-World".istitle() = True
• "123 Hello".istitle() = True

Edge cases:
• "".istitle() = False (empty string)
• "Hello123".istitle() = True
• "Hello WORLD".istitle() = False

Common uses:
• Validation: check if string is properly titlecased
• Format validation
• Title checking
• Data validation

Best practice:
• Use for title format validation
• Combine with .title() for formatting
• Understand word boundaries

Example: "Hello World".istitle() returns True because each word starts with an uppercase letter ("Hello" and "World") and the rest are lowercase.
`
  }),
  (_i: number) => ({ 
    q: `What is "Hello".casefold()?`, 
    o: ["hello", "HELLO", "Hello", "Error"], 
    c: 0, 
    e: "casefold() returns casefolded string for caseless matching.",
    de: `The casefold() method returns a casefolded copy of the string. Casefolding is similar to lowercasing but more aggressive - it's designed for caseless matching. It converts all characters to lowercase and handles special Unicode characters correctly.

casefold() method:
• "Hello".casefold() = "hello"
• More aggressive than .lower()
• Handles Unicode special cases
• Returns new string for caseless matching

How it works:
• Similar to .lower() but more aggressive
• Handles special Unicode characters
• Converts to lowercase for comparison
• Better for internationalization

Examples:
• "Hello".casefold() = "hello"
• "HELLO".casefold() = "hello"
• "ß".casefold() = "ss" (special Unicode handling)
• "HELLO WORLD".casefold() = "hello world"

Difference from .lower():
• Most cases: same as .lower()
• Unicode: handles special characters better
• German ß → ss (casefold), ß (lower)
• Better for caseless matching

Common uses:
• Caseless string comparison
• Internationalization (i18n)
• Unicode-aware matching
• Better than .lower() for some languages

Best practice:
• Use for caseless matching (recommended)
• Better than .lower() for Unicode
• Use .lower() for display formatting
• Prefer over .lower() for comparisons

Example: "Hello".casefold() returns "hello". For most English strings, it's similar to .lower(), but it handles Unicode special characters better for international caseless matching.
`
  }),
  (_i: number) => ({ 
    q: `What is "Hello".isascii()?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "isascii() checks if all characters are ASCII.",
    de: `The isascii() method returns True if all characters in the string are ASCII characters. ASCII characters have codes in the range 0-127. This is useful for checking if a string contains only standard ASCII characters without Unicode or extended characters.

isascii() method:
• "Hello".isascii() = True (all ASCII)
• Returns boolean (True/False)
• Checks if all characters are ASCII (0-127)
• ASCII = American Standard Code for Information Interchange

ASCII range:
• Characters with codes 0-127
• Includes letters (a-z, A-Z), digits (0-9)
• Includes punctuation, spaces, control characters
• No extended Unicode characters

Examples:
• "Hello".isascii() = True
• "Hello123!".isascii() = True
• "Hello 世界".isascii() = False (contains Chinese)
• "Hello café".isascii() = False (contains é)
• "".isascii() = True (empty string is ASCII)

Common ASCII characters:
• Letters: a-z, A-Z
• Digits: 0-9
• Punctuation: !@#$%^&*()
• Spaces, tabs, newlines
• Control characters

Non-ASCII characters:
• Unicode characters: é, ñ, ü, 世界
• Extended Latin: à, è, ì, ò, ù
• Emojis: 😀, ❤️
• Non-Latin scripts: 中文, العربية

Common uses:
• Validation: ensure ASCII-only strings
• Compatibility checking
• Legacy system integration
• Network protocols (some require ASCII)

Best practice:
• Use when you need ASCII-only strings
• Check before encoding/transmission
• Be aware of Unicode support

Example: "Hello".isascii() returns True because all characters ('H', 'e', 'l', 'l', 'o') are standard ASCII characters with codes in the 0-127 range.
`
  }),
  
  // 81-90: String Methods - Search and Replace
  (_i: number) => ({ 
    q: `What is "hello".find("l")?`, 
    o: ["2", "1", "3", "Error"], 
    c: 0, 
    e: "find() returns first index of substring.",
    de: `The find() method returns the lowest index in the string where the substring is found. If the substring is not found, it returns -1. find() searches from left to right and returns the index of the first occurrence.

find() method:
• "hello".find("l") = 2 (first 'l' at index 2)
• Returns index (0-based) if found
• Returns -1 if not found
• Searches from left to right

How it works:
• Searches for substring in string
• Returns index where substring starts
• Returns -1 if not found
• No exception raised if not found

Examples:
• "hello".find("l") = 2 (first 'l')
• "hello".find("x") = -1 (not found)
• "hello".find("ll") = 2 (substring "ll")
• "hello".find("o") = 4

Index positions:
• "hello" = h(0), e(1), l(2), l(3), o(4)
• "l" found at index 2 and 3
• find() returns 2 (first occurrence)

Common uses:
• Finding substring position: idx = text.find("pattern")
• Checking existence: if text.find("x") != -1:
• Extracting after position
• String parsing

Alternative: .index()
• Similar but raises ValueError if not found
• find() returns -1, index() raises error
• Use find() for existence checking

Example: "hello".find("l") returns 2 because 'l' first appears at index 2 in the string "hello" (h=0, e=1, l=2).
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".rfind("l")?`, 
    o: ["3", "2", "1", "Error"], 
    c: 0, 
    e: "rfind() returns last index of substring.",
    de: `The rfind() method returns the highest index in the string where the substring is found. If the substring is not found, it returns -1. rfind() searches from right to left (reverse find) and returns the index of the last occurrence.

rfind() method:
• "hello".rfind("l") = 3 (last 'l' at index 3)
• Returns index (0-based) if found
• Returns -1 if not found
• Searches from right to left

How it works:
• Searches for substring starting from end
• Returns index where substring starts
• Returns -1 if not found
• Finds last occurrence

Examples:
• "hello".rfind("l") = 3 (last 'l')
• "hello".rfind("x") = -1 (not found)
• "hello".rfind("ll") = 2 (substring "ll")
• "hello".rfind("o") = 4

Index positions:
• "hello" = h(0), e(1), l(2), l(3), o(4)
• "l" found at index 2 and 3
• rfind() returns 3 (last occurrence)

Common uses:
• Finding last occurrence: idx = text.rfind("pattern")
• Parsing from end: find last separator
• Extracting filename from path
• Reverse string operations

Comparison with .find():
• find(): searches left to right, returns first
• rfind(): searches right to left, returns last
• Both return -1 if not found

Example: "hello".rfind("l") returns 3 because 'l' last appears at index 3 in the string "hello" (rfind searches from right to left).
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".index("l")?`, 
    o: ["2", "1", "3", "Error"], 
    c: 0, 
    e: "index() returns first index, raises error if not found.",
    de: `The index() method returns the lowest index in the string where the substring is found. If the substring is not found, it raises a ValueError exception. index() is similar to find() but raises an error instead of returning -1.

index() method:
• "hello".index("l") = 2 (first 'l' at index 2)
• Returns index (0-based) if found
• Raises ValueError if not found
• Searches from left to right

How it works:
• Searches for substring in string
• Returns index where substring starts
• Raises ValueError if not found
• Exception must be handled

Examples:
• "hello".index("l") = 2 (first 'l')
• "hello".index("x") = ValueError (not found)
• "hello".index("ll") = 2 (substring "ll")
• "hello".index("o") = 4

Comparison with .find():
• find(): returns -1 if not found (no exception)
• index(): raises ValueError if not found
• Both return same index if found
• find() is safer for existence checking

When to use:
• Use find() if you want -1 for not found
• Use index() if you expect substring exists
• Use find() for existence checking
• Use index() for required substring

Example: "hello".index("l") returns 2 because 'l' first appears at index 2. If "l" wasn't found, it would raise ValueError.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".count("l")?`, 
    o: ["2", "1", "3", "Error"], 
    c: 0, 
    e: "count() counts occurrences of substring.",
    de: `The count() method returns the number of non-overlapping occurrences of a substring in the string. It counts how many times the substring appears in the string. It's useful for frequency analysis and validation.

count() method:
• "hello".count("l") = 2 (appears twice)
• Returns integer count
• Returns 0 if not found
• Counts non-overlapping occurrences

How it works:
• Searches for substring in string
• Counts all occurrences
• Non-overlapping: "aaa".count("aa") = 1, not 2
• Returns 0 if substring not found

Examples:
• "hello".count("l") = 2
• "hello".count("x") = 0 (not found)
• "hello".count("ll") = 1 (substring)
• "hello".count("") = 6 (empty string counts positions)

Overlapping behavior:
• "aaa".count("aa") = 1 (non-overlapping)
• Counts don't overlap
• "aaaa".count("aa") = 2

Common uses:
• Frequency analysis: text.count("the")
• Validation: if password.count("!") >= 2:
• Character counting
• Pattern frequency

Important:
• Non-overlapping matches only
• Empty string counts all positions + 1
• Case-sensitive counting
• Works with multi-character substrings

Example: "hello".count("l") returns 2 because the character 'l' appears twice in "hello" (at indices 2 and 3).
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".startswith("he")?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "startswith() checks if string begins with substring.",
    de: `The startswith() method returns True if the string starts with the specified substring, False otherwise. It's useful for checking prefixes, file extensions, URLs, and validating string formats.

startswith() method:
• "hello".startswith("he") = True
• Returns boolean (True/False)
• Checks if string begins with substring
• Case-sensitive check

How it works:
• Checks if string starts with substring
• Compares from beginning
• Returns True if matches, False otherwise
• Case-sensitive

Examples:
• "hello".startswith("he") = True
• "hello".startswith("x") = False
• "hello".startswith("Hello") = False (case-sensitive)
• "hello".startswith("") = True (empty string always matches)

Common uses:
• File extensions: filename.startswith("http")
• URL checking: url.startswith("https://")
• Prefix validation
• Format checking

With tuple:
• Can check multiple prefixes
• text.startswith(("http", "https"))
• Returns True if starts with any

Best practice:
• Use for prefix checking
• More readable than slicing: text[:len(prefix)] == prefix
• Efficient for string validation

Example: "hello".startswith("he") returns True because "hello" begins with "he". This is useful for checking prefixes.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".endswith("lo")?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "endswith() checks if string ends with substring.",
    de: `The endswith() method returns True if the string ends with the specified substring, False otherwise. It's useful for checking suffixes, file extensions, endings, and validating string formats.

endswith() method:
• "hello".endswith("lo") = True
• Returns boolean (True/False)
• Checks if string ends with substring
• Case-sensitive check

How it works:
• Checks if string ends with substring
• Compares from end
• Returns True if matches, False otherwise
• Case-sensitive

Examples:
• "hello".endswith("lo") = True
• "hello".endswith("x") = False
• "hello".endswith("LO") = False (case-sensitive)
• "hello".endswith("") = True (empty string always matches)

Common uses:
• File extensions: filename.endswith(".txt")
• URL endings: url.endswith("/")
• Suffix validation
• Format checking

With tuple:
• Can check multiple suffixes
• filename.endswith((".jpg", ".png"))
• Returns True if ends with any

Best practice:
• Use for suffix checking
• More readable than slicing: text[-len(suffix):] == suffix
• Efficient for file extension checks

Example: "hello".endswith("lo") returns True because "hello" ends with "lo". This is useful for checking file extensions like .endswith(".py").
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".replace("l", "L")?`, 
    o: ["heLLo", "hello", "HELLO", "Error"], 
    c: 0, 
    e: "replace() substitutes characters.",
    de: `The replace() method returns a copy of the string with all occurrences of a substring replaced by another substring. By default, it replaces all occurrences. It's one of Python's most commonly used string methods for text manipulation.

replace() method:
• "hello".replace("l", "L") = "heLLo"
• Replaces all occurrences by default
• Returns new string (original unchanged)
• Basic syntax: replace(old, new)

How it works:
• Finds all occurrences of old substring
• Replaces each with new substring
• Returns new string
• Original string unchanged (strings are immutable)

Examples:
• "hello".replace("l", "L") = "heLLo" (all 'l' replaced)
• "hello".replace("x", "X") = "hello" (no change if not found)
• "hello".replace("", "X") = "XhXeXlXlXoX" (empty string everywhere)
• "hello world".replace(" ", "_") = "hello_world"

Common uses:
• Text substitution: text.replace("old", "new")
• Character removal: text.replace(" ", "")
• Format conversion
• Data cleaning

With count parameter:
• Can limit replacements: replace(old, new, count)
• "hello".replace("l", "L", 1) = "heLlo" (only first)
• Useful for limited replacements

Example: "hello".replace("l", "L") returns "heLLo" because all occurrences of 'l' are replaced with 'L'. The original string "hello" is unchanged.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".replace("l", "L", 1)?`, 
    o: ["heLlo", "heLLo", "hello", "Error"], 
    c: 0, 
    e: "replace() with count parameter replaces only first occurrence.",
    de: `The replace() method can take a third parameter (count) that limits how many occurrences are replaced. replace(old, new, count) replaces only the first 'count' occurrences, from left to right. This allows controlled, limited replacements.

replace() with count:
• "hello".replace("l", "L", 1) = "heLlo"
• Third parameter limits replacements
• Replaces only first occurrence(s)
• Remaining occurrences unchanged

How it works:
• Finds occurrences from left to right
• Replaces first 'count' occurrences
• Leaves remaining unchanged
• If count > occurrences, all are replaced

Examples:
• "hello".replace("l", "L", 1) = "heLlo" (first 'l' replaced)
• "hello".replace("l", "L", 2) = "heLLo" (both replaced)
• "hello".replace("l", "L", 0) = "hello" (no replacements)
• "hello".replace("l", "L", 10) = "heLLo" (all replaced)

Common uses:
• Replace first occurrence only
• Limited text substitution
• Controlled replacements
• Fixing specific instances

Why use count:
• Sometimes you want limited replacements
• Replace only first occurrence
• Avoid replacing all instances
• More control over substitution

Example: "hello".replace("l", "L", 1) returns "heLlo" because only the first occurrence of 'l' (at index 2) is replaced with 'L', leaving the second 'l' (at index 3) unchanged.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".partition("l")?`, 
    o: ["('he', 'l', 'lo')", "['he', 'l', 'lo']", "Error", "None"], 
    c: 0, 
    e: "partition() splits at first occurrence.",
    de: `The partition() method splits the string at the first occurrence of the separator and returns a tuple of three parts: the part before the separator, the separator itself, and the part after the separator. If the separator is not found, it returns (string, "", "").

partition() method:
• "hello".partition("l") = ('he', 'l', 'lo')
• Returns tuple of 3 parts
• Split at first occurrence only
• Includes separator in result

How it works:
• Finds first occurrence of separator
• Splits into: (before, separator, after)
• Returns tuple with 3 elements
• If not found: (string, "", "")

Examples:
• "hello".partition("l") = ('he', 'l', 'lo')
• "hello".partition("x") = ('hello', '', '') (not found)
• "hello".partition("") = ('', '', 'hello') (empty separator at start)
• "a-b-c".partition("-") = ('a', '-', 'b-c') (first occurrence only)

Tuple unpacking:
• before, sep, after = "hello".partition("l")
• before = 'he', sep = 'l', after = 'lo'
• Useful for parsing

Common uses:
• Splitting at first separator: before, sep, after = text.partition(":")
• Key-value parsing: key, _, value = line.partition("=")
• Path parsing
• Config file parsing

Comparison with .split():
• partition(): splits at first occurrence, returns 3 parts
• split(): splits at all occurrences, returns list
• partition() includes separator, split() excludes it

Example: "hello".partition("l") returns ('he', 'l', 'lo') - the part before 'l', 'l' itself, and the part after 'l'. This is useful for splitting at the first occurrence while keeping the separator.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".rpartition("l")?`, 
    o: ["('hel', 'l', 'o')", "['hel', 'l', 'o']", "Error", "None"], 
    c: 0, 
    e: "rpartition() splits at last occurrence.",
    de: `The rpartition() method splits the string at the last occurrence of the separator and returns a tuple of three parts: the part before the separator, the separator itself, and the part after the separator. If the separator is not found, it returns ("", "", string).

rpartition() method:
• "hello".rpartition("l") = ('hel', 'l', 'o')
• Returns tuple of 3 parts
• Split at last occurrence only
• Includes separator in result

How it works:
• Finds last occurrence of separator
• Splits into: (before, separator, after)
• Returns tuple with 3 elements
• If not found: ('', '', string)

Examples:
• "hello".rpartition("l") = ('hel', 'l', 'o') (last 'l')
• "hello".rpartition("x") = ('', '', 'hello') (not found)
• "a-b-c".rpartition("-") = ('a-b', '-', 'c') (last occurrence only)

Comparison with .partition():
• partition(): splits at first occurrence
• rpartition(): splits at last occurrence
• Both return 3-part tuple
• Both include separator

Common uses:
• Splitting at last separator
• Filename extension: name, _, ext = filename.rpartition(".")
• URL parsing
• Path parsing from end

Tuple unpacking:
• before, sep, after = "hello".rpartition("l")
• before = 'hel', sep = 'l', after = 'o'
• Useful for parsing from end

Example: "hello".rpartition("l") returns ('hel', 'l', 'o') - it splits at the last occurrence of 'l', returning the part before, 'l' itself, and the part after. Useful for splitting at the last separator.
`
  }),
  
  // 91-100: String Methods - Splitting, Joining, Formatting
  (_i: number) => ({ 
    q: `What is "hello,world".split(",")?`, 
    o: ["['hello', 'world']", "['hello,world']", "Error", "None"], 
    c: 0, 
    e: "split() divides string into list.",
    de: `The split() method splits a string into a list of substrings using a specified separator. If a separator is provided, it splits at each occurrence. If no separator is provided, it splits on whitespace. This is one of Python's most commonly used string methods.

split() method:
• "hello,world".split(",") = ['hello', 'world']
• Divides string into list
• Splits at each occurrence of separator
• Returns list of substrings

How it works:
• Finds all occurrences of separator
• Splits string at each occurrence
• Returns list of parts (separator excluded)
• Empty separator causes error

Examples:
• "hello,world".split(",") = ['hello', 'world']
• "a,b,c".split(",") = ['a', 'b', 'c']
• "hello".split(",") = ['hello'] (no separator found)
• "a,,b".split(",") = ['a', '', 'b'] (empty between separators)

With count parameter:
• "a,b,c".split(",", 1) = ['a', 'b,c'] (split at most 1 time)
• Limits number of splits
• Returns maxsplit+1 elements

Common uses:
• CSV parsing: line.split(",")
• Tokenization
• String parsing
• Data extraction

Example: "hello,world".split(",") returns ['hello', 'world'] because the string is split at the comma, creating a list with two elements.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello world".split()?`, 
    o: ["['hello', 'world']", "['hello world']", "Error", "None"], 
    c: 0, 
    e: "split() without argument splits on whitespace.",
    de: `The split() method without arguments splits a string on any whitespace (spaces, tabs, newlines) and removes empty strings from the result. It's useful for splitting text into words. Multiple consecutive whitespace characters are treated as a single separator.

split() without separator:
• "hello world".split() = ['hello', 'world']
• Splits on any whitespace
• Removes empty strings from result
• Multiple whitespace → single split

How it works:
• Splits on any whitespace character
• Spaces, tabs, newlines all work
• Multiple whitespace → treated as single separator
• Strips leading/trailing whitespace

Examples:
• "hello world".split() = ['hello', 'world']
• "hello  world".split() = ['hello', 'world'] (multiple spaces)
• "hello\\tworld".split() = ['hello', 'world'] (tab)
• "  hello world  ".split() = ['hello', 'world'] (strips whitespace)

Difference from split(" "):
• split(): splits on any whitespace, removes empty strings
• split(" "): splits on single space only, keeps empty strings
• "a  b".split() = ['a', 'b']
• "a  b".split(" ") = ['a', '', 'b']

Common uses:
• Tokenizing words: text.split()
• Parsing space-separated values
• Breaking text into words
• Clean splitting (removes empty strings)

Example: "hello world".split() returns ['hello', 'world'] because the string is split on whitespace, creating a list of words.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello\\nworld".splitlines()?`, 
    o: ["['hello', 'world']", "['hello\\nworld']", "Error", "None"], 
    c: 0, 
    e: "splitlines() splits on line breaks.",
    de: `The splitlines() method splits a string into a list at line boundaries. It recognizes various line break characters (\\n, \\r, \\r\\n) and splits accordingly. Unlike split("\\n"), it handles different line ending formats correctly.

splitlines() method:
• "hello\\nworld".splitlines() = ['hello', 'world']
• Splits on line breaks
• Handles different line ending formats
• Returns list of lines

How it works:
• Splits at line boundaries
• Recognizes \\n, \\r, \\r\\n
• Removes line break characters
• Returns list of lines

Examples:
• "hello\\nworld".splitlines() = ['hello', 'world']
• "hello\\r\\nworld".splitlines() = ['hello', 'world'] (Windows)
• "hello\\rworld".splitlines() = ['hello', 'world'] (old Mac)
• "hello\\n\\nworld".splitlines() = ['hello', '', 'world'] (empty line)

Common uses:
• Processing text files line by line
• Splitting multi-line strings
• Text processing
• Reading file content

Comparison with split("\\n"):
• splitlines(): handles all line break formats
• split("\\n"): only handles \\n
• splitlines(): better for cross-platform
• splitlines(): removes trailing \\n correctly

Example: "hello\\nworld".splitlines() returns ['hello', 'world'] because the string is split at the newline character, creating a list of two lines.
`
  }),
  (_i: number) => ({ 
    q: `What is "-".join(["a", "b", "c"])?`, 
    o: ["a-b-c", "a b c", "abc", "Error"], 
    c: 0, 
    e: "join() combines list elements with separator.",
    de: `The join() method combines a list (or any iterable) of strings into a single string, using the string on which join() is called as the separator. It's the opposite of split() and is more efficient than string concatenation for joining multiple strings.

join() method:
• "-".join(["a", "b", "c"]) = "a-b-c"
• Combines list elements with separator
• More efficient than concatenation
• Returns new string

How it works:
• Takes iterable of strings
• Joins them with separator between
• Returns combined string
• Empty iterable returns empty string

Examples:
• "-".join(["a", "b", "c"]) = "a-b-c"
• "".join(["a", "b", "c"]) = "abc" (no separator)
• " ".join(["hello", "world"]) = "hello world"
• ",".join(["1", "2", "3"]) = "1,2,3"

Important:
• Elements must be strings
• "".join([1, 2, 3]) raises TypeError
• Convert first: "".join(map(str, [1, 2, 3]))

Common uses:
• Building CSV: ",".join(values)
• Concatenating strings: "".join(strings)
• Formatting: " - ".join(items)
• Creating paths: "/".join(parts)

Best practice:
• Use join() instead of += in loops
• More efficient for multiple strings
• Preferred Pythonic way

Example: "-".join(["a", "b", "c"]) returns "a-b-c" because the list elements are joined with '-' as the separator between them.
`
  }),
  (_i: number) => ({ 
    q: `What is "".join(["a", "b", "c"])?`, 
    o: ["abc", "a b c", "Error", "None"], 
    c: 0, 
    e: "join() with empty string concatenates without separator.",
    de: `When join() is called with an empty string as the separator, it concatenates all elements together with no separator between them. This is the most efficient way to concatenate multiple strings in Python.

join() with empty string:
• "".join(["a", "b", "c"]) = "abc"
• Concatenates without separator
• Most efficient string concatenation
• Returns combined string

How it works:
• Takes iterable of strings
• Joins them with no separator (empty string)
• Returns concatenated string
• Fastest way to combine strings

Examples:
• "".join(["a", "b", "c"]) = "abc"
• "".join(["hello", "world"]) = "helloworld"
• "".join(["1", "2", "3"]) = "123"
• "".join(["a"]) = "a" (single element)

Why use this:
• Most efficient concatenation method
• Better than string += in loops
• Preferred Pythonic way
• Handles any number of strings

Common uses:
• Concatenating strings: "".join(strings)
• Building strings from characters
• Efficient string building
• Reversing string: "".join(reversed(s))

Comparison with +=:
• "".join(list): efficient, single operation
• result += item: inefficient, creates new strings each time
• join() is O(n), += in loop is O(n²)

Example: "".join(["a", "b", "c"]) returns "abc" because the list elements are concatenated together with no separator between them. This is the most efficient way to combine multiple strings.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".center(10)?`, 
    o: ["  hello   ", "hello", "Error", "None"], 
    c: 0, 
    e: "center() centers string in given width.",
    de: `The center() method centers a string in a field of specified width by padding it with spaces on both sides. If the string is longer than the width, it returns the original string unchanged. This is useful for formatting text output.

center() method:
• "hello".center(10) = "  hello   "
• Centers string in width
• Pads with spaces on both sides
• Returns new string

How it works:
• Calculates padding needed
• Adds spaces on both sides
• Centers string in field
• If width <= len(string), returns original

Examples:
• "hello".center(10) = "  hello   " (2 spaces each side)
• "hello".center(11) = "   hello   " (3 left, 2 right)
• "hello".center(5) = "hello" (no change, already fits)
• "hello".center(10, "-") = "--hello---" (custom fill character)

With fill character:
• Second parameter specifies fill character
• Default is space " "
• "hello".center(10, "*") = "**hello***"

Common uses:
• Text formatting
• Centering headers
• Display formatting
• Creating formatted output

Example: "hello".center(10) returns "  hello   " because the string is centered in a field of width 10, with 2 spaces on the left and 3 spaces on the right (when length is odd, extra space goes on right).
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".ljust(10)?`, 
    o: ["hello     ", "hello", "Error", "None"], 
    c: 0, 
    e: "ljust() left-justifies string.",
    de: `The ljust() method left-justifies a string in a field of specified width by padding it with spaces on the right side. If the string is longer than the width, it returns the original string unchanged. This is useful for aligning text to the left.

ljust() method:
• "hello".ljust(10) = "hello     "
• Left-justifies string in width
• Pads with spaces on right
• Returns new string

How it works:
• Adds spaces on right side
• Aligns string to left
• Creates field of specified width
• If width <= len(string), returns original

Examples:
• "hello".ljust(10) = "hello     " (5 spaces on right)
• "hello".ljust(10, "-") = "hello-----" (custom fill character)
• "hello".ljust(5) = "hello" (no change)

With fill character:
• Second parameter specifies fill character
• Default is space " "
• "hello".ljust(10, ".") = "hello....."

Common uses:
• Left-aligning text
• Creating fixed-width columns
• Formatting output
• Table formatting

Example: "hello".ljust(10) returns "hello     " because the string is left-justified in a field of width 10, with 5 spaces added on the right side.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".rjust(10)?`, 
    o: ["     hello", "hello", "Error", "None"], 
    c: 0, 
    e: "rjust() right-justifies string.",
    de: `The rjust() method right-justifies a string in a field of specified width by padding it with spaces on the left side. If the string is longer than the width, it returns the original string unchanged. This is useful for aligning text to the right, especially for numbers.

rjust() method:
• "hello".rjust(10) = "     hello"
• Right-justifies string in width
• Pads with spaces on left
• Returns new string

How it works:
• Adds spaces on left side
• Aligns string to right
• Creates field of specified width
• If width <= len(string), returns original

Examples:
• "hello".rjust(10) = "     hello" (5 spaces on left)
• "hello".rjust(10, "0") = "00000hello" (zero padding)
• "123".rjust(5, "0") = "00123" (number formatting)

With fill character:
• Second parameter specifies fill character
• Default is space " "
• Often used with "0" for zero padding

Common uses:
• Right-aligning numbers
• Zero padding: "5".rjust(3, "0") = "005"
• Creating aligned columns
• Number formatting

Example: "hello".rjust(10) returns "     hello" because the string is right-justified in a field of width 10, with 5 spaces added on the left side.
`
  }),
  (_i: number) => ({ 
    q: `What is "hello".zfill(10)?`, 
    o: ["00000hello", "hello", "Error", "None"], 
    c: 0, 
    e: "zfill() pads string with zeros.",
    de: `The zfill() method pads a string on the left with zeros ('0') to make it a specified width. If the string starts with a sign ('+' or '-'), the zeros are inserted after the sign. It's particularly useful for formatting numbers with leading zeros.

zfill() method:
• "hello".zfill(10) = "00000hello"
• Pads with zeros on left
• Creates field of specified width
• Returns new string

How it works:
• Adds zeros on left side
• Pads to specified width
• If string starts with +/-, zeros go after sign
• If width <= len(string), returns original

Examples:
• "hello".zfill(10) = "00000hello" (5 zeros)
• "42".zfill(5) = "00042" (3 zeros)
• "+42".zfill(5) = "+0042" (zeros after +)
• "-42".zfill(5) = "-0042" (zeros after -)

Common uses:
• Formatting numbers: "5".zfill(3) = "005"
• Creating fixed-width numbers
• Zero padding for IDs
• Display formatting

Comparison with rjust(..., "0"):
• zfill(): handles signs correctly
• rjust(..., "0"): treats sign as part of string
• zfill() is designed for numbers
• Both similar for positive numbers

Example: "hello".zfill(10) returns "00000hello" because the string is padded on the left with zeros to make it width 10. This is useful for formatting numbers with leading zeros.
`
  }),
  (_i: number) => ({ 
    q: `What is f"Value: {5}"?`, 
    o: ['"Value: 5"', "Value: 5", "Error", "None"], 
    c: 0, 
    e: "f-strings allow variable interpolation.",
    de: `f-strings (formatted string literals) are a Python feature introduced in Python 3.6 that allow you to embed expressions inside string literals using curly braces {}. The 'f' prefix (or 'F') tells Python to evaluate the expressions inside the braces and format the result.

f-string syntax:
• f"Value: {5}" = "Value: 5"
• Prefix string with 'f' or 'F'
• Expressions in {} are evaluated
• Values are converted to strings automatically

How it works:
• f-prefix enables f-string
• {expression} evaluates expression
• Result converted to string
• Embedded in final string

Examples:
• f"Value: {5}" = "Value: 5"
• name = "Alice"; f"Hello {name}" = "Hello Alice"
• x = 10; f"{x} + {5} = {x + 5}" = "10 + 5 = 15"
• f"{2 * 3}" = "6" (expressions work)

Advantages:
• Fastest string formatting method
• Most readable and concise
• Expressions evaluated at runtime
• No need to convert types manually

Common uses:
• Variable interpolation: f"Name: {name}"
• Expressions: f"Sum: {a + b}"
• Formatting: f"Price: $\\{price:.2f}"
• Debugging: f"x = {x}, y = {y}"

Formatting options:
• f"{value:.2f}" (decimal places)
• f"{value:>10}" (alignment)
• f"{value:0>5}" (zero padding)

Example: f"Value: {5}" returns "Value: 5" because the expression {5} is evaluated to 5, which is then converted to a string and embedded in the f-string. This is the modern Pythonic way to format strings.
`
  }),
];

// --- LEVEL 2: SHRIMP (Math, Expressions, Order of Ops) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level2Patterns = [
  // 1-10: Basic Arithmetic Operations
  (_i: number) => ({ 
    q: `What is 10 + 5 * 2?`, 
    o: ["20", "30", "15", "None"], 
    c: 0, 
    e: "Multiplication happens first (PEMDAS).",
    de: `Python follows the order of operations (PEMDAS: Parentheses, Exponents, Multiplication/Division, Addition/Subtraction). Multiplication has higher precedence than addition, so 5 * 2 is calculated first (equals 10), then 10 + 10 equals 20.

Order of operations:
• 10 + 5 * 2
• First: 5 * 2 = 10 (multiplication first)
• Then: 10 + 10 = 20 (addition second)
• Result: 20

PEMDAS rule:
• P: Parentheses (highest priority)
• E: Exponents (**)
• M/D: Multiplication and Division (left to right)
• A/S: Addition and Subtraction (left to right)

Common mistake:
• 10 + 5 * 2 ≠ (10 + 5) * 2 = 30
• Must follow operator precedence
• Multiplication before addition

Example: 10 + 5 * 2 evaluates to 20 because multiplication (5 * 2 = 10) happens before addition (10 + 10 = 20), following PEMDAS rules.
`
  }),
  (_i: number) => ({ 
    q: `What is (10 + 5) * 2?`, 
    o: ["30", "20", "15", "None"], 
    c: 0, 
    e: "Parentheses change order of operations.",
    de: `Parentheses override the normal order of operations in Python. When you use parentheses, the expression inside is evaluated first, regardless of operator precedence. (10 + 5) * 2 calculates 10 + 5 first (equals 15), then 15 * 2 equals 30.

Parentheses precedence:
• (10 + 5) * 2
• First: (10 + 5) = 15 (parentheses evaluated first)
• Then: 15 * 2 = 30 (multiplication)
• Result: 30

Without parentheses:
• 10 + 5 * 2 = 10 + 10 = 20 (multiplication first)
• Parentheses change the result!

How parentheses work:
• Highest precedence (evaluated first)
• Override normal operator precedence
• Can nest: ((10 + 5) * 2) / 3
• Used for clarity even when not needed

Example: (10 + 5) * 2 evaluates to 30 because parentheses force addition first (10 + 5 = 15), then multiplication (15 * 2 = 30).
`
  }),
  (_i: number) => ({ 
    q: `What is 10 / 2 in Python 3?`, 
    o: ["5.0", "5", "0", "Error"], 
    c: 0, 
    e: "The / operator always returns a float in Python 3.",
    de: `In Python 3, the division operator (/) always returns a floating-point number, even when the result is a whole number. This is called "true division" and ensures mathematical consistency. 10 / 2 equals 5.0, not 5.

Python 3 division:
• 10 / 2 = 5.0 (always float)
• Even whole numbers become floats
• Ensures consistent behavior
• Mathematically more accurate

Python 2 vs Python 3:
• Python 2: 10 / 2 = 5 (integer division)
• Python 3: 10 / 2 = 5.0 (true division - always float)
• Python 2 & 3: 10 // 2 = 5 (floor division - integer)

Why this change:
• Prevents confusion about division behavior
• Makes division mathematically consistent
• Eliminates unexpected integer truncation
• More intuitive for most use cases

Getting integer results:
• Use // (floor division): 10 // 2 = 5
• Use int(): int(10 / 2) = 5
• // is preferred for clarity

Example: 10 / 2 returns 5.0 (a float) in Python 3, even though the result is a whole number. For integer division, use 10 // 2 which returns 5.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 // 3?`, 
    o: ["3", "3.33", "4", "Error"], 
    c: 0, 
    e: "// is floor division (integer division).",
    de: `The // operator performs floor division (also called integer division or truncating division). It divides two numbers and returns the largest integer less than or equal to the result. For positive numbers, this means it truncates toward zero. 10 // 3 equals 3.

Floor division:
• 10 // 3 = 3 (fits 3 times, remainder 1)
• Returns integer (or float if operands are floats)
• Rounds down (toward negative infinity)
• Works with negative numbers too

How it works:
• 10 ÷ 3 = 3.333... → floor = 3
• 10 // 3 = 3 (largest integer ≤ 3.333)
• Similar to int(10 / 3) but different with negatives

With negatives:
• -10 // 3 = -4 (rounds down, away from zero)
• int(-10 / 3) = -3 (truncates toward zero)
• // rounds toward negative infinity, int() truncates toward zero

Use cases:
• Getting whole number of divisions
• Splitting items into groups
• Converting to integer after division
• Time calculations (hours, minutes)

Example: 10 // 3 returns 3 because floor division calculates how many complete groups of 3 can be made from 10, which is 3 (with remainder 1).
`
  }),
  (_i: number) => ({ 
    q: `What is 10 % 3?`, 
    o: ["1", "3", "0", "Error"], 
    c: 0, 
    e: "% is the modulo operator (remainder).",
    de: `The % operator is the modulo operator - it returns the remainder after division. When you divide 10 by 3, you get 3 groups of 3 with 1 left over. That remainder (1) is what the modulo operator returns. 10 % 3 equals 1.

Modulo operation:
• 10 % 3 = 1 (remainder when 10 is divided by 3)
• 10 ÷ 3 = 3 with remainder 1
• Returns what's left after floor division
• Works with floats too: 10.5 % 3 = 1.5

How it works:
• Divide first number by second
• Return the remainder after division
• 10 % 3: 10 ÷ 3 = 3 remainder 1, so 10 % 3 = 1
• 10 % 5: 10 ÷ 5 = 2 remainder 0, so 10 % 5 = 0

Common uses:
• Checking even/odd: n % 2 (0 = even, 1 = odd)
• Wrapping values: index % length (keeps index in range)
• Finding divisors: n % d == 0 (d divides n)
• Time calculations: seconds % 60 (seconds within minute)
• Hashtables: hash % size (bucket index)

Example: 10 % 3 returns 1 because when you divide 10 by 3, you get 3 groups of 3 with 1 remaining. This is useful for checking divisibility, wrapping values, and many other programming tasks.
`
  }),
  (_i: number) => ({ 
    q: `What is 2 ** 3?`, 
    o: ["8", "6", "9", "Error"], 
    c: 0, 
    e: "** is the exponentiation operator.",
    de: `The ** operator performs exponentiation (raising a number to a power). It's Python's built-in operator for calculating powers, making it convenient and readable. 2 ** 3 means "2 to the power of 3" which equals 8 (2 × 2 × 2).

Exponentiation syntax:
• 2 ** 3 = 8 (2 raised to the power of 3)
• base ** exponent = base ^ exponent (mathematically)
• Right-associative: 2 ** 3 ** 2 = 2 ** (3 ** 2) = 2 ** 9 = 512
• Works with floats: 2.5 ** 2 = 6.25

How it works:
• 2 ** 3 = 2 × 2 × 2 = 8
• 2 ** 0 = 1 (any number to power 0 is 1)
• 2 ** -1 = 0.5 (negative powers give fractions)
• 10 ** 2 = 100 (10 squared)

Common uses:
• Powers of 2: 2 ** 10 = 1024
• Squaring: x ** 2
• Cubing: x ** 3
• Scientific notation: 10 ** 6 = 1,000,000
• Calculating areas/volumes

Alternatives:
• math.pow(2, 3) = 8.0 (always returns float)
• pow(2, 3) = 8 (built-in function, can return int)
• 2 ** 3 is preferred (more readable and Pythonic)

Example: 2 ** 3 returns 8 because 2 raised to the power of 3 means multiplying 2 by itself 3 times (2 × 2 × 2 = 8).
`
  }),
  (_i: number) => ({ 
    q: `What is 2 ** 2 ** 3?`, 
    o: ["256", "64", "512", "Error"], 
    c: 0, 
    e: "Exponentiation is right-associative: 2**(2**3) = 2**8 = 256.",
    de: `Exponentiation in Python is right-associative, meaning it groups from right to left. 2 ** 2 ** 3 is evaluated as 2 ** (2 ** 3), not (2 ** 2) ** 3. This matches mathematical convention for powers. 2 ** (2 ** 3) = 2 ** 8 = 256.

Right-associativity:
• 2 ** 2 ** 3 = 2 ** (2 ** 3)
• NOT (2 ** 2) ** 3
• Groups from right to left
• Matches mathematical convention

Step-by-step:
• 2 ** 2 ** 3
• First: 2 ** 3 = 8 (rightmost exponentiation)
• Then: 2 ** 8 = 256 (left exponentiation)
• Result: 256

If it were left-associative:
• (2 ** 2) ** 3 = 4 ** 3 = 64 (different result!)

Mathematical convention:
• a^b^c = a^(b^c) (standard math notation)
• Python follows this convention
• Right-associative for exponentiation

Other operators:
• Most operators are left-associative: 10 - 5 - 2 = (10 - 5) - 2 = 3
• Exponentiation is right-associative: 2 ** 3 ** 2 = 2 ** (3 ** 2) = 512

Example: 2 ** 2 ** 3 evaluates to 256. It's calculated as 2 ** (2 ** 3) = 2 ** 8 = 256, following right-associativity for exponentiation.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 / 0?`, 
    o: ["ZeroDivisionError", "0", "infinity", "None"], 
    c: 0, 
    e: "Division by zero raises ZeroDivisionError.",
    de: `Dividing by zero in Python raises a ZeroDivisionError exception. This is mathematically undefined and Python prevents this operation by raising an error. You cannot divide any number by zero - it's not valid mathematically or in Python.

Division by zero:
• 10 / 0 raises ZeroDivisionError
• 10 // 0 raises ZeroDivisionError
• 10 % 0 raises ZeroDivisionError
• Any division by zero causes an error

Why this happens:
• Mathematically undefined (can't divide by zero)
• Python prevents invalid operations
• Raises exception to signal the error
• Must be handled or program crashes

The error:
• Exception type: ZeroDivisionError
• Message: "division by zero"
• Stops program execution unless caught
• Common mistake in calculations

Handling the error:
• Use try-except to catch it
• Check before dividing: if divisor != 0:
• Provide default values for edge cases
• Validate input to prevent division by zero

Example handling:
try:
    result = 10 / 0
except ZeroDivisionError:
    result = None  # Handle the error

Prevention:
• Check before dividing: if y != 0: x / y
• Validate input: assert divisor != 0
• Use default values: x / y if y != 0 else 0

Example: 10 / 0 raises ZeroDivisionError because division by zero is mathematically undefined. This must be caught with try-except or prevented by checking that the divisor is not zero before dividing.
`
  }),
  (_i: number) => ({ 
    q: `What is 0 / 10?`, 
    o: ["0.0", "0", "Error", "None"], 
    c: 0, 
    e: "Zero divided by any number is 0.0.",
    de: `Dividing zero by any non-zero number always results in zero. In Python 3, the division operator (/) always returns a float, so 0 / 10 equals 0.0 (a float), not 0 (an integer).

Zero divided by number:
• 0 / 10 = 0.0 (zero divided by any number)
• 0 / 5 = 0.0
• 0 / 100 = 0.0
• Always 0.0 (float in Python 3)

How it works:
• Zero divided by any number equals zero
• 0 ÷ 10 = 0 (mathematically)
• In Python 3, / always returns float
• Result: 0.0 (not 0)

Python 3 behavior:
• 0 / 10 = 0.0 (float, not int)
• 0 // 10 = 0 (integer, floor division)
• Division operator always returns float
• Even when result is zero

Important distinction:
• 0 / 10 = 0.0 (Zero divided by number - valid)
• 10 / 0 = ZeroDivisionError (Number divided by zero - invalid)
• These are different operations!

Common uses:
• Default values: result = 0.0 if divisor != 0 else default
• Calculations with zero numerator
• Mathematical formulas where numerator might be zero

Example: 0 / 10 returns 0.0 because zero divided by any non-zero number equals zero, and Python 3's division operator always returns a float (0.0 instead of 0).
`
  }),
  (_i: number) => ({ 
    q: `What is 10 * 0?`, 
    o: ["0", "10", "Error", "None"], 
    c: 0, 
    e: "Any number multiplied by zero is zero.",
    de: `Any number multiplied by zero always equals zero. This is a fundamental mathematical property. 10 * 0 equals 0 because multiplying any number by zero results in zero.

Multiplication by zero:
• 10 * 0 = 0 (any number times zero)
• 5 * 0 = 0
• 100 * 0 = 0
• Always zero

How it works:
• Multiplying by zero always gives zero
• This is true for all numbers (positive, negative, float, int)
• Zero is the multiplicative identity element
• Fundamental mathematical property

Examples:
• 10 * 0 = 0
• -5 * 0 = 0
• 3.14 * 0 = 0.0 (float times zero)
• 0 * 0 = 0

Properties:
• Commutative: 10 * 0 = 0 * 10 = 0
• Works with any number type
• Result type depends on operands
• If one operand is float, result is float

Common uses:
• Reset calculations: total = 0
• Conditional logic: if count == 0: result = 0
• Mathematical formulas
• Initialization

Example: 10 * 0 returns 0 because any number multiplied by zero equals zero. This is a fundamental mathematical property that holds true for all numbers in Python.
`
  }),
  
  // 11-20: Math Functions
  (_i: number) => ({ 
    q: `What is abs(-5)?`, 
    o: ["5", "-5", "0", "Error"], 
    c: 0, 
    e: "abs() returns absolute value.",
    de: `The abs() function returns the absolute value of a number - its distance from zero on the number line, without regard to direction. For negative numbers, it returns the positive version. abs(-5) returns 5.

Absolute value:
• abs(-5) = 5 (removes negative sign)
• abs(5) = 5 (positive numbers unchanged)
• abs(0) = 0 (zero is zero)
• Always returns non-negative number

How it works:
• Calculates distance from zero
• Removes negative sign if present
• Positive numbers unchanged
• Returns non-negative result

Examples:
• abs(-5) = 5
• abs(5) = 5
• abs(-3.14) = 3.14
• abs(0) = 0

Mathematical definition:
• |x| = x if x ≥ 0
• |x| = -x if x < 0
• Distance from zero on number line

Common uses:
• Calculating distances
• Removing negative signs
• Comparing magnitudes
• Error handling (always positive)

Example: abs(-5) returns 5 because the absolute value of -5 is 5, representing its distance from zero regardless of direction.
`
  }),
  (_i: number) => ({ 
    q: `What is abs(5)?`, 
    o: ["5", "-5", "0", "Error"], 
    c: 0, 
    e: "abs() of positive number is itself.",
    de: `The abs() function returns the absolute value of a number. For positive numbers (or zero), the absolute value is the number itself. abs(5) returns 5 because 5 is already positive.

Absolute value of positive:
• abs(5) = 5 (positive numbers unchanged)
• abs(3.14) = 3.14 (positive floats unchanged)
• abs(0) = 0 (zero is zero)
• Positive numbers are their own absolute value

How it works:
• If number ≥ 0, returns number unchanged
• If number < 0, returns -number
• Always returns non-negative result

Examples:
• abs(5) = 5 (already positive)
• abs(10) = 10
• abs(3.14) = 3.14
• abs(0) = 0

Why this makes sense:
• Absolute value = distance from zero
• Distance from zero to 5 is 5
• Positive numbers don't change
• Negative numbers become positive

Common uses:
• Normalizing values
• Comparing magnitudes
• Distance calculations
• Always getting non-negative results

Example: abs(5) returns 5 because 5 is already positive, and the absolute value of a positive number is the number itself.
`
  }),
  (_i: number) => ({ 
    q: `What is round(3.49)?`, 
    o: ["3", "4", "3.49", "Error"], 
    c: 0, 
    e: "round() rounds .49 down to nearest integer.",
    de: `The round() function rounds a number to the nearest integer. When the decimal part is less than .5, it rounds down. round(3.49) rounds down to 3 because 0.49 < 0.5.

Rounding behavior:
• round(3.49) = 3 (rounds down, decimal < .5)
• round(3.51) = 4 (rounds up, decimal > .5)
• round(3.5) = 4 (banker's rounding - rounds to even)

How it works:
• If decimal part < .5, rounds down
• If decimal part > .5, rounds up
• If decimal part = .5, rounds to nearest even (banker's rounding)
• Returns integer (or float if rounding float)

Examples:
• round(3.49) = 3 (down)
• round(3.51) = 4 (up)
• round(3.5) = 4 (to even)
• round(2.5) = 2 (to even)

Banker's rounding:
• round(3.5) = 4 (rounds to even: 4)
• round(2.5) = 2 (rounds to even: 2)
• Avoids rounding bias
• Standard in Python

Common uses:
• Converting floats to integers
• Displaying rounded values
• Financial calculations
• Statistical rounding

Example: round(3.49) returns 3 because 0.49 is less than 0.5, so it rounds down to the nearest integer (3).
`
  }),
  (_i: number) => ({ 
    q: `What is round(3.51)?`, 
    o: ["4", "3", "3.51", "Error"], 
    c: 0, 
    e: "round() rounds .51 up to nearest integer.",
    de: `The round() function rounds a number to the nearest integer. When the decimal part is greater than .5, it rounds up. round(3.51) rounds up to 4 because 0.51 > 0.5.

Rounding behavior:
• round(3.51) = 4 (rounds up, decimal > .5)
• round(3.49) = 3 (rounds down, decimal < .5)
• round(3.5) = 4 (banker's rounding - rounds to even)

How it works:
• If decimal part > .5, rounds up
• If decimal part < .5, rounds down
• If decimal part = .5, rounds to nearest even
• Returns integer

Examples:
• round(3.51) = 4 (up)
• round(3.99) = 4 (up)
• round(3.50) = 4 (to even)
• round(2.50) = 2 (to even)

Common uses:
• Converting floats to integers
• Displaying rounded values
• Financial calculations
• Statistical rounding

Example: round(3.51) returns 4 because 0.51 is greater than 0.5, so it rounds up to the nearest integer (4).
`
  }),
  (_i: number) => ({ 
    q: `What is round(3.5)?`, 
    o: ["4", "3", "3.5", "Error"], 
    c: 0, 
    e: "round() rounds .5 to nearest even (banker's rounding).",
    de: `The round() function uses "banker's rounding" (round half to even) when the decimal part is exactly .5. round(3.5) rounds to 4 because 4 is the nearest even number. This rounding method avoids statistical bias by rounding .5 to the nearest even number.

Banker's rounding:
• round(3.5) = 4 (rounds to even: 4)
• round(2.5) = 2 (rounds to even: 2)
• round(4.5) = 4 (rounds to even: 4)
• round(5.5) = 6 (rounds to even: 6)

How it works:
• If decimal part < .5, rounds down
• If decimal part > .5, rounds up
• If decimal part = .5, rounds to nearest even number
• This is "round half to even" or "IEEE 754" rounding

Why banker's rounding:
• Avoids systematic rounding bias
• More accurate in statistics
• Standard in financial calculations
• IEEE 754 standard

Examples:
• round(3.5) = 4 (even number)
• round(2.5) = 2 (even number)
• round(4.5) = 4 (even number)
• round(5.5) = 6 (even number)

Important note:
• This is different from traditional rounding
• Traditional: always round .5 up
• Banker's: round .5 to nearest even
• Python uses banker's rounding

Example: round(3.5) returns 4 because when rounding 0.5, Python rounds to the nearest even number. Since 3.5 is equidistant from 3 and 4, it chooses 4 (the even number).
`
  }),
  (_i: number) => ({ 
    q: `What is min(5, 10, 2)?`, 
    o: ["2", "5", "10", "Error"], 
    c: 0, 
    e: "min() finds the smallest value.",
    de: `The min() function returns the smallest value from the given arguments. It can take multiple arguments or an iterable. min(5, 10, 2) returns 2 because 2 is the smallest of the three numbers.

min() function:
• min(5, 10, 2) = 2 (smallest value)
• Can take multiple arguments
• Can take an iterable: min([5, 10, 2])
• Returns smallest value

How it works:
• Compares all arguments
• Returns the minimum value
• Works with numbers, strings, any comparable type
• Raises ValueError if empty iterable

Examples:
• min(5, 10, 2) = 2
• min(1, 2, 3) = 1
• min([5, 10, 2]) = 2
• min("a", "b", "c") = "a"

With iterable:
• min([1, 2, 3]) = 1
• min("hello") = "e" (lexicographically smallest)
• min([]) raises ValueError

Common uses:
• Finding minimum value
• Comparison operations
• Range checking
• Optimization problems

Example: min(5, 10, 2) returns 2 because among the values 5, 10, and 2, the smallest is 2.
`
  }),
  (_i: number) => ({ 
    q: `What is max(5, 10, 2)?`, 
    o: ["10", "5", "2", "Error"], 
    c: 0, 
    e: "max() finds the largest value.",
    de: `The max() function returns the largest value from the given arguments. It can take multiple arguments or an iterable. max(5, 10, 2) returns 10 because 10 is the largest of the three numbers.

max() function:
• max(5, 10, 2) = 10 (largest value)
• Can take multiple arguments
• Can take an iterable: max([5, 10, 2])
• Returns largest value

How it works:
• Compares all arguments
• Returns the maximum value
• Works with numbers, strings, any comparable type
• Raises ValueError if empty iterable

Examples:
• max(5, 10, 2) = 10
• max(1, 2, 3) = 3
• max([5, 10, 2]) = 10
• max("a", "b", "c") = "c"

With iterable:
• max([1, 2, 3]) = 3
• max("hello") = "o" (lexicographically largest)
• max([]) raises ValueError

Common uses:
• Finding maximum value
• Comparison operations
• Range checking
• Optimization problems

Example: max(5, 10, 2) returns 10 because among the values 5, 10, and 2, the largest is 10.
`
  }),
  (_i: number) => ({ 
    q: `What is pow(3, 2)?`, 
    o: ["9", "6", "27", "0"], 
    c: 0, 
    e: "pow(a, b) is equivalent to a**b.",
    de: `The pow() function is Python's built-in function for exponentiation. pow(3, 2) calculates 3 to the power of 2, which equals 9. It's equivalent to using the ** operator: pow(3, 2) = 3 ** 2 = 9.

pow() function:
• pow(3, 2) = 9 (3 to the power of 2)
• Equivalent to 3 ** 2
• pow(base, exponent) = base ** exponent
• Returns int if operands are ints

How it works:
• Calculates base raised to exponent
• pow(3, 2) = 3 × 3 = 9
• pow(2, 3) = 2 × 2 × 2 = 8
• Works with floats too: pow(2.5, 2) = 6.25

Examples:
• pow(3, 2) = 9
• pow(2, 3) = 8
• pow(5, 0) = 1 (any number to power 0)
• pow(10, 2) = 100

With third argument (modulo):
• pow(2, 3, 5) = (2 ** 3) % 5 = 8 % 5 = 3
• More efficient for large numbers
• Computes (base ** exponent) % modulus

Comparison with **:
• pow(3, 2) = 9, 3 ** 2 = 9 (same result)
• pow() is a function, ** is an operator
• Both work, ** is more common in Python

Example: pow(3, 2) returns 9 because 3 raised to the power of 2 equals 3 × 3 = 9. This is equivalent to 3 ** 2.
`
  }),
  (_i: number) => ({ 
    q: `What is pow(2, 3, 5)?`, 
    o: ["3", "8", "0", "Error"], 
    c: 0, 
    e: "pow(x, y, z) is (x**y) % z.",
    de: `The pow() function can take a third argument for modular exponentiation. pow(2, 3, 5) calculates (2 ** 3) % 5, which equals 8 % 5 = 3. This is more efficient than computing 2 ** 3 first, then taking the modulo.

Modular exponentiation:
• pow(2, 3, 5) = (2 ** 3) % 5 = 8 % 5 = 3
• Third argument is the modulus
• More efficient for large numbers
• Computes (base ** exponent) % modulus directly

How it works:
• Calculates base ** exponent
• Takes result modulo modulus
• More efficient than separate operations
• Useful for cryptography and large numbers

Step-by-step:
• pow(2, 3, 5)
• First: 2 ** 3 = 8
• Then: 8 % 5 = 3
• Result: 3

Why use third argument:
• More efficient for large exponents
• Avoids intermediate large numbers
• Important for cryptography
• Prevents overflow issues

Examples:
• pow(2, 3, 5) = 3
• pow(3, 4, 7) = (3 ** 4) % 7 = 81 % 7 = 4
• pow(5, 2, 10) = (5 ** 2) % 10 = 25 % 10 = 5

Common uses:
• Cryptography (RSA, etc.)
• Large number calculations
• Efficient modulo arithmetic
• Preventing overflow

Example: pow(2, 3, 5) returns 3 because it calculates (2 ** 3) % 5 = 8 % 5 = 3. This is more efficient than computing 2 ** 3 separately, especially for large exponents.
`
  }),
  (_i: number) => ({ 
    q: `What is sum([1, 2, 3])?`, 
    o: ["6", "0", "Error", "None"], 
    c: 0, 
    e: "sum() adds all numbers in iterable.",
    de: `The sum() function adds all numbers in an iterable (like a list) and returns the total. sum([1, 2, 3]) adds 1 + 2 + 3, which equals 6. It's Python's built-in way to sum a collection of numbers.

sum() function:
• sum([1, 2, 3]) = 6 (adds all elements)
• Takes an iterable of numbers
• Returns total sum
• Can take optional start value

How it works:
• Iterates through iterable
• Adds all numbers together
• Returns total sum
• sum(iterable, start) starts with start value

Examples:
• sum([1, 2, 3]) = 6
• sum([10, 20, 30]) = 60
• sum([]) = 0 (empty list)
• sum([1, 2, 3], 10) = 16 (starts with 10)

With start value:
• sum([1, 2, 3], 10) = 16 (starts with 10, then adds 1+2+3)
• sum([], 5) = 5 (empty list with start value)
• Default start is 0

Common uses:
• Adding list of numbers
• Calculating totals
• Summing numeric collections
• Statistical calculations

Important:
• Elements must be numbers
• sum(["a", "b"]) raises TypeError
• For strings, use "".join()

Example: sum([1, 2, 3]) returns 6 because it adds all elements in the list: 1 + 2 + 3 = 6. This is Python's efficient way to sum numeric collections.
`
  }),
  
  // 21-30: More Math Functions
  (_i: number) => ({ 
    q: `What is divmod(10, 3)?`, 
    o: ["(3, 1)", "3.33", "Error", "None"], 
    c: 0, 
    e: "divmod() returns (quotient, remainder).",
    de: `The divmod() function returns a tuple containing both the quotient and remainder of division. It's equivalent to performing floor division and modulo operations together. divmod(10, 3) returns (3, 1) because 10 // 3 = 3 and 10 % 3 = 1.

divmod() function:
• divmod(10, 3) = (3, 1) (quotient, remainder)
• Returns tuple (quotient, remainder)
• Equivalent to (a // b, a % b)
• More efficient than separate operations

How it works:
• Calculates floor division: 10 // 3 = 3
• Calculates modulo: 10 % 3 = 1
• Returns tuple: (3, 1)
• More efficient than doing both separately

Examples:
• divmod(10, 3) = (3, 1)
• divmod(20, 4) = (5, 0) (no remainder)
• divmod(15, 4) = (3, 3)
• divmod(7, 2) = (3, 1)

Equivalent operations:
• divmod(10, 3) = (10 // 3, 10 % 3) = (3, 1)
• Does both operations in one call
• More efficient for large numbers

Common uses:
• Getting both quotient and remainder
• Time calculations (hours, minutes)
• Base conversion
• Efficient division operations

Unpacking:
• quotient, remainder = divmod(10, 3)
• quotient = 3, remainder = 1
• Useful for extracting both values

Example: divmod(10, 3) returns (3, 1) because when dividing 10 by 3, you get a quotient of 3 and a remainder of 1. This is more efficient than calculating // and % separately.
`
  }),
  (_i: number) => ({ 
    q: `What is sorted([3, 1, 2])?`, 
    o: ["[1, 2, 3]", "[3, 1, 2]", "Error", "None"], 
    c: 0, 
    e: "sorted() returns sorted list.",
    de: `The sorted() function returns a new sorted list from the items in an iterable. It doesn't modify the original list - it creates a new sorted copy. sorted([3, 1, 2]) returns [1, 2, 3], sorted in ascending order.

sorted() function:
• sorted([3, 1, 2]) = [1, 2, 3] (sorted ascending)
• Returns new sorted list
• Original list unchanged (not modified)
• Works with any iterable

How it works:
• Creates new list from iterable
• Sorts elements in ascending order (default)
• Returns sorted list
• Original remains unchanged

Examples:
• sorted([3, 1, 2]) = [1, 2, 3]
• sorted([5, 2, 8, 1]) = [1, 2, 5, 8]
• sorted("hello") = ['e', 'h', 'l', 'l', 'o']
• sorted((3, 1, 2)) = [1, 2, 3] (works with tuples)

Comparison with .sort():
• sorted([3, 1, 2]) = [1, 2, 3] (new list)
• [3, 1, 2].sort() = None (modifies original)
• sorted() returns value, .sort() modifies in-place

Common uses:
• Sorting lists without modifying original
• Sorting any iterable (strings, tuples)
• Creating sorted copies
• Functional programming style

Example: sorted([3, 1, 2]) returns [1, 2, 3] because it creates a new list sorted in ascending order. The original list [3, 1, 2] remains unchanged.
`
  }),
  (_i: number) => ({ 
    q: `What is sorted([3, 1, 2], reverse=True)?`, 
    o: ["[3, 2, 1]", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "reverse=True sorts descending.",
    de: `The sorted() function accepts a reverse parameter. When reverse=True, it sorts the iterable in descending order (largest to smallest). sorted([3, 1, 2], reverse=True) returns [3, 2, 1], sorted from largest to smallest.

sorted() with reverse:
• sorted([3, 1, 2], reverse=True) = [3, 2, 1] (descending)
• reverse=True sorts largest to smallest
• Returns new sorted list
• Original unchanged

How it works:
• Creates new list from iterable
• Sorts in descending order (reverse=True)
• Returns sorted list (largest to smallest)
• Original remains unchanged

Examples:
• sorted([3, 1, 2], reverse=True) = [3, 2, 1]
• sorted([5, 2, 8, 1], reverse=True) = [8, 5, 2, 1]
• sorted("hello", reverse=True) = ['o', 'l', 'l', 'h', 'e']
• sorted([3, 1, 2], reverse=False) = [1, 2, 3] (default)

Default behavior:
• reverse=False (default) → ascending order
• reverse=True → descending order
• Can also use: sorted([3, 1, 2])[::-1] for descending

Common uses:
• Sorting from largest to smallest
• Finding top N items
• Reverse ordering
• Descending sorts

Example: sorted([3, 1, 2], reverse=True) returns [3, 2, 1] because it sorts the list in descending order (largest to smallest) when reverse=True is specified.
`
  }),
  (_i: number) => ({ 
    q: `What is 5 ** 0?`, 
    o: ["1", "0", "5", "Error"], 
    c: 0, 
    e: "Any number to power 0 is 1.",
    de: `Any number raised to the power of 0 equals 1. This is a fundamental mathematical property. 5 ** 0 equals 1, just like any other non-zero number raised to power 0. This is true for all numbers (positive, negative, integers, floats).

Power of zero rule:
• 5 ** 0 = 1 (any number to power 0)
• 10 ** 0 = 1
• -5 ** 0 = 1
• 3.14 ** 0 = 1.0

How it works:
• Mathematically: x^0 = 1 (for any x ≠ 0)
• Fundamental property of exponents
• Consistent across all number types
• Works with integers and floats

Mathematical reasoning:
• x^a / x^a = x^(a-a) = x^0
• x^a / x^a = 1
• Therefore: x^0 = 1

Examples:
• 5 ** 0 = 1
• 100 ** 0 = 1
• -5 ** 0 = 1
• 0.5 ** 0 = 1.0

Special case:
• 0 ** 0 is undefined (some systems return 1, Python raises error)

Common uses:
• Base conversion formulas
• Mathematical expressions
• Power series
• Exponential functions

Example: 5 ** 0 returns 1 because any non-zero number raised to the power of 0 equals 1. This is a fundamental mathematical property.
`
  }),
  (_i: number) => ({ 
    q: `What is 0 ** 5?`, 
    o: ["0", "1", "Error", "None"], 
    c: 0, 
    e: "0 to any power is 0.",
    de: `Zero raised to any positive power equals zero. This is because zero multiplied by itself any number of times is still zero. 0 ** 5 equals 0, just like 0 ** 1, 0 ** 10, etc. However, 0 ** 0 is undefined.

Zero to positive power:
• 0 ** 5 = 0 (zero to any positive power)
• 0 ** 1 = 0
• 0 ** 10 = 0
• Always zero for positive exponents

How it works:
• Zero multiplied by itself = zero
• 0 × 0 × 0 × 0 × 0 = 0
• For any positive exponent, result is 0
• Only exception: 0 ** 0 is undefined

Examples:
• 0 ** 5 = 0
• 0 ** 1 = 0
• 0 ** 100 = 0
• 0 ** 0 raises ValueError (undefined)

Special cases:
• 0 ** 0: Undefined (raises ValueError in Python)
• 0 ** positive: 0
• 0 ** negative: ZeroDivisionError (division by zero)

Common uses:
• Mathematical formulas
• Edge case handling
• Power calculations
• Polynomial evaluations

Important:
• 0 ** 0 is undefined mathematically
• Python raises ValueError for 0 ** 0
• 0 ** positive integer = 0
• 0 ** negative = error (division by zero)

Example: 0 ** 5 returns 0 because zero raised to any positive power equals zero. Zero multiplied by itself any number of times is still zero.
`
  }),
  (_i: number) => ({ 
    q: `What is 1 ** 100?`, 
    o: ["1", "100", "0", "Error"], 
    c: 0, 
    e: "1 to any power is 1.",
    de: `One raised to any power equals one. This is because one multiplied by itself any number of times is still one. 1 ** 100 equals 1, just like 1 ** 1, 1 ** 1000, etc. This is true for any exponent (positive, negative, zero, fraction).

One to any power:
• 1 ** 100 = 1 (one to any power)
• 1 ** 1 = 1
• 1 ** 0 = 1
• 1 ** -5 = 1
• Always one

How it works:
• One multiplied by itself = one
• 1 × 1 × 1 × ... × 1 = 1
• For any exponent, result is 1
• Works with any number type

Examples:
• 1 ** 100 = 1
• 1 ** 0 = 1
• 1 ** -5 = 1
• 1.0 ** 100 = 1.0

Mathematical property:
• 1^n = 1 for any n
• Multiplicative identity
• One is its own power
• Fundamental property

Common uses:
• Base cases in algorithms
• Mathematical proofs
• Identity operations
• Edge case handling

Example: 1 ** 100 returns 1 because one raised to any power equals one. No matter how many times you multiply 1 by itself, the result is always 1.
`
  }),
  (_i: number) => ({ 
    q: `What is 5 ** 1?`, 
    o: ["5", "1", "0", "Error"], 
    c: 0, 
    e: "Any number to power 1 is itself.",
    de: `Any number raised to the power of 1 equals the number itself. This is because raising to the power of 1 means using the number once. 5 ** 1 equals 5, just like any other number raised to power 1 equals itself.

Power of one rule:
• 5 ** 1 = 5 (number to power 1)
• 10 ** 1 = 10
• 3.14 ** 1 = 3.14
• Any number ** 1 = itself

How it works:
• Raising to power 1 means using number once
• x^1 = x (for any x)
• Fundamental property of exponents
• Works with all number types

Mathematical reasoning:
• Exponent 1 means "multiply once"
• x^1 = x × 1 = x
• Identity property of exponentiation

Examples:
• 5 ** 1 = 5
• 100 ** 1 = 100
• -5 ** 1 = -5
• 0.5 ** 1 = 0.5

Common uses:
• Identity operations
• Base cases
• Mathematical formulas
• Simplifying expressions

Example: 5 ** 1 returns 5 because any number raised to the power of 1 equals the number itself. This is the identity property of exponentiation.
`
  }),
  (_i: number) => ({ 
    q: `What is 5 % 5?`, 
    o: ["0", "5", "1", "Error"], 
    c: 0, 
    e: "Modulo returns remainder - same number gives 0.",
    de: `The modulo operator (%) returns the remainder after division. When you divide a number by itself, there's no remainder because it divides evenly. 5 % 5 equals 0 because 5 divided by 5 equals 1 with no remainder.

Modulo with same number:
• 5 % 5 = 0 (no remainder when dividing by itself)
• 10 % 10 = 0
• Any number % itself = 0
• Divides evenly

How it works:
• 5 ÷ 5 = 1 with remainder 0
• When dividend equals divisor, remainder is 0
• Divides evenly (no remainder)
• Always 0 for same number

Examples:
• 5 % 5 = 0
• 10 % 10 = 0
• 100 % 100 = 0
• 3.14 % 3.14 = 0.0 (for floats)

Mathematical property:
• a % a = 0 (for any a ≠ 0)
• When numbers are equal, no remainder
• Useful for checking divisibility

Common uses:
• Checking if number divides evenly: n % n == 0
• Checking if divisible: n % d == 0
• Resetting counters
• Wrapping values

Example: 5 % 5 returns 0 because when you divide 5 by 5, you get 1 with no remainder. This property is useful for checking if numbers divide evenly.
`
  }),
  (_i: number) => ({ 
    q: `What is 5 % 3?`, 
    o: ["2", "1", "0", "Error"], 
    c: 0, 
    e: "5 divided by 3 gives remainder 2.",
    de: `The modulo operator (%) returns the remainder after division. When you divide 5 by 3, you get 1 group of 3 with 2 left over. That remainder (2) is what the modulo operator returns. 5 % 3 equals 2.

Modulo operation:
• 5 % 3 = 2 (remainder when 5 divided by 3)
• 5 ÷ 3 = 1 with remainder 2
• Returns what's left after division
• Useful for many programming tasks

How it works:
• Divide first number by second
• Return the remainder after division
• 5 % 3: 5 ÷ 3 = 1 remainder 2, so 5 % 3 = 2
• Works with floats too: 5.5 % 3 = 2.5

Step-by-step:
• 5 ÷ 3 = 1.666...
• 1 × 3 = 3
• 5 - 3 = 2 (remainder)
• Result: 2

Common uses:
• Checking even/odd: n % 2 (0 = even, 1 = odd)
• Wrapping values: index % length
• Finding divisors: n % d == 0
• Time calculations: seconds % 60

Example: 5 % 3 returns 2 because when you divide 5 by 3, you get 1 group of 3 with 2 remaining. This is the remainder after division.
`
  }),
  (_i: number) => ({ 
    q: `What is 3 % 5?`, 
    o: ["3", "2", "0", "Error"], 
    c: 0, 
    e: "3 divided by 5 gives remainder 3 (3 < 5).",
    de: `The modulo operator (%) returns the remainder after division. When the dividend (first number) is smaller than the divisor (second number), the dividend itself is the remainder because it can't be divided. 3 % 5 equals 3 because 3 < 5, so 3 remains as the remainder.

Modulo when dividend < divisor:
• 3 % 5 = 3 (dividend smaller than divisor)
• 3 ÷ 5 = 0 with remainder 3
• When dividend < divisor, remainder = dividend
• Cannot divide, so dividend remains

How it works:
• 3 ÷ 5 = 0.6 (decimal) or 0 remainder 3 (integer division)
• Since 3 < 5, no complete division possible
• 0 groups of 5 fit in 3
• Remainder is 3 (the dividend itself)

Examples:
• 3 % 5 = 3 (3 < 5)
• 2 % 10 = 2 (2 < 10)
• 1 % 100 = 1 (1 < 100)
• 4 % 7 = 4 (4 < 7)

Mathematical property:
• If a < b, then a % b = a
• When dividend is smaller, it can't be divided
• Remainder equals dividend
• Useful for wrapping small values

Common uses:
• Wrapping small values
• Ensuring values stay in range
• Modular arithmetic
• Circular indexing

Example: 3 % 5 returns 3 because 3 is smaller than 5, so it can't be divided. When the dividend is less than the divisor, the modulo operation returns the dividend itself as the remainder.
`
  }),
  
  // 31-40: Order of Operations (PEMDAS)
  (_i: number) => ({ 
    q: `What is 2 * 3 + 4?`, 
    o: ["10", "14", "18", "Error"], 
    c: 0, 
    e: "Multiplication before addition (PEMDAS).",
    de: `Python follows the order of operations (PEMDAS). Multiplication has higher precedence than addition, so 2 * 3 is calculated first (equals 6), then 6 + 4 equals 10.

PEMDAS order:
• 2 * 3 + 4
• First: 2 * 3 = 6 (multiplication first)
• Then: 6 + 4 = 10 (addition second)
• Result: 10

Operator precedence:
• ** (exponentiation) - highest
• *, /, //, % (multiplication, division) - medium-high
• +, - (addition, subtraction) - medium
• Parentheses override precedence

Common mistake:
• 2 * 3 + 4 ≠ (2 * 3) + 4 = 10 (correct)
• Not 2 * (3 + 4) = 14 (wrong order)

Example: 2 * 3 + 4 evaluates to 10 because multiplication (2 * 3 = 6) happens before addition (6 + 4 = 10), following PEMDAS rules.
`
  }),
  (_i: number) => ({ 
    q: `What is 2 + 3 * 4?`, 
    o: ["14", "20", "24", "Error"], 
    c: 0, 
    e: "Multiplication before addition.",
    de: `Multiplication has higher precedence than addition in Python's order of operations. 2 + 3 * 4 calculates 3 * 4 first (equals 12), then 2 + 12 equals 14.

Order of operations:
• 2 + 3 * 4
• First: 3 * 4 = 12 (multiplication first)
• Then: 2 + 12 = 14 (addition second)
• Result: 14

PEMDAS rule:
• Multiplication (M) before Addition (A)
• 2 + 3 * 4 ≠ (2 + 3) * 4 = 20
• Must follow operator precedence

Example: 2 + 3 * 4 evaluates to 14 because multiplication (3 * 4 = 12) happens before addition (2 + 12 = 14).
`
  }),
  (_i: number) => ({ 
    q: `What is (2 + 3) * 4?`, 
    o: ["20", "14", "24", "Error"], 
    c: 0, 
    e: "Parentheses change order - addition first.",
    de: `Parentheses override the normal order of operations. (2 + 3) * 4 calculates 2 + 3 first (equals 5), then 5 * 4 equals 20.

Parentheses precedence:
• (2 + 3) * 4
• First: (2 + 3) = 5 (parentheses first)
• Then: 5 * 4 = 20 (multiplication)
• Result: 20

Without parentheses:
• 2 + 3 * 4 = 2 + 12 = 14 (multiplication first)
• Parentheses change the result!

Example: (2 + 3) * 4 evaluates to 20 because parentheses force addition first (2 + 3 = 5), then multiplication (5 * 4 = 20).
`
  }),
  (_i: number) => ({ 
    q: `What is 2 ** 3 + 4?`, 
    o: ["12", "18", "24", "Error"], 
    c: 0, 
    e: "Exponentiation before addition.",
    de: `Exponentiation has higher precedence than addition. 2 ** 3 + 4 calculates 2 ** 3 first (equals 8), then 8 + 4 equals 12.

Order of operations:
• 2 ** 3 + 4
• First: 2 ** 3 = 8 (exponentiation first)
• Then: 8 + 4 = 12 (addition second)
• Result: 12

PEMDAS:
• Exponents (E) before Addition (A)
• ** has highest precedence (except parentheses)

Example: 2 ** 3 + 4 evaluates to 12 because exponentiation (2 ** 3 = 8) happens before addition (8 + 4 = 12).
`
  }),
  (_i: number) => ({ 
    q: `What is 2 + 3 ** 4?`, 
    o: ["83", "20", "1296", "Error"], 
    c: 0, 
    e: "Exponentiation before addition: 2 + 81 = 83.",
    de: `Exponentiation has higher precedence than addition. 2 + 3 ** 4 calculates 3 ** 4 first (equals 81), then 2 + 81 equals 83.

Order of operations:
• 2 + 3 ** 4
• First: 3 ** 4 = 81 (exponentiation first)
• Then: 2 + 81 = 83 (addition second)
• Result: 83

Step-by-step:
• 3 ** 4 = 3 × 3 × 3 × 3 = 81
• 2 + 81 = 83

Example: 2 + 3 ** 4 evaluates to 83 because exponentiation (3 ** 4 = 81) happens before addition (2 + 81 = 83).
`
  }),
  (_i: number) => ({ 
    q: `What is (2 + 3) ** 4?`, 
    o: ["625", "83", "20", "Error"], 
    c: 0, 
    e: "Parentheses first, then exponentiation: 5**4 = 625.",
    de: `Parentheses override normal precedence. (2 + 3) ** 4 calculates 2 + 3 first (equals 5), then 5 ** 4 equals 625.

Parentheses precedence:
• (2 + 3) ** 4
• First: (2 + 3) = 5 (parentheses first)
• Then: 5 ** 4 = 625 (exponentiation)
• Result: 625

Step-by-step:
• 2 + 3 = 5
• 5 ** 4 = 5 × 5 × 5 × 5 = 625

Example: (2 + 3) ** 4 evaluates to 625 because parentheses force addition first (2 + 3 = 5), then exponentiation (5 ** 4 = 625).
`
  }),
  (_i: number) => ({ 
    q: `What is 10 / 2 * 4?`, 
    o: ["20.0", "1.25", "5", "Error"], 
    c: 0, 
    e: "Left to right for same precedence: (10/2)*4 = 20.0.",
    de: `When operators have the same precedence, Python evaluates them left to right. Division and multiplication have the same precedence, so 10 / 2 * 4 calculates 10 / 2 first (equals 5.0), then 5.0 * 4 equals 20.0.

Left-to-right evaluation:
• 10 / 2 * 4
• First: 10 / 2 = 5.0 (leftmost operation)
• Then: 5.0 * 4 = 20.0 (next operation)
• Result: 20.0

Same precedence:
• / and * have same precedence
• Evaluated left to right
• (10 / 2) * 4 = 5.0 * 4 = 20.0
• NOT 10 / (2 * 4) = 10 / 8 = 1.25

Example: 10 / 2 * 4 evaluates to 20.0 because division and multiplication have the same precedence, so they're evaluated left to right: (10 / 2) * 4 = 5.0 * 4 = 20.0.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 * 2 / 4?`, 
    o: ["5.0", "20", "0.5", "Error"], 
    c: 0, 
    e: "Left to right for same precedence: (10*2)/4 = 5.0.",
    de: `When operators have the same precedence, Python evaluates left to right. Multiplication and division have the same precedence, so 10 * 2 / 4 calculates 10 * 2 first (equals 20), then 20 / 4 equals 5.0.

Left-to-right evaluation:
• 10 * 2 / 4
• First: 10 * 2 = 20 (leftmost operation)
• Then: 20 / 4 = 5.0 (next operation)
• Result: 5.0

Same precedence:
• * and / have same precedence
• Evaluated left to right
• (10 * 2) / 4 = 20 / 4 = 5.0
• NOT 10 * (2 / 4) = 10 * 0.5 = 5.0 (same result by coincidence)

Example: 10 * 2 / 4 evaluates to 5.0 because multiplication and division have the same precedence, so they're evaluated left to right: (10 * 2) / 4 = 20 / 4 = 5.0.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 - 2 - 3?`, 
    o: ["5", "9", "11", "Error"], 
    c: 0, 
    e: "Left to right for subtraction: (10-2)-3 = 5.",
    de: `Subtraction is left-associative, meaning it's evaluated left to right. 10 - 2 - 3 calculates 10 - 2 first (equals 8), then 8 - 3 equals 5.

Left-to-right subtraction:
• 10 - 2 - 3
• First: 10 - 2 = 8 (leftmost operation)
• Then: 8 - 3 = 5 (next operation)
• Result: 5

Associativity:
• Subtraction is left-associative
• (10 - 2) - 3 = 8 - 3 = 5
• NOT 10 - (2 - 3) = 10 - (-1) = 11

Example: 10 - 2 - 3 evaluates to 5 because subtraction is evaluated left to right: (10 - 2) - 3 = 8 - 3 = 5.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 + 2 - 3?`, 
    o: ["9", "5", "11", "Error"], 
    c: 0, 
    e: "Left to right for same precedence: (10+2)-3 = 9.",
    de: `Addition and subtraction have the same precedence and are left-associative. 10 + 2 - 3 calculates 10 + 2 first (equals 12), then 12 - 3 equals 9.

Left-to-right evaluation:
• 10 + 2 - 3
• First: 10 + 2 = 12 (leftmost operation)
• Then: 12 - 3 = 9 (next operation)
• Result: 9

Same precedence:
• + and - have same precedence
• Evaluated left to right
• (10 + 2) - 3 = 12 - 3 = 9
• NOT 10 + (2 - 3) = 10 + (-1) = 9 (same result by coincidence)

Example: 10 + 2 - 3 evaluates to 9 because addition and subtraction have the same precedence, so they're evaluated left to right: (10 + 2) - 3 = 12 - 3 = 9.
`
  }),
  
  // 41-50: Type Conversions in Expressions
  (_i: number) => ({ 
    q: `What is float("3.14")?`, 
    o: ["3.14", "3", "Error", "None"], 
    c: 0, 
    e: "float() converts string to float.",
    de: `The float() function converts a string containing a numeric value (with or without decimal point) to a floating-point number. float("3.14") parses the string "3.14" and returns the float 3.14.

float() conversion:
• float("3.14") = 3.14 (string → float)
• Parses numeric string to float
• Works with decimal strings
• Returns float value

How it works:
• Parses string to extract number
• Handles decimal points
• Handles scientific notation: float("1e5") = 100000.0
• Returns float type

Examples:
• float("3.14") = 3.14
• float("42") = 42.0 (integer string → float)
• float("3.14159") = 3.14159
• float("  3.14  ") = 3.14 (strips whitespace)

Common uses:
• Converting user input: float(input("Enter number: "))
• Parsing decimal strings
• Converting numeric strings to floats
• Processing text-based numeric data

Example: float("3.14") returns 3.14 (a float) because it parses the string "3.14" and converts it to a floating-point number.
`
  }),
  (_i: number) => ({ 
    q: `What is int("42")?`, 
    o: ["42", '"42"', "Error", "float"], 
    c: 0, 
    e: "int() converts numeric strings to integers.",
    de: `The int() function converts a string containing numeric characters to an integer. int("42") parses the string "42" and returns the integer 42. This is essential for converting user input (which comes as strings) to numbers.

int() conversion:
• int("42") = 42 (string → integer)
• Parses numeric string to integer
• Strips whitespace: int("  42  ") = 42
• Returns integer value

How it works:
• Parses string to extract number
• Truncates decimals if present in string: int("42.9") raises ValueError
• Handles base conversion: int("FF", 16) = 255
• Returns int type

Examples:
• int("42") = 42
• int("  42  ") = 42 (whitespace stripped)
• int("42.0") raises ValueError (must be integer string)
• int("0") = 0

Common uses:
• User input: int(input("Enter age: "))
• Parsing integer strings
• Converting numeric strings to integers
• Processing text-based numeric data

Example: int("42") returns 42 (an integer) because it parses the string "42" and converts it to an integer.
`
  }),
  (_i: number) => ({ 
    q: `What is str(42)?`, 
    o: ['"42"', "42", "Error", "None"], 
    c: 0, 
    e: "str() converts values to strings.",
    de: `The str() function converts a value to its string representation. str(42) converts the integer 42 to the string "42". This is the opposite of int() or float() - it converts from numbers to strings.

str() conversion:
• str(42) = "42" (integer → string)
• Creates string representation
• Works with any type
• Returns string value

How it works:
• Converts value to string
• For numbers, creates string of digits
• For floats, includes decimal: str(3.14) = "3.14"
• Works with any type

Examples:
• str(42) = "42"
• str(3.14) = "3.14"
• str(True) = "True"
• str([1, 2]) = "[1, 2]"

Common uses:
• String formatting: "Age: " + str(age)
• Displaying numbers: print(str(42))
• Converting for concatenation
• f-strings alternative: f"Age: {42}"

Example: str(42) returns "42" (a string) because it converts the integer 42 to its string representation "42".
`
  }),
  (_i: number) => ({ 
    q: `What is int(3.7)?`, 
    o: ["3", "4", "3.7", "Error"], 
    c: 0, 
    e: "int() truncates towards zero (not rounding).",
    de: `The int() function truncates (cuts off) the decimal part of a float, moving toward zero. int(3.7) truncates to 3, not 4. This is different from rounding - it simply removes the decimal part without rounding up or down.

Truncation behavior:
• int(3.7) = 3 (truncates toward zero)
• int(3.2) = 3 (truncates toward zero)
• int(-3.7) = -3 (truncates toward zero)
• NOT rounding - just removes decimal

How it works:
• Removes decimal part
• Moves toward zero
• Positive: rounds down (toward zero)
• Negative: rounds up (toward zero)

Examples:
• int(3.7) = 3 (not 4!)
• int(3.2) = 3
• int(-3.7) = -3 (not -4!)
• int(-3.2) = -3

Comparison with round():
• int(3.7) = 3 (truncates)
• round(3.7) = 4 (rounds)
• Different operations!

Common uses:
• Converting floats to integers
• Truncating decimal parts
• Getting whole number portion
• Type conversion

Example: int(3.7) returns 3 because int() truncates (removes) the decimal part, moving toward zero. It does NOT round, so 3.7 becomes 3, not 4.
`
  }),
  (_i: number) => ({ 
    q: `What is int(-3.7)?`, 
    o: ["-3", "-4", "-3.7", "Error"], 
    c: 0, 
    e: "int() truncates towards zero for negatives too.",
    de: `The int() function truncates toward zero for both positive and negative numbers. int(-3.7) truncates to -3 (toward zero), not -4 (away from zero). This means it rounds positive numbers down and negative numbers up, both moving toward zero.

Truncation toward zero:
• int(-3.7) = -3 (toward zero, not -4)
• int(-3.2) = -3 (toward zero)
• int(3.7) = 3 (toward zero)
• Always moves toward zero

How it works:
• Removes decimal part
• Moves result toward zero
• Positive: rounds down (3.7 → 3)
• Negative: rounds up (-3.7 → -3)

Examples:
• int(-3.7) = -3 (toward zero)
• int(-3.2) = -3 (toward zero)
• int(-10.9) = -10 (toward zero)
• int(10.9) = 10 (toward zero)

Comparison with floor():
• int(-3.7) = -3 (toward zero)
• math.floor(-3.7) = -4 (toward negative infinity)
• Different for negative numbers!

Common uses:
• Converting floats to integers
• Truncating toward zero
• Getting whole number portion
• Type conversion

Example: int(-3.7) returns -3 because int() truncates toward zero. For negative numbers, this means rounding up (toward zero), so -3.7 becomes -3, not -4.
`
  }),
  (_i: number) => ({ 
    q: `What is float(5)?`, 
    o: ["5.0", "5", "Error", "None"], 
    c: 0, 
    e: "float() converts integer to float.",
    de: `The float() function converts an integer to a floating-point number by adding decimal precision. float(5) converts the integer 5 to the float 5.0. This is important because floats and ints are different types in Python.

float() conversion:
• float(5) = 5.0 (integer → float)
• Adds decimal precision (even if .0)
• Result is type float, not int
• 5.0 is different from 5 in type

How it works:
• Converts integer to float
• Adds .0 to make it a float
• Creates float type object
• Value is equivalent but type differs

Examples:
• float(5) = 5.0
• float(10) = 10.0
• float(-5) = -5.0
• float(0) = 0.0

Type differences:
• 5 is int, 5.0 is float
• 5 == 5.0 is True (values equal)
• type(5) != type(5.0) (types differ)
• 5 is 5.0 is False (different objects)

Common uses:
• Ensuring decimal precision
• Type conversion
• Calculations requiring floats
• Division operations (always produce float)

Example: float(5) returns 5.0 (a float) because it converts the integer 5 to a floating-point number by adding .0.
`
  }),
  (_i: number) => ({ 
    q: `What is str(1.0 + 2)?`, 
    o: ['"3.0"', "3.0", "Error", "None"], 
    c: 0, 
    e: "Result of math converted to string.",
    de: `The str() function converts the result of a mathematical expression to a string. First, 1.0 + 2 is calculated (equals 3.0, a float), then str(3.0) converts it to the string "3.0".

Step-by-step evaluation:
• str(1.0 + 2)
• First: 1.0 + 2 = 3.0 (float + int = float)
• Then: str(3.0) = "3.0" (float → string)
• Result: "3.0"

How it works:
• Expression inside str() is evaluated first
• 1.0 + 2 = 3.0 (float)
• str(3.0) converts float to string
• Result is string representation

Examples:
• str(1.0 + 2) = "3.0"
• str(1 + 2) = "3" (integer becomes "3")
• str(3.14 + 1) = "4.14"
• str(5 * 2) = "10"

Important:
• Expression evaluated first
• Result then converted to string
• String format matches number format
• Float strings include ".0"

Example: str(1.0 + 2) returns "3.0" because first the expression 1.0 + 2 is evaluated to 3.0 (a float), then it's converted to the string "3.0".
`
  }),
  (_i: number) => ({ 
    q: `What is type(3.14 + 1)?`, 
    o: ["<class 'float'>", "<class 'int'>", "<class 'str'>", "None"], 
    c: 0, 
    e: "Adding int to float results in float.",
    de: `When you add an integer to a float, Python promotes the integer to a float and the result is a float. 3.14 + 1 equals 4.14, which is a float. type(3.14 + 1) returns <class 'float'> because the result is always a float when mixing int and float.

Type promotion:
• 3.14 + 1 = 4.14 (float + int = float)
• type(3.14 + 1) = <class 'float'>
• Integer is promoted to float
• Result is always float

How it works:
• Python promotes int to float
• 1 becomes 1.0
• 3.14 + 1.0 = 4.14
• Result is float type

Examples:
• type(3.14 + 1) = <class 'float'>
• type(1.0 + 2) = <class 'float'>
• type(5.0 + 10) = <class 'float'>

Rule:
• int + float = float
• float + int = float
• int + int = int
• float + float = float

Example: type(3.14 + 1) returns <class 'float'> because adding an integer to a float promotes the integer to a float, and the result is a float.
`
  }),
  (_i: number) => ({ 
    q: `What is type(1 + 2)?`, 
    o: ["<class 'int'>", "<class 'float'>", "<class 'str'>", "None"], 
    c: 0, 
    e: "Adding two ints results in int.",
    de: `When you add two integers, the result is an integer. 1 + 2 equals 3, which is an integer. type(1 + 2) returns <class 'int'> because the result of adding two integers is always an integer.

Integer addition:
• 1 + 2 = 3 (int + int = int)
• type(1 + 2) = <class 'int'>
• Result is integer type
• No type promotion needed

How it works:
• Both operands are integers
• Result is integer
• No conversion needed
• Integer type maintained

Examples:
• type(1 + 2) = <class 'int'>
• type(5 + 10) = <class 'int'>
• type(100 + 200) = <class 'int'>

Rule:
• int + int = int
• float + int = float
• int + float = float
• float + float = float

Example: type(1 + 2) returns <class 'int'> because adding two integers results in an integer. No type promotion occurs when both operands are the same type.
`
  }),
  (_i: number) => ({ 
    q: `What is type(1.0 * 2)?`, 
    o: ["<class 'float'>", "<class 'int'>", "<class 'str'>", "None"], 
    c: 0, 
    e: "Multiplying float by int results in float.",
    de: `When you multiply a float by an integer, Python promotes the integer to a float and the result is a float. 1.0 * 2 equals 2.0, which is a float. type(1.0 * 2) returns <class 'float'> because the result is always a float when mixing int and float.

Type promotion:
• 1.0 * 2 = 2.0 (float * int = float)
• type(1.0 * 2) = <class 'float'>
• Integer is promoted to float
• Result is always float

How it works:
• Python promotes int to float
• 2 becomes 2.0
• 1.0 * 2.0 = 2.0
• Result is float type

Examples:
• type(1.0 * 2) = <class 'float'>
• type(3.14 * 5) = <class 'float'>
• type(2.5 * 10) = <class 'float'>

Rule:
• float * int = float
• int * float = float
• int * int = int
• float * float = float

Example: type(1.0 * 2) returns <class 'float'> because multiplying a float by an integer promotes the integer to a float, and the result is a float.
`
  }),
  
  // 51-60: String vs Numeric Operations
  (_i: number) => ({ 
    q: `Is '1' + '1' equal to '2'?`, 
    o: ["No, it is '11'", "Yes", "Error", "None"], 
    c: 0, 
    e: "String concatenation, not addition.",
    de: `When both operands are strings, the + operator performs string concatenation, not mathematical addition. '1' + '1' concatenates the strings to produce '11', not the number 2. Strings and numbers use the same operator differently.

String concatenation:
• '1' + '1' = '11' (strings concatenate)
• NOT mathematical addition
• Joins strings end-to-end
• Result is string, not number

How it works:
• Both operands are strings
• + operator concatenates (joins)
• '1' + '1' = '11' (two characters)
• NOT 1 + 1 = 2

To get 2:
• Convert strings first: int('1') + int('1') = 2
• Must explicitly convert
• Type determines behavior

Common mistake:
• '1' + '1' ≠ 2 (it's '11')
• Must convert strings to numbers first
• Remember: strings concatenate, numbers add

Example: '1' + '1' returns '11' because both are strings, so + concatenates them. To add mathematically, convert first: int('1') + int('1') = 2.
`
  }),
  (_i: number) => ({ 
    q: `What is int('1') + int('1')?`, 
    o: ["2", "'11'", "Error", "None"], 
    c: 0, 
    e: "Convert strings to ints before adding.",
    de: `To perform mathematical addition on numeric strings, you must first convert them to numbers using int() or float(). int('1') + int('1') converts both strings to integers first (1 and 1), then adds them mathematically to get 2.

Type conversion then addition:
• int('1') + int('1')
• First: int('1') = 1, int('1') = 1 (convert strings)
• Then: 1 + 1 = 2 (mathematical addition)
• Result: 2 (integer)

How it works:
• int() converts string to integer
• '1' → 1, '1' → 1
• Then integers are added: 1 + 1 = 2
• Result is integer

Examples:
• int('1') + int('1') = 2
• int('5') + int('3') = 8
• int('10') + int('20') = 30

Common pattern:
• User input is always string
• Must convert before math: int(input()) + int(input())
• Essential for numeric operations

Example: int('1') + int('1') returns 2 because the strings are converted to integers first (1 and 1), then added mathematically (1 + 1 = 2).
`
  }),
  (_i: number) => ({ 
    q: `What is '5' * 2?`, 
    o: ["'55'", "10", "Error", "None"], 
    c: 0, 
    e: "String multiplication repeats string.",
    de: `When you multiply a string by an integer, Python repeats the string that many times. '5' * 2 repeats the string '5' twice, producing '55'. This is string multiplication, not numeric multiplication.

String multiplication:
• '5' * 2 = '55' (string repeated 2 times)
• String * integer = repeated string
• NOT numeric multiplication
• Result is string

How it works:
• String is operand
• Integer is multiplier
• String is repeated that many times
• '5' * 2 = '5' + '5' = '55'

Examples:
• '5' * 2 = '55'
• 'abc' * 3 = 'abcabcabc'
• 'hello' * 0 = '' (empty string)
• 'x' * 5 = 'xxxxx'

Comparison with numeric:
• '5' * 2 = '55' (string multiplication)
• 5 * 2 = 10 (numeric multiplication)
• Type determines behavior

Common uses:
• Creating repeated patterns
• Padding: ' ' * 10 (10 spaces)
• Visual formatting
• Generating test data

Example: '5' * 2 returns '55' because string multiplication repeats the string '5' two times, producing '55'. This is different from numeric multiplication (5 * 2 = 10).
`
  }),
  (_i: number) => ({ 
    q: `What is 5 * 2?`, 
    o: ["10", "'55'", "Error", "None"], 
    c: 0, 
    e: "Numeric multiplication.",
    de: `When both operands are numbers, the * operator performs mathematical multiplication. 5 * 2 multiplies the numbers 5 and 2 to get 10. This is numeric multiplication, not string repetition.

Numeric multiplication:
• 5 * 2 = 10 (numbers multiply)
• Mathematical multiplication
• Integer * integer = integer
• Result is number

How it works:
• Both operands are numbers
• * operator multiplies
• 5 × 2 = 10
• Result is numeric

Examples:
• 5 * 2 = 10
• 3 * 4 = 12
• 5.0 * 2 = 10.0 (if one is float, result is float)

Comparison with string:
• 5 * 2 = 10 (numeric multiplication)
• '5' * 2 = '55' (string repetition)
• Type determines behavior

Common uses:
• Mathematical calculations
• Scaling values
• Area/volume calculations
• Arithmetic operations

Example: 5 * 2 returns 10 because both operands are numbers, so * performs mathematical multiplication (5 × 2 = 10).
`
  }),
  (_i: number) => ({ 
    q: `What is 'hello' + 'world'?`, 
    o: ["'helloworld'", "'hello world'", "Error", "None"], 
    c: 0, 
    e: "String concatenation joins without spaces.",
    de: `String concatenation with the + operator joins strings end-to-end without adding any separator. 'hello' + 'world' concatenates to 'helloworld' (no space between). If you want a space, you must add it explicitly.

String concatenation:
• 'hello' + 'world' = 'helloworld' (no space)
• Joins strings exactly as they are
• No automatic spacing
• Must add spaces manually

How it works:
• + operator concatenates strings
• Joins end-to-end
• No separator added
• Creates new string

Examples:
• 'hello' + 'world' = 'helloworld'
• 'hello' + ' ' + 'world' = 'hello world' (with space)
• 'a' + 'b' + 'c' = 'abc'

Adding spaces:
• 'hello' + ' ' + 'world' = 'hello world'
• 'hello ' + 'world' = 'hello world'
• 'hello' + ' world' = 'hello world'

Common uses:
• Building strings
• Combining text
• String construction
• Formatting output

Example: 'hello' + 'world' returns 'helloworld' because string concatenation joins strings without adding spaces. To add a space, use 'hello' + ' ' + 'world' or 'hello ' + 'world'.
`
  }),
  (_i: number) => ({ 
    q: `What is '5' + '3'?`, 
    o: ["'53'", "8", "Error", "None"], 
    c: 0, 
    e: "String concatenation, not numeric addition.",
    de: `When both operands are strings, the + operator performs string concatenation. '5' + '3' concatenates the strings to produce '53', not the number 8. This is a common mistake when working with numeric strings.

String concatenation:
• '5' + '3' = '53' (strings concatenate)
• NOT mathematical addition
• Joins strings: '5' + '3' = '53'
• Result is string, not number

How it works:
• Both operands are strings
• + operator concatenates
• '5' + '3' = '53' (two characters)
• NOT 5 + 3 = 8

To get 8:
• Convert strings first: int('5') + int('3') = 8
• Must explicitly convert
• Type determines behavior

Common mistake:
• '5' + '3' ≠ 8 (it's '53')
• User input is always string
• Must convert before math

Example: '5' + '3' returns '53' because both are strings, so + concatenates them. To add mathematically, convert first: int('5') + int('3') = 8.
`
  }),
  (_i: number) => ({ 
    q: `What is int('5') + int('3')?`, 
    o: ["8", "'53'", "Error", "None"], 
    c: 0, 
    e: "Convert strings to ints before adding.",
    de: `To perform mathematical addition on numeric strings, convert them to integers first using int(). int('5') + int('3') converts both strings to integers (5 and 3), then adds them mathematically to get 8.

Type conversion then addition:
• int('5') + int('3')
• First: int('5') = 5, int('3') = 3 (convert strings)
• Then: 5 + 3 = 8 (mathematical addition)
• Result: 8 (integer)

How it works:
• int() converts string to integer
• '5' → 5, '3' → 3
• Then integers are added: 5 + 3 = 8
• Result is integer

Examples:
• int('5') + int('3') = 8
• int('10') + int('20') = 30
• int('100') + int('200') = 300

Common pattern:
• User input is string: input() returns string
• Must convert: int(input("Enter number: "))
• Then perform math

Example: int('5') + int('3') returns 8 because the strings are converted to integers first (5 and 3), then added mathematically (5 + 3 = 8).
`
  }),
  (_i: number) => ({ 
    q: `What is 'abc' * 0?`, 
    o: ['""', "'abc'", "Error", "None"], 
    c: 0, 
    e: "Multiplying string by 0 gives empty string.",
    de: `When you multiply a string by 0, Python returns an empty string. 'abc' * 0 equals '' (empty string) because repeating a string zero times results in nothing. This is consistent with the mathematical property that any number times zero equals zero.

String multiplication by zero:
• 'abc' * 0 = '' (empty string)
• Repeating zero times = nothing
• Returns empty string
• Consistent with math: anything * 0 = 0

How it works:
• String * 0 = empty string
• Repeating 0 times = ''
• No characters repeated
• Empty string result

Examples:
• 'abc' * 0 = ''
• 'hello' * 0 = ''
• 'x' * 0 = ''
• '' * 0 = '' (already empty)

Mathematical analogy:
• String * 0 = '' (zero repetition)
• Number * 0 = 0 (zero multiplication)
• Similar concept: zero times = nothing

Common uses:
• Conditional string creation
• Resetting string accumulators
• Edge cases in loops
• Clearing string variables

Example: 'abc' * 0 returns '' (empty string) because multiplying a string by 0 repeats it zero times, resulting in an empty string.
`
  }),
  (_i: number) => ({ 
    q: `What is 'abc' * 1?`, 
    o: ["'abc'", "'abcabc'", "Error", "None"], 
    c: 0, 
    e: "Multiplying string by 1 gives original string.",
    de: `When you multiply a string by 1, Python returns the original string unchanged. 'abc' * 1 equals 'abc' because repeating a string once is the same as the original string. This is similar to the mathematical property that any number times 1 equals itself.

String multiplication by one:
• 'abc' * 1 = 'abc' (original string)
• Repeating once = original
• Returns string unchanged
• Consistent with math: anything * 1 = itself

How it works:
• String * 1 = original string
• Repeating 1 time = no change
• Returns same string
• Multiplicative identity

Examples:
• 'abc' * 1 = 'abc'
• 'hello' * 1 = 'hello'
• 'x' * 1 = 'x'
• '' * 1 = '' (empty string unchanged)

Mathematical analogy:
• String * 1 = original (one repetition)
• Number * 1 = same number (multiplicative identity)
• Similar concept: one times = itself

Common uses:
• Conditional string creation
• Identity operations
• Default values in loops
• Maintaining original string

Example: 'abc' * 1 returns 'abc' because multiplying a string by 1 repeats it once, which is the same as the original string.
`
  }),
  (_i: number) => ({ 
    q: `What is 'abc' * 3?`, 
    o: ["'abcabcabc'", "'abc3'", "Error", "None"], 
    c: 0, 
    e: "String multiplication repeats the string.",
    de: `When you multiply a string by an integer greater than 1, Python repeats the string that many times. 'abc' * 3 repeats the string 'abc' three times, producing 'abcabcabc'. This is string repetition, not numeric multiplication.

String multiplication:
• 'abc' * 3 = 'abcabcabc' (string repeated 3 times)
• String * integer = repeated string
• Repeats the string exactly
• Result is string

How it works:
• String is operand
• Integer is multiplier
• String is repeated that many times
• 'abc' * 3 = 'abc' + 'abc' + 'abc' = 'abcabcabc'

Examples:
• 'abc' * 3 = 'abcabcabc'
• 'x' * 5 = 'xxxxx'
• 'hello' * 2 = 'hellohello'
• ' ' * 10 = '          ' (10 spaces)

Common uses:
• Creating repeated patterns
• Padding: ' ' * 20 (20 spaces)
• Visual formatting
• Generating test data

Example: 'abc' * 3 returns 'abcabcabc' because string multiplication repeats the string 'abc' three times, concatenating them together.
`
  }),
  
  // 61-70: Comparison Operators
  (_i: number) => ({ 
    q: `Result of 10 > 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Greater than comparison.",
    de: `The > operator compares two values and returns True if the left operand is greater than the right operand. 10 > 5 returns True because 10 is greater than 5.

Greater than operator:
• 10 > 5 = True (10 is greater than 5)
• Returns boolean (True/False)
• Compares numeric values
• Works with strings (lexicographic)

How it works:
• Compares left operand to right operand
• Returns True if left > right
• Returns False otherwise
• Works with numbers, strings, etc.

Examples:
• 10 > 5 = True
• 5 > 10 = False
• 10 > 10 = False (not greater)
• "b" > "a" = True (lexicographic)

Common uses:
• Conditional statements: if x > 5:
• Range checking
• Comparisons
• Sorting

Example: 10 > 5 returns True because 10 is greater than 5.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 < 10?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Less than comparison.",
    de: `The < operator compares two values and returns True if the left operand is less than the right operand. 5 < 10 returns True because 5 is less than 10.

Less than operator:
• 5 < 10 = True (5 is less than 10)
• Returns boolean (True/False)
• Compares numeric values
• Works with strings (lexicographic)

How it works:
• Compares left operand to right operand
• Returns True if left < right
• Returns False otherwise
• Works with numbers, strings, etc.

Examples:
• 5 < 10 = True
• 10 < 5 = False
• 10 < 10 = False (not less)
• "a" < "b" = True (lexicographic)

Common uses:
• Conditional statements: if x < 10:
• Range checking
• Comparisons
• Sorting

Example: 5 < 10 returns True because 5 is less than 10.
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 >= 10?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Greater than or equal.",
    de: `The >= operator compares two values and returns True if the left operand is greater than or equal to the right operand. 10 >= 10 returns True because 10 is equal to 10 (satisfies "or equal" part).

Greater than or equal:
• 10 >= 10 = True (equal, so True)
• Returns True if left >= right
• Returns False if left < right
• Includes equality

How it works:
• Checks if left > right OR left == right
• Returns True if either condition is true
• Returns False only if left < right
• Works with numbers, strings, etc.

Examples:
• 10 >= 10 = True (equal)
• 10 >= 5 = True (greater)
• 10 >= 15 = False (neither)
• 5 >= 10 = False (less)

Common uses:
• Range checking: if age >= 18:
• Boundary conditions
• Inclusive comparisons
• Conditional logic

Example: 10 >= 10 returns True because 10 equals 10, which satisfies the "or equal" part of the >= operator.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 <= 10?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Less than or equal.",
    de: `The <= operator compares two values and returns True if the left operand is less than or equal to the right operand. 5 <= 10 returns True because 5 is less than 10 (satisfies "less than" part).

Less than or equal:
• 5 <= 10 = True (less, so True)
• Returns True if left <= right
• Returns False if left > right
• Includes equality

How it works:
• Checks if left < right OR left == right
• Returns True if either condition is true
• Returns False only if left > right
• Works with numbers, strings, etc.

Examples:
• 5 <= 10 = True (less)
• 10 <= 10 = True (equal)
• 15 <= 10 = False (greater)
• 10 <= 5 = False (greater)

Common uses:
• Range checking: if age <= 65:
• Boundary conditions
• Inclusive comparisons
• Conditional logic

Example: 5 <= 10 returns True because 5 is less than 10, which satisfies the <= operator (less than or equal).
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 == 10?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Equality check.",
    de: `The == operator compares two values for equality and returns True if they are equal. 10 == 10 returns True because both operands have the same value.

Equality operator:
• 10 == 10 = True (values are equal)
• Returns boolean (True/False)
• Compares values, not identity
• Works with numbers, strings, etc.

How it works:
• Compares left operand to right operand
• Returns True if values are equal
• Returns False if values are different
• Value comparison (not identity)

Examples:
• 10 == 10 = True
• 10 == 5 = False
• 10 == 10.0 = True (value equal, type different)
• "hello" == "hello" = True

Important distinction:
• == compares values (equality)
• is compares identity (same object)
• 10 == 10.0 is True (same value)
• 10 is 10.0 is False (different objects)

Common uses:
• Conditional statements: if x == 5:
• Checking equality
• Comparisons
• Validation

Example: 10 == 10 returns True because both operands have the same value (10).
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 != 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Inequality check.",
    de: `The != operator compares two values for inequality and returns True if they are not equal. 10 != 5 returns True because 10 is not equal to 5.

Inequality operator:
• 10 != 5 = True (values are not equal)
• Returns boolean (True/False)
• Opposite of == operator
• Works with numbers, strings, etc.

How it works:
• Compares left operand to right operand
• Returns True if values are not equal
• Returns False if values are equal
• Value comparison (not identity)

Examples:
• 10 != 5 = True (not equal)
• 10 != 10 = False (equal)
• 10 != 10.0 = False (values equal)
• "hello" != "world" = True

Logical relationship:
• a != b is same as not (a == b)
• Opposite of equality operator
• Returns True when values differ

Common uses:
• Conditional statements: if x != 0:
• Checking inequality
• Validation
• Filtering

Example: 10 != 5 returns True because 10 is not equal to 5. The != operator checks for inequality.
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 == 5?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Equality check - not equal.",
    de: `The == operator compares two values for equality. 10 == 5 returns False because 10 is not equal to 5. The equality operator returns True only when both operands have the same value.

Equality check:
• 10 == 5 = False (not equal)
• Returns boolean (True/False)
• Compares values
• Returns False when values differ

How it works:
• Compares left operand to right operand
• Returns True if values are equal
• Returns False if values are different
• 10 ≠ 5, so False

Examples:
• 10 == 5 = False (different values)
• 10 == 10 = True (same values)
• 5 == 10 = False (different values)

Common uses:
• Conditional statements: if x == 5:
• Checking equality
• Comparisons
• Validation

Example: 10 == 5 returns False because 10 is not equal to 5. The == operator returns True only when both operands are equal.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 > 10?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Greater than - false.",
    de: `The > operator compares two values and returns True if the left operand is greater than the right operand. 5 > 10 returns False because 5 is not greater than 10 (5 is less than 10).

Greater than check:
• 5 > 10 = False (5 is not greater than 10)
• Returns boolean (True/False)
• 5 < 10, so > returns False
• Checks if left > right

How it works:
• Compares left operand to right operand
• Returns True if left > right
• Returns False if left <= right
• 5 is less than 10, so False

Examples:
• 5 > 10 = False (5 < 10)
• 10 > 5 = True (10 > 5)
• 5 > 5 = False (equal, not greater)

Common uses:
• Conditional statements: if x > 10:
• Range checking
• Comparisons
• Validation

Example: 5 > 10 returns False because 5 is not greater than 10. 5 is actually less than 10, so the > operator returns False.
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 < 5?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Less than - false.",
    de: `The < operator compares two values and returns True if the left operand is less than the right operand. 10 < 5 returns False because 10 is not less than 5 (10 is greater than 5).

Less than check:
• 10 < 5 = False (10 is not less than 5)
• Returns boolean (True/False)
• 10 > 5, so < returns False
• Checks if left < right

How it works:
• Compares left operand to right operand
• Returns True if left < right
• Returns False if left >= right
• 10 is greater than 5, so False

Examples:
• 10 < 5 = False (10 > 5)
• 5 < 10 = True (5 < 10)
• 5 < 5 = False (equal, not less)

Common uses:
• Conditional statements: if x < 10:
• Range checking
• Comparisons
• Validation

Example: 10 < 5 returns False because 10 is not less than 5. 10 is actually greater than 5, so the < operator returns False.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 >= 10?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Greater than or equal - false.",
    de: `The >= operator compares two values and returns True if the left operand is greater than or equal to the right operand. 5 >= 10 returns False because 5 is neither greater than nor equal to 10 (5 < 10).

Greater than or equal check:
• 5 >= 10 = False (5 < 10, not >=)
• Returns boolean (True/False)
• 5 is less than 10, so False
• Checks if left >= right

How it works:
• Compares left operand to right operand
• Returns True if left >= right
• Returns False if left < right
• 5 < 10, so False

Examples:
• 5 >= 10 = False (5 < 10)
• 10 >= 5 = True (10 > 5)
• 10 >= 10 = True (10 == 10)

Common uses:
• Conditional statements: if x >= 10:
• Range checking
• Boundary conditions
• Validation

Example: 5 >= 10 returns False because 5 is less than 10, so it doesn't satisfy the "greater than or equal" condition.
`
  }),
  
  // 71-80: Logical Operators
  (_i: number) => ({ 
    q: `Result of 5 == 5 and 10 > 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "and requires both conditions True.",
    de: `The and operator returns True only if both conditions are True. 5 == 5 and 10 > 5 evaluates both: 5 == 5 is True, and 10 > 5 is True. Since both are True, the result is True.

and operator:
• 5 == 5 and 10 > 5 = True
• Both conditions: True and True = True
• Returns True only if both are True
• Short-circuits: if first is False, doesn't evaluate second

How it works:
• Evaluates left condition first
• If left is True, evaluates right
• Returns True only if both are True
• Returns False if either is False

Examples:
• True and True = True
• True and False = False
• False and True = False
• False and False = False

Short-circuiting:
• If first is False, second not evaluated
• Efficient for expensive operations
• Use for validation: x > 0 and expensive_check(x)

Common uses:
• Multiple conditions: if x > 0 and x < 100:
• Validation checks
• Compound conditions
• Guard clauses

Example: 5 == 5 and 10 > 5 returns True because both conditions are True (5 == 5 is True, and 10 > 5 is True).
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 == 5 and 5 > 10?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "and requires both True - second is False.",
    de: `The and operator returns True only if both conditions are True. 5 == 5 and 5 > 10 evaluates both: 5 == 5 is True, but 5 > 10 is False. Since one is False, the result is False.

and operator:
• 5 == 5 and 5 > 10 = False
• First condition: True, second: False
• True and False = False
• Returns False because second is False

How it works:
• Evaluates left condition: 5 == 5 = True
• Evaluates right condition: 5 > 10 = False
• True and False = False
• Returns False if either is False

Examples:
• True and False = False
• 5 == 5 and 5 > 10 = False
• Both must be True for result to be True

Common uses:
• Multiple conditions: if x > 0 and x < 10:
• Validation checks
• Compound conditions

Example: 5 == 5 and 5 > 10 returns False because although the first condition is True (5 == 5), the second condition is False (5 > 10), so the and operator returns False.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 == 10 or 10 > 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "or requires at least one True.",
    de: `The or operator returns True if at least one condition is True. 5 == 10 or 10 > 5 evaluates both: 5 == 10 is False, but 10 > 5 is True. Since at least one is True, the result is True.

or operator:
• 5 == 10 or 10 > 5 = True
• First condition: False, second: True
• False or True = True
• Returns True if at least one is True

How it works:
• Evaluates left condition first
• If left is True, returns True immediately (short-circuit)
• If left is False, evaluates right
• Returns True if either is True

Examples:
• True or False = True
• False or True = True
• True or True = True
• False or False = False

Short-circuiting:
• If first is True, second not evaluated
• Efficient for expensive operations
• Use for fallbacks: value or default_value

Common uses:
• Alternative conditions: if x == 5 or x == 10:
• Default values: result = value or default
• Compound conditions

Example: 5 == 10 or 10 > 5 returns True because although the first condition is False (5 == 10), the second condition is True (10 > 5), so the or operator returns True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 == 10 or 5 > 10?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "or requires at least one True - both False.",
    de: `The or operator returns True if at least one condition is True. 5 == 10 or 5 > 10 evaluates both: 5 == 10 is False, and 5 > 10 is False. Since both are False, the result is False.

or operator:
• 5 == 10 or 5 > 10 = False
• Both conditions: False or False = False
• Returns False when both are False
• Returns True only if at least one is True

How it works:
• Evaluates left condition: 5 == 10 = False
• Evaluates right condition: 5 > 10 = False
• False or False = False
• Returns False when both are False

Examples:
• False or False = False
• True or False = True
• False or True = True
• True or True = True

Common uses:
• Alternative conditions: if x == 5 or x == 10:
• Default values: result = value or default
• Compound conditions

Example: 5 == 10 or 5 > 10 returns False because both conditions are False (5 == 10 is False, and 5 > 10 is False), so the or operator returns False.
`
  }),
  (_i: number) => ({ 
    q: `Result of not 5 == 10?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "not inverts boolean result.",
    de: `The not operator inverts (negates) the boolean value of an expression. not 5 == 10 first evaluates 5 == 10 (which is False), then not False equals True. The not operator inverts the boolean result.

not operator:
• not 5 == 10 = True
• First: 5 == 10 = False
• Then: not False = True
• Inverts the boolean value

How it works:
• Evaluates the expression first
• Then inverts the result
• not True = False
• not False = True

Examples:
• not True = False
• not False = True
• not 5 == 5 = not True = False
• not 5 == 10 = not False = True

Logical relationship:
• not (a == b) is same as a != b
• Inverts comparison result
• Useful for negating conditions

Common uses:
• Negating conditions: if not x == 0:
• Inverting boolean values
• Checking for "not equal"
• Guard clauses: if not valid:

Example: not 5 == 10 returns True because first 5 == 10 evaluates to False, then not False equals True.
`
  }),
  (_i: number) => ({ 
    q: `Result of not 5 == 5?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "not inverts True to False.",
    de: `The not operator inverts the boolean value of an expression. not 5 == 5 first evaluates 5 == 5 (which is True), then not True equals False. The not operator inverts the boolean result.

not operator:
• not 5 == 5 = False
• First: 5 == 5 = True
• Then: not True = False
• Inverts True to False

How it works:
• Evaluates the expression first
• Then inverts the result
• not True = False
• not False = True

Examples:
• not True = False
• not False = True
• not 5 == 5 = not True = False
• not 5 == 10 = not False = True

Common uses:
• Negating conditions: if not valid:
• Inverting boolean values
• Checking for "not equal"
• Guard clauses

Example: not 5 == 5 returns False because first 5 == 5 evaluates to True, then not True equals False.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 < 10 < 15?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained comparisons work in Python.",
    de: `Python supports chained comparisons, allowing you to write multiple comparisons in a single expression. 5 < 10 < 15 is evaluated as (5 < 10) and (10 < 15). Both conditions are True, so the result is True.

Chained comparison:
• 5 < 10 < 15 = True
• Equivalent to: (5 < 10) and (10 < 15)
• Evaluates both conditions
• Returns True if both are True

How it works:
• Evaluates left comparison: 5 < 10 = True
• Evaluates right comparison: 10 < 15 = True
• Combines with and: True and True = True
• Returns True if chain is valid

Examples:
• 5 < 10 < 15 = True (valid chain)
• 5 < 10 < 20 = True
• 5 < 10 < 5 = False (invalid chain)
• 10 < 5 < 15 = False (invalid chain)

Common uses:
• Range checking: if 0 < x < 100:
• Multiple comparisons: if 5 < a < 10 < b < 20:
• Concise range validation

Example: 5 < 10 < 15 returns True because both conditions are True (5 < 10 is True, and 10 < 15 is True), so the chained comparison evaluates to True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 15 > 10 > 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained comparisons work both ways.",
    de: `Python supports chained comparisons in both directions. 15 > 10 > 5 is evaluated as (15 > 10) and (10 > 5). Both conditions are True, so the result is True. Chained comparisons work whether going up (<) or down (>).

Chained comparison (descending):
• 15 > 10 > 5 = True
• Equivalent to: (15 > 10) and (10 > 5)
• Evaluates both conditions
• Returns True if both are True

How it works:
• Evaluates left comparison: 15 > 10 = True
• Evaluates right comparison: 10 > 5 = True
• Combines with and: True and True = True
• Returns True if chain is valid

Examples:
• 15 > 10 > 5 = True (valid chain)
• 20 > 15 > 10 = True
• 15 > 10 > 20 = False (invalid chain)

Common uses:
• Range checking: if 100 > x > 0:
• Multiple comparisons
• Concise validation

Example: 15 > 10 > 5 returns True because both conditions are True (15 > 10 is True, and 10 > 5 is True), so the chained comparison evaluates to True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 == 5 == 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained equality checks all pairs.",
    de: `Python supports chained equality comparisons. 5 == 5 == 5 is evaluated as (5 == 5) and (5 == 5). Both conditions are True, so the result is True. However, this is a special case that works differently from other chained comparisons.

Chained equality:
• 5 == 5 == 5 = True
• Evaluates as: (5 == 5) and (5 == 5)
• All pairs must be equal
• Returns True if all are equal

How it works:
• Evaluates left comparison: 5 == 5 = True
• Evaluates right comparison: 5 == 5 = True
• Combines with and: True and True = True
• Returns True if all pairs are equal

Examples:
• 5 == 5 == 5 = True (all equal)
• 5 == 5 == 10 = False (last not equal)
• 5 == 10 == 5 = False (middle not equal)

Important note:
• This checks pairwise equality
• Not "all three are equal" semantically
• But works the same in this case

Example: 5 == 5 == 5 returns True because both comparisons are True (5 == 5 is True, and 5 == 5 is True), so the chained equality evaluates to True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 != 10 != 15?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained inequality checks all pairs.",
    de: `Python supports chained inequality comparisons. 5 != 10 != 15 is evaluated as (5 != 10) and (10 != 15). Both conditions are True (5 ≠ 10, and 10 ≠ 15), so the result is True. This checks that all adjacent pairs are not equal.

Chained inequality:
• 5 != 10 != 15 = True
• Evaluates as: (5 != 10) and (10 != 15)
• All pairs must be not equal
• Returns True if all pairs differ

How it works:
• Evaluates left comparison: 5 != 10 = True
• Evaluates right comparison: 10 != 15 = True
• Combines with and: True and True = True
• Returns True if all pairs are not equal

Examples:
• 5 != 10 != 15 = True (all different)
• 5 != 5 != 15 = False (first pair equal)
• 5 != 10 != 10 = False (second pair equal)

Common uses:
• Checking uniqueness: if a != b != c:
• Validation that values differ
• Pairwise inequality

Example: 5 != 10 != 15 returns True because both comparisons are True (5 != 10 is True, and 10 != 15 is True), so the chained inequality evaluates to True.
`
  }),
  
  // 81-90: Membership and Identity Operators
  (_i: number) => ({ 
    q: `Result of 5 in [1, 2, 3, 4, 5]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in checks membership.",
    de: `The in operator checks if a value is a member of a collection (list, tuple, string, etc.). 5 in [1, 2, 3, 4, 5] returns True because 5 is present in the list. The in operator searches through the collection and returns True if the value is found.

Membership operator:
• 5 in [1, 2, 3, 4, 5] = True (5 is in list)
• Returns boolean (True/False)
• Searches collection for value
• Returns True if found

How it works:
• Searches through collection
• Compares value with each element
• Returns True if match found
• Returns False if not found

Examples:
• 5 in [1, 2, 3, 4, 5] = True
• 10 in [1, 2, 3, 4, 5] = False
• 'a' in 'abc' = True
• 'x' in 'abc' = False

Common uses:
• Checking membership: if item in list:
• Validation: if value in valid_values:
• Filtering: [x for x in items if x in valid]
• Existence checking

Example: 5 in [1, 2, 3, 4, 5] returns True because the value 5 is found in the list [1, 2, 3, 4, 5].
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 in [1, 2, 3, 4, 5]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in checks membership - not found.",
    de: `The in operator checks if a value is a member of a collection. 10 in [1, 2, 3, 4, 5] returns False because 10 is not present in the list. The in operator searches through the collection and returns False if the value is not found.

Membership check:
• 10 in [1, 2, 3, 4, 5] = False (10 not in list)
• Returns boolean (True/False)
• Searches collection for value
• Returns False if not found

How it works:
• Searches through collection
• Compares value with each element
• Returns True if match found
• Returns False if not found

Examples:
• 10 in [1, 2, 3, 4, 5] = False
• 5 in [1, 2, 3, 4, 5] = True
• 'x' in 'abc' = False
• 'a' in 'abc' = True

Common uses:
• Checking membership: if item not in list:
• Validation: if value not in valid_values:
• Filtering: [x for x in items if x not in invalid]
• Existence checking

Example: 10 in [1, 2, 3, 4, 5] returns False because the value 10 is not found in the list [1, 2, 3, 4, 5].
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 not in [1, 2, 3]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "not in checks if value is absent.",
    de: `The not in operator is the opposite of in - it returns True if the value is NOT found in the collection. 5 not in [1, 2, 3] returns True because 5 is absent from the list [1, 2, 3]. This is useful for negative membership checks.

not in operator:
• 5 not in [1, 2, 3] = True (5 is not in list)
• Returns boolean (True/False)
• Opposite of in operator
• Returns True if value is absent

How it works:
• Searches through collection
• Returns True if value NOT found
• Returns False if value found
• Equivalent to not (value in collection)

Examples:
• 5 not in [1, 2, 3] = True (not found)
• 1 not in [1, 2, 3] = False (found)
• 'x' not in 'abc' = True (not found)
• 'a' not in 'abc' = False (found)

Common uses:
• Checking absence: if item not in list:
• Validation: if value not in invalid_values:
• Filtering: [x for x in items if x not in invalid]
• Negative checks

Example: 5 not in [1, 2, 3] returns True because the value 5 is not found in the list [1, 2, 3], so not in returns True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 1 not in [1, 2, 3]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "not in - value is present, so False.",
    de: `The not in operator returns False if the value IS found in the collection. 1 not in [1, 2, 3] returns False because 1 is present in the list [1, 2, 3]. When the value is found, not in returns False.

not in check:
• 1 not in [1, 2, 3] = False (1 is in list)
• Returns boolean (True/False)
• Opposite of in operator
• Returns False if value is present

How it works:
• Searches through collection
• Returns True if value NOT found
• Returns False if value found
• 1 is found, so False

Examples:
• 1 not in [1, 2, 3] = False (found)
• 5 not in [1, 2, 3] = True (not found)
• 'a' not in 'abc' = False (found)
• 'x' not in 'abc' = True (not found)

Logical relationship:
• value not in collection = not (value in collection)
• Inverts the result of in
• More readable for negative checks

Common uses:
• Checking absence: if item not in list:
• Validation: if value not in invalid:
• Filtering: [x for x in items if x not in invalid]
• Negative membership checks

Example: 1 not in [1, 2, 3] returns False because the value 1 is found in the list [1, 2, 3], so not in returns False.
`
  }),
  (_i: number) => ({ 
    q: `Result of 'a' in 'abc'?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in checks substring membership in strings.",
    de: `The in operator checks if a substring is contained within a string. 'a' in 'abc' returns True because the substring 'a' is found in the string 'abc'. The in operator works with strings to check substring membership.

String membership:
• 'a' in 'abc' = True ('a' is substring)
• Returns boolean (True/False)
• Checks if substring exists
• Case-sensitive check

How it works:
• Searches for substring in string
• Returns True if substring found
• Returns False if not found
• Works with single or multiple characters

Examples:
• 'a' in 'abc' = True
• 'bc' in 'abc' = True (multi-character substring)
• 'x' in 'abc' = False (not found)
• '' in 'abc' = True (empty string always matches)

Common uses:
• Checking for characters: if 'x' in text:
• Pattern matching: if 'error' in message:
• Validation: if '@' in email:
• Filtering strings

Example: 'a' in 'abc' returns True because the substring 'a' is found in the string 'abc'.
`
  }),
  (_i: number) => ({ 
    q: `Result of 'x' in 'abc'?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in checks substring - not found.",
    de: `The in operator checks if a substring is contained within a string. 'x' in 'abc' returns False because the substring 'x' is not found in the string 'abc'. The in operator works with strings to check substring membership.

String membership check:
• 'x' in 'abc' = False ('x' not in string)
• Returns boolean (True/False)
• Checks if substring exists
• Returns False if not found

How it works:
• Searches for substring in string
• Returns True if substring found
• Returns False if not found
• 'x' is not found in 'abc', so False

Examples:
• 'x' in 'abc' = False (not found)
• 'a' in 'abc' = True (found)
• 'xyz' in 'abc' = False (not found)

Common uses:
• Checking for characters: if 'x' not in text:
• Pattern matching: if 'error' not in message:
• Validation
• Filtering strings

Example: 'x' in 'abc' returns False because the substring 'x' is not found in the string 'abc'.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 is 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "is checks identity (same object).",
    de: `The is operator checks if two variables reference the same object in memory (identity), not just if they have the same value. 5 is 5 returns True because Python caches small integers, so both 5s refer to the same object. However, for larger integers or mutable objects, this may not be true.

Identity operator:
• 5 is 5 = True (same integer object)
• Checks if same object in memory
• Different from == (which checks value)
• Python caches small integers

How it works:
• Checks object identity (memory address)
• Returns True if same object
• Returns False if different objects
• Small integers are cached (singletons)

Important distinction:
• == checks value equality
• is checks object identity
• 5 == 5.0 is True (same value)
• 5 is 5.0 is False (different objects)

Examples:
• 5 is 5 = True (cached integers)
• 1000 is 1000 = True (in Python, cached)
• [1, 2] is [1, 2] = False (different list objects)
• None is None = True (singleton)

Common uses:
• Checking for None: if x is None:
• Checking for singletons: if x is True:
• Identity checks
• Object comparison

Example: 5 is 5 returns True because Python caches small integers, so both 5s refer to the same object in memory. For identity checks, use is; for value checks, use ==.
`
  }),
  (_i: number) => ({ 
    q: `Result of [1, 2] is [1, 2]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "is checks identity - different list objects.",
    de: `The is operator checks if two variables reference the same object in memory. [1, 2] is [1, 2] returns False because each list literal creates a new list object. Even though the lists have the same values, they are different objects in memory.

Identity check:
• [1, 2] is [1, 2] = False (different objects)
• Checks object identity, not value
• Each list literal creates new object
• Different memory addresses

How it works:
• Each [1, 2] creates a new list object
• Different memory addresses
• is checks if same object
• Returns False (different objects)

Important distinction:
• [1, 2] == [1, 2] = True (same values)
• [1, 2] is [1, 2] = False (different objects)
• == checks values, is checks identity

Examples:
• [1, 2] is [1, 2] = False (different objects)
• a = [1, 2]; b = a; a is b = True (same object)
• (1, 2) is (1, 2) = False (tuples too, unless cached)

Common uses:
• Checking for None: if x is None:
• Object identity checks
• Understanding object references
• Memory efficiency

Example: [1, 2] is [1, 2] returns False because each list literal creates a new list object. Even though they have the same values, they are different objects in memory. Use == to check if values are equal.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 is not 10?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "is not checks if objects are different.",
    de: `The is not operator is the opposite of is - it returns True if two variables reference different objects in memory. 5 is not 10 returns True because 5 and 10 are different objects (different values, so definitely different objects).

is not operator:
• 5 is not 10 = True (different objects)
• Returns True if different objects
• Returns False if same object
• Opposite of is operator

How it works:
• Checks object identity
• Returns True if different objects
• Returns False if same object
• 5 and 10 are different, so True

Examples:
• 5 is not 10 = True (different values/objects)
• 5 is not 5 = False (same object, for cached integers)
• None is not None = False (same singleton)
• [1, 2] is not [1, 2] = True (different objects)

Logical relationship:
• a is not b = not (a is b)
• Inverts the result of is
• More readable for negative checks

Common uses:
• Checking not None: if x is not None:
• Object identity checks
• Negative identity checks

Example: 5 is not 10 returns True because 5 and 10 are different objects (different values). The is not operator checks if objects are different.
`
  }),
  (_i: number) => ({ 
    q: `Result of None is None?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "None is a singleton - always same object.",
    de: `None is a singleton in Python - there is only one None object in the entire program. None is None returns True because all None references point to the same singleton object. This is why you should always use is None (not == None) to check for None.

None singleton:
• None is None = True (same singleton)
• There is only one None object
• All None references are the same object
• Always use is None (not == None)

How it works:
• None is a singleton object
• All None references are the same object
• is checks identity, returns True
• This is why is None is recommended

Examples:
• None is None = True (singleton)
• x = None; x is None = True
• y = None; x is y = True (same object)
• None == None = True (but use is None)

Best practice:
• Always use is None (not == None)
• More Pythonic and correct
• Faster and clearer
• Works with identity

Common uses:
• Checking for None: if x is None:
• Default values: if value is None:
• Optional parameters
• Null checking

Example: None is None returns True because None is a singleton - there is only one None object in Python, so all None references are the same object.
`
  }),
  
  // 91-100: Complex Expressions and Edge Cases
  (_i: number) => ({ 
    q: `What is -5?`, 
    o: ["-5", "5", "Error", "None"], 
    c: 0, 
    e: "Unary minus creates negative number.",
    de: `The unary minus operator (-) negates a number, creating its negative counterpart. -5 is the negative version of 5. It's called "unary" because it operates on a single operand (unlike binary operators like + which operate on two).

Unary minus:
• -5 = negative five
• Negates the value
• Creates negative number from positive
• Can negate variables too: -x

How it works:
• -5 means "negative 5" or "minus 5"
• Changes the sign: positive → negative
• -(-5) = 5 (double negation returns original)
• Works with floats: -3.14 = -3.14

Examples:
• -5 = -5
• -(-5) = 5
• -(10) = -10
• x = 5; -x = -5

Common uses:
• Representing negative values
• Inverting signs: -balance
• Temperature below zero: -10°C
• Debt/losses in finance

Example: -5 is negative five. The unary minus operator negates the number 5, creating -5.
`
  }),
  (_i: number) => ({ 
    q: `What is +5?`, 
    o: ["5", "-5", "Error", "None"], 
    c: 0, 
    e: "Unary plus is allowed but doesn't change value.",
    de: `The unary plus operator (+) is allowed in Python but doesn't change the value of a number. +5 is just 5. However, it can be useful for code clarity or in certain expressions.

Unary plus:
• +5 = 5 (doesn't change value)
• Creates no-op: +x returns x unchanged
• Valid syntax but has no effect
• Less commonly used than unary minus

Why it exists:
• Symmetry with unary minus
• Code clarity (emphasize positive value)
• Type hints/annotations
• May convert to int/float in some contexts

Behavior:
• +5 = 5 (no change)
• +(-5) = -5 (applying + doesn't negate)
• +(3.14) = 3.14 (works with floats too)
• +x = x (for any number x)

Common uses:
• Code clarity: +balance (emphasize positive)
• Type conversion in expressions
• Consistency in code style
• Mathematical notation

Example: +5 is simply 5. While valid syntax, it has no effect. Most Python code doesn't use unary plus unless needed for clarity or specific use cases.
`
  }),
  (_i: number) => ({ 
    q: `What is --5?`, 
    o: ["5", "-5", "Error", "None"], 
    c: 0, 
    e: "Double negative makes positive.",
    de: `The double negative (--5) applies the unary minus operator twice, negating the negation. --5 means -(-5), which equals 5. A double negative makes a positive, just like in mathematics.

Double negative:
• --5 = -(-5) = 5
• First negation: -5
• Second negation: -(-5) = 5
• Double negative = positive

How it works:
• First: -5 creates negative 5
• Second: -(-5) negates the negative, creating positive 5
• Result: 5 (positive)
• Double negative makes positive

Examples:
• --5 = 5
• ---5 = -5 (triple negative = negative)
• --(-5) = -5
• x = -5; --x = 5

Mathematical property:
• -(-a) = a (double negative)
• Negating a negation gives original
• Same as mathematics

Common uses:
• Mathematical expressions
• Negating negative values
• Double negation logic
• Mathematical formulas

Example: --5 returns 5 because the first - creates -5, and the second - negates -5, resulting in 5 (double negative makes positive).
`
  }),
  (_i: number) => ({ 
    q: `What is -(-5)?`, 
    o: ["5", "-5", "Error", "None"], 
    c: 0, 
    e: "Negative of negative is positive.",
    de: `When you apply the unary minus operator to a negative number, you get its positive counterpart. -(-5) means "the negative of negative 5", which equals 5. Negating a negative number makes it positive, just like in mathematics.

Negative of negative:
• -(-5) = 5
• Negating negative makes positive
• Same as --5
• Mathematical property

How it works:
• Inner: -5 is negative five
• Outer: -(-5) negates the negative
• Result: 5 (positive)
• Double negative = positive

Examples:
• -(-5) = 5
• -(-10) = 10
• -(-3.14) = 3.14
• x = -5; -x = 5

Mathematical property:
• -(-a) = a (double negative)
• Negating a negation gives original
• Fundamental mathematical property

Common uses:
• Mathematical expressions
• Negating negative values
• Converting negative to positive
• Mathematical formulas

Example: -(-5) returns 5 because negating a negative number makes it positive. This is the mathematical property that a double negative equals a positive.
`
  }),
  (_i: number) => ({ 
    q: `What is 0 // 5?`, 
    o: ["0", "Error", "None", "5"], 
    c: 0, 
    e: "Zero divided by any number is 0.",
    de: `When you divide zero by any non-zero number using floor division (//), the result is zero. 0 // 5 equals 0 because zero divided by any number equals zero. This is mathematically valid (unlike dividing by zero, which is not).

Zero divided by number:
• 0 // 5 = 0 (zero divided by any number)
• 0 ÷ 5 = 0 (mathematically)
• Returns integer 0
• Valid operation

How it works:
• Zero divided by any number equals zero
• 0 ÷ 5 = 0 (mathematically)
• Floor division returns integer
• Result: 0

Examples:
• 0 // 5 = 0
• 0 // 10 = 0
• 0 // 100 = 0
• 0 // 1 = 0

Important distinction:
• 0 // 5 = 0 (Zero divided by number - valid)
• 5 // 0 = ZeroDivisionError (Number divided by zero - invalid)
• These are different operations!

Common uses:
• Edge case handling
• Default values
• Mathematical formulas
• Division operations

Example: 0 // 5 returns 0 because zero divided by any non-zero number equals zero. This is valid (unlike 5 // 0 which raises ZeroDivisionError).
`
  }),
  (_i: number) => ({ 
    q: `What is 5 // 1?`, 
    o: ["5", "5.0", "Error", "None"], 
    c: 0, 
    e: "Any number divided by 1 is itself.",
    de: `When you divide any number by 1 using floor division (//), the result is the number itself. 5 // 1 equals 5 because any number divided by 1 equals itself. This is a fundamental mathematical property.

Division by one:
• 5 // 1 = 5 (number divided by 1)
• Any number ÷ 1 = itself
• Mathematical identity
• Returns integer (when both operands are ints)

How it works:
• Any number divided by 1 equals itself
• 5 ÷ 1 = 5 (mathematically)
• Floor division returns integer
• Result: 5

Examples:
• 5 // 1 = 5
• 10 // 1 = 10
• 100 // 1 = 100
• -5 // 1 = -5

Mathematical property:
• a ÷ 1 = a (for any a)
• One is the multiplicative identity
• Dividing by 1 doesn't change value
• Fundamental property

Common uses:
• Mathematical formulas
• Identity operations
• Edge cases
• Calculations

Example: 5 // 1 returns 5 because any number divided by 1 equals itself. This is a fundamental mathematical identity property.
`
  }),
  (_i: number) => ({ 
    q: `What is 0 % 5?`, 
    o: ["0", "5", "Error", "None"], 
    c: 0, 
    e: "0 modulo any number is 0.",
    de: `When you take 0 modulo any non-zero number, the result is 0. 0 % 5 equals 0 because when you divide 0 by 5, you get 0 groups of 5 with 0 remainder. Zero modulo any number is always 0.

Zero modulo:
• 0 % 5 = 0 (zero modulo any number)
• 0 ÷ 5 = 0 with remainder 0
• Always 0 for any non-zero divisor
• Valid operation

How it works:
• Divide zero by number
• Get zero groups with zero remainder
• 0 ÷ 5 = 0 remainder 0
• Result: 0

Examples:
• 0 % 5 = 0
• 0 % 10 = 0
• 0 % 100 = 0
• 0 % 1 = 0

Important distinction:
• 0 % 5 = 0 (Zero modulo number - valid)
• 5 % 0 = ZeroDivisionError (Number modulo zero - invalid)
• These are different operations!

Common uses:
• Edge case handling
• Wrapping calculations
• Mathematical formulas
• Modulo operations

Example: 0 % 5 returns 0 because zero divided by 5 has a remainder of 0. This is valid (unlike 5 % 0 which raises ZeroDivisionError).
`
  }),
  (_i: number) => ({ 
    q: `What is 5 % 1?`, 
    o: ["0", "5", "Error", "None"], 
    c: 0, 
    e: "Any number modulo 1 is 0.",
    de: `When you take any number modulo 1, the result is always 0. 5 % 1 equals 0 because when you divide 5 by 1, you get 5 groups of 1 with 0 remainder. Any number modulo 1 is always 0.

Modulo by one:
• 5 % 1 = 0 (any number modulo 1)
• 5 ÷ 1 = 5 with remainder 0
• Always 0 for modulo 1
• Mathematical property

How it works:
• Divide number by 1
• Get complete groups with no remainder
• 5 ÷ 1 = 5 remainder 0
• Result: 0

Examples:
• 5 % 1 = 0
• 10 % 1 = 0
• 100 % 1 = 0
• -5 % 1 = 0

Mathematical property:
• a % 1 = 0 (for any integer a)
• Dividing by 1 always has remainder 0
• Useful property

Common uses:
• Checking if integer: if x % 1 == 0:
• Decimal part extraction
• Mathematical formulas
• Edge cases

Example: 5 % 1 returns 0 because when you divide 5 by 1, you get 5 complete groups with no remainder. Any number modulo 1 is always 0.
`
  }),
  (_i: number) => ({ 
    q: `What is round(2.5)?`, 
    o: ["2", "3", "2.5", "Error"], 
    c: 0, 
    e: "round() uses banker's rounding - rounds to nearest even.",
    de: `The round() function uses "banker's rounding" (round half to even) when the decimal part is exactly .5. round(2.5) rounds to 2 because 2 is the nearest even number. This rounding method avoids statistical bias by rounding .5 to the nearest even number.

Banker's rounding:
• round(2.5) = 2 (rounds to even: 2)
• round(3.5) = 4 (rounds to even: 4)
• round(4.5) = 4 (rounds to even: 4)
• round(5.5) = 6 (rounds to even: 6)

How it works:
• If decimal part < .5, rounds down
• If decimal part > .5, rounds up
• If decimal part = .5, rounds to nearest even number
• This is "round half to even" or "IEEE 754" rounding

Why banker's rounding:
• Avoids systematic rounding bias
• More accurate in statistics
• Standard in financial calculations
• IEEE 754 standard

Examples:
• round(2.5) = 2 (even number)
• round(3.5) = 4 (even number)
• round(4.5) = 4 (even number)
• round(5.5) = 6 (even number)

Important note:
• This is different from traditional rounding
• Traditional: always round .5 up
• Banker's: round .5 to nearest even
• Python uses banker's rounding

Example: round(2.5) returns 2 because when rounding 0.5, Python rounds to the nearest even number. Since 2.5 is equidistant from 2 and 3, it chooses 2 (the even number).
`
  }),
  (_i: number) => ({ 
    q: `What is round(3.5)?`, 
    o: ["4", "3", "3.5", "Error"], 
    c: 0, 
    e: "round() uses banker's rounding - rounds to nearest even.",
    de: `The round() function uses "banker's rounding" (round half to even) when the decimal part is exactly .5. round(3.5) rounds to 4 because 4 is the nearest even number. This rounding method avoids statistical bias by rounding .5 to the nearest even number.

Banker's rounding:
• round(3.5) = 4 (rounds to even: 4)
• round(2.5) = 2 (rounds to even: 2)
• When .5, rounds to nearest even
• Avoids rounding bias

How it works:
• If decimal part < .5, rounds down
• If decimal part > .5, rounds up
• If decimal part = .5, rounds to nearest even number
• This is "round half to even" rounding

Why banker's rounding:
• Avoids systematic rounding bias
• More accurate in statistics
• Standard in financial calculations
• IEEE 754 standard

Examples:
• round(3.5) = 4 (even number)
• round(2.5) = 2 (even number)
• round(4.5) = 4 (even number)
• round(5.5) = 6 (even number)

Important note:
• Different from traditional rounding
• Traditional: always round .5 up (3.5 → 4)
• Banker's: round .5 to nearest even (2.5 → 2, 3.5 → 4)
• Python uses banker's rounding

Example: round(3.5) returns 4 because when rounding 0.5, Python rounds to the nearest even number. Since 3.5 is equidistant from 3 and 4, it chooses 4 (the even number).
`
  }),
];

// --- LEVEL 3: CRAB (Conditionals, Booleans, Logic) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level3Patterns = [
  // 1-10: Basic Boolean Logic
  (_i: number) => ({ 
    q: `Result of True and False?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "and needs both to be True.",
    de: `The and operator returns True only if both operands are True. True and False evaluates to False because the second operand is False. The and operator requires both conditions to be True for the result to be True.

and operator:
• True and False = False
• Returns True only if both are True
• Returns False if either is False
• Requires both conditions to be True

How it works:
• Evaluates left operand first: True
• Evaluates right operand: False
• True and False = False
• Returns False if either is False

Examples:
• True and True = True (both True)
• True and False = False (second False)
• False and True = False (first False)
• False and False = False (both False)

Common uses:
• Multiple conditions: if x > 0 and x < 100:
• Validation checks: if valid and available:
• Compound conditions
• Guard clauses

Example: True and False returns False because the and operator requires both operands to be True, but False is not True.
`
  }),
  (_i: number) => ({ 
    q: `Result of True or False?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "or needs only one to be True.",
    de: `The or operator returns True if at least one operand is True. True or False evaluates to True because the first operand is True. The or operator requires only one condition to be True for the result to be True.

or operator:
• True or False = True
• Returns True if at least one is True
• Returns False only if both are False
• Requires only one condition to be True

How it works:
• Evaluates left operand first: True
• Short-circuits: returns True immediately (doesn't evaluate right)
• True or False = True
• Returns True if either is True

Examples:
• True or True = True (both True)
• True or False = True (first True)
• False or True = True (second True)
• False or False = False (both False)

Short-circuiting:
• If first is True, second not evaluated
• Efficient for expensive operations
• Use for fallbacks: value or default_value

Common uses:
• Alternative conditions: if x == 5 or x == 10:
• Default values: result = value or default
• Compound conditions
• Fallback values

Example: True or False returns True because the or operator requires only one operand to be True, and the first operand (True) satisfies this condition.
`
  }),
  (_i: number) => ({ 
    q: `Result of False and False?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Both must be True for and.",
    de: `The and operator returns True only if both operands are True. False and False evaluates to False because both operands are False. The and operator requires both conditions to be True for the result to be True.

and operator:
• False and False = False
• Returns True only if both are True
• Returns False if either is False
• Both are False, so result is False

How it works:
• Evaluates left operand: False
• Short-circuits: returns False immediately (doesn't evaluate right)
• False and False = False
• Returns False if either is False

Examples:
• False and False = False (both False)
• False and True = False (first False)
• True and False = False (second False)
• True and True = True (both True)

Short-circuiting:
• If first is False, second not evaluated
• Efficient for expensive operations
• Use for validation: if x > 0 and expensive_check(x)

Common uses:
• Multiple conditions: if x > 0 and x < 100:
• Validation checks: if valid and available:
• Compound conditions

Example: False and False returns False because the and operator requires both operands to be True, but both are False.
`
  }),
  (_i: number) => ({ 
    q: `Result of False or False?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "At least one must be True for or.",
    de: `The or operator returns True if at least one operand is True. False or False evaluates to False because both operands are False. The or operator requires at least one condition to be True for the result to be True.

or operator:
• False or False = False
• Returns True if at least one is True
• Returns False only if both are False
• Both are False, so result is False

How it works:
• Evaluates left operand: False
• Evaluates right operand: False
• False or False = False
• Returns False if both are False

Examples:
• False or False = False (both False)
• False or True = True (second True)
• True or False = True (first True)
• True or True = True (both True)

Common uses:
• Alternative conditions: if x == 5 or x == 10:
• Default values: result = value or default
• Compound conditions
• Fallback values

Example: False or False returns False because the or operator requires at least one operand to be True, but both are False.
`
  }),
  (_i: number) => ({ 
    q: `Result of True and True?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Both are True, so and returns True.",
    de: `The and operator returns True only if both operands are True. True and True evaluates to True because both operands are True. The and operator requires both conditions to be True for the result to be True.

and operator:
• True and True = True
• Returns True only if both are True
• Both are True, so result is True
• Requires both conditions to be True

How it works:
• Evaluates left operand: True
• Evaluates right operand: True
• True and True = True
• Returns True if both are True

Examples:
• True and True = True (both True)
• True and False = False (second False)
• False and True = False (first False)
• False and False = False (both False)

Common uses:
• Multiple conditions: if x > 0 and x < 100:
• Validation checks: if valid and available:
• Compound conditions
• Guard clauses

Example: True and True returns True because both operands are True, satisfying the and operator's requirement.
`
  }),
  (_i: number) => ({ 
    q: `Result of True or True?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "At least one is True, so or returns True.",
    de: `The or operator returns True if at least one operand is True. True or True evaluates to True because both operands are True (so at least one is True). The or operator requires only one condition to be True for the result to be True.

or operator:
• True or True = True
• Returns True if at least one is True
• Both are True, so result is True
• Requires only one condition to be True

How it works:
• Evaluates left operand: True
• Short-circuits: returns True immediately (doesn't evaluate right)
• True or True = True
• Returns True if either is True

Examples:
• True or True = True (both True)
• True or False = True (first True)
• False or True = True (second True)
• False or False = False (both False)

Short-circuiting:
• If first is True, second not evaluated
• Efficient for expensive operations
• Use for fallbacks: value or default_value

Common uses:
• Alternative conditions: if x == 5 or x == 10:
• Default values: result = value or default
• Compound conditions
• Fallback values

Example: True or True returns True because the or operator requires only one operand to be True, and both operands are True.
`
  }),
  (_i: number) => ({ 
    q: `Result of not True?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "not inverts True to False.",
    de: `The not operator inverts (negates) the boolean value of an expression. not True evaluates to False because it inverts True to False. The not operator returns the opposite boolean value.

not operator:
• not True = False
• Inverts the boolean value
• Returns opposite boolean
• Works with any boolean expression

How it works:
• Takes boolean expression
• Inverts the result
• not True = False
• not False = True

Examples:
• not True = False
• not False = True
• not (5 > 3) = not True = False
• not (5 > 10) = not False = True

Common uses:
• Negating conditions: if not x == 0:
• Inverting boolean values
• Checking for "not equal"
• Guard clauses: if not valid:

Example: not True returns False because the not operator inverts True to False.
`
  }),
  (_i: number) => ({ 
    q: `Result of not False?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "not inverts False to True.",
    de: `The not operator inverts (negates) the boolean value of an expression. not False evaluates to True because it inverts False to True. The not operator returns the opposite boolean value.

not operator:
• not False = True
• Inverts the boolean value
• Returns opposite boolean
• Works with any boolean expression

How it works:
• Takes boolean expression
• Inverts the result
• not False = True
• not True = False

Examples:
• not False = True
• not True = False
• not (5 > 10) = not False = True
• not (5 > 3) = not True = False

Common uses:
• Negating conditions: if not x == 0:
• Inverting boolean values
• Checking for "not equal"
• Guard clauses: if not valid:

Example: not False returns True because the not operator inverts False to True.
`
  }),
  (_i: number) => ({ 
    q: `Result of not (True and False)?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Parentheses first: True and False = False, then not False = True.",
    de: `Parentheses change the order of evaluation in boolean expressions. not (True and False) evaluates the expression inside parentheses first: True and False equals False. Then not False equals True. The parentheses force the and operation to happen before the not operation.

Order of operations:
• not (True and False)
• First: (True and False) = False (parentheses first)
• Then: not False = True (not operation)
• Result: True

How it works:
• Parentheses have highest precedence
• Evaluate inside parentheses first
• Then apply not operator
• Parentheses change evaluation order

Examples:
• not (True and False) = not False = True
• not (True and True) = not True = False
• (not True) and False = False and False = False (different!)

Common uses:
• Complex boolean expressions
• Changing evaluation order
• Grouping operations
• Logical expressions

Example: not (True and False) returns True because parentheses force True and False to evaluate first (resulting in False), then not False equals True.
`
  }),
  (_i: number) => ({ 
    q: `Result of not True or False?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Operator precedence: not True = False, then False or False = False.",
    de: `Operator precedence determines the order of evaluation. In not True or False, the not operator has higher precedence than or, so not True evaluates first (equals False), then False or False equals False. Without parentheses, not binds tighter than or.

Operator precedence:
• not True or False
• First: not True = False (not has higher precedence)
• Then: False or False = False (or operation)
• Result: False

How it works:
• not has higher precedence than or
• not True evaluates first = False
• Then False or False = False
• Precedence determines evaluation order

Examples:
• not True or False = False or False = False
• (not True) or False = False or False = False (same)
• not (True or False) = not True = False (different!)

Precedence order:
• not (highest)
• and
• or (lowest)

Common uses:
• Understanding boolean precedence
• Complex boolean expressions
• Logical operations

Example: not True or False returns False because not has higher precedence than or, so not True evaluates first (False), then False or False equals False.
`
  }),
  
  // 11-20: Comparison Operators
  (_i: number) => ({ 
    q: `Result of 10 > 5?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Greater than comparison.",
    de: `The > operator compares two values and returns True if the left operand is greater than the right operand. 10 > 5 returns True because 10 is greater than 5. Comparison operators are fundamental for conditional statements (if/elif/else) and boolean logic in Python.

Greater than operator:
• 10 > 5 = True (10 is greater than 5)
• Returns boolean (True/False)
• Used in conditional statements
• Works with numbers, strings, etc.

How it works:
• Compares left operand to right operand
• Returns True if left > right
• Returns False otherwise
• Essential for if statements

Common uses:
• Conditional statements: if x > 5:
• Range checking: if age > 18:
• Comparisons and sorting
• Boolean expressions in conditionals

Example: 10 > 5 returns True because 10 is greater than 5. This boolean result is commonly used in if statements: if 10 > 5: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 < 10?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Less than comparison.",
    de: `The < operator compares two values and returns True if the left operand is less than the right operand. 5 < 10 returns True because 5 is less than 10. Comparison operators are essential for conditional statements and boolean logic in Python.

Less than operator:
• 5 < 10 = True (5 is less than 10)
• Returns boolean (True/False)
• Used in conditional statements
• Works with numbers, strings, etc.

How it works:
• Compares left operand to right operand
• Returns True if left < right
• Returns False otherwise
• Essential for if statements

Common uses:
• Conditional statements: if x < 10:
• Range checking: if age < 65:
• Comparisons and sorting
• Boolean expressions in conditionals

Example: 5 < 10 returns True because 5 is less than 10. This boolean result is commonly used in if statements: if x < 10: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 >= 10?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Greater than or equal.",
    de: `The >= operator compares two values and returns True if the left operand is greater than or equal to the right operand. 10 >= 10 returns True because 10 is equal to 10 (satisfies the "or equal" part). This operator is commonly used in conditional statements for inclusive range checking.

Greater than or equal:
• 10 >= 10 = True (equal, so True)
• Returns True if left >= right
• Returns False if left < right
• Includes equality

Common uses:
• Conditional statements: if age >= 18:
• Inclusive range checking
• Boundary conditions
• Boolean expressions in conditionals

Example: 10 >= 10 returns True because 10 equals 10, which satisfies the "or equal" condition. This is useful for inclusive comparisons: if age >= 18: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 <= 10?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Less than or equal.",
    de: `The <= operator compares two values and returns True if the left operand is less than or equal to the right operand. 5 <= 10 returns True because 5 is less than 10 (satisfies the "less than" part). This operator is commonly used in conditional statements for inclusive range checking.

Less than or equal:
• 5 <= 10 = True (less, so True)
• Returns True if left <= right
• Returns False if left > right
• Includes equality

Common uses:
• Conditional statements: if age <= 65:
• Inclusive range checking
• Boundary conditions
• Boolean expressions in conditionals

Example: 5 <= 10 returns True because 5 is less than 10, which satisfies the <= condition. This is useful for inclusive comparisons: if x <= 10: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 == 10?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Equality check.",
    de: `The == operator compares two values for equality and returns True if they are equal. 10 == 10 returns True because both operands have the same value (10). The == operator checks value equality and is the most common comparison operator used in conditional statements.

Equality operator:
• 10 == 10 = True (values are equal)
• Returns boolean (True/False)
• Compares values, not identity
• Most common comparison operator

How it works:
• Compares left operand to right operand
• Returns True if values are equal
• Returns False if values differ
• Used extensively in if statements

Important distinction:
• == compares values (equality)
• is compares identity (same object)
• 10 == 10.0 is True (same value)
• 10 is 10.0 is False (different objects)

Common uses:
• Conditional statements: if x == 5:
• Checking equality: if name == "admin":
• Validation and comparisons
• Boolean expressions in conditionals

Example: 10 == 10 returns True because both operands have the same value (10). This is commonly used in if statements: if x == 10: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 != 5?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Inequality check.",
    de: `The != operator compares two values for inequality and returns True if they are not equal. 10 != 5 returns True because 10 is not equal to 5. The != operator is the opposite of == and is commonly used in conditional statements to check if values differ.

Inequality operator:
• 10 != 5 = True (values are not equal)
• Returns boolean (True/False)
• Opposite of == operator
• Checks if values differ

How it works:
• Compares left operand to right operand
• Returns True if values are not equal
• Returns False if values are equal
• Useful for checking differences

Common uses:
• Conditional statements: if x != 0:
• Checking inequality: if status != "error":
• Validation and comparisons
• Boolean expressions in conditionals

Example: 10 != 5 returns True because 10 is not equal to 5. This is commonly used in if statements: if x != 0: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 > 10?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Greater than - false.",
    de: `The > operator compares two values and returns True if the left operand is greater than the right operand. 5 > 10 returns False because 5 is not greater than 10 (5 is actually less than 10). Understanding when comparison operators return False is important for writing correct conditional statements.

Greater than check:
• 5 > 10 = False (5 is not greater than 10)
• Returns boolean (True/False)
• 5 < 10, so > returns False
• Essential for if statements

How it works:
• Compares left operand to right operand
• Returns True if left > right
• Returns False if left <= right
• 5 is less than 10, so False

Common uses:
• Conditional statements: if x > 10:
• Range checking
• Comparisons
• Boolean expressions in conditionals

Example: 5 > 10 returns False because 5 is not greater than 10 (5 < 10). This boolean result is used in conditional statements to check conditions.
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 < 5?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Less than - false.",
    de: `The < operator compares two values and returns True if the left operand is less than the right operand. 10 < 5 returns False because 10 is not less than 5 (10 is actually greater than 5). Understanding when comparison operators return False helps write correct conditional statements.

Less than check:
• 10 < 5 = False (10 is not less than 5)
• Returns boolean (True/False)
• 10 > 5, so < returns False
• Essential for if statements

How it works:
• Compares left operand to right operand
• Returns True if left < right
• Returns False if left >= right
• 10 is greater than 5, so False

Common uses:
• Conditional statements: if x < 5:
• Range checking
• Comparisons
• Boolean expressions in conditionals

Example: 10 < 5 returns False because 10 is not less than 5 (10 > 5). This boolean result is used in conditional statements to check conditions.
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 == 5?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Equality check - not equal.",
    de: `The == operator compares two values for equality. 10 == 5 returns False because 10 is not equal to 5. The == operator returns True only when both operands have the same value. Understanding when equality checks return False is important for conditional statements.

Equality check:
• 10 == 5 = False (values are not equal)
• Returns boolean (True/False)
• 10 ≠ 5, so == returns False
• Used in conditional statements

How it works:
• Compares left operand to right operand
• Returns True if values are equal
• Returns False if values differ
• 10 ≠ 5, so False

Common uses:
• Conditional statements: if x == 5:
• Checking equality
• Validation
• Boolean expressions in conditionals

Example: 10 == 5 returns False because 10 is not equal to 5. This boolean result is used in conditional statements: if x == 5: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 >= 10?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Greater than or equal - false.",
    de: `The >= operator compares two values and returns True if the left operand is greater than or equal to the right operand. 5 >= 10 returns False because 5 is neither greater than nor equal to 10 (5 < 10). This operator is commonly used in conditional statements for inclusive range checking.

Greater than or equal check:
• 5 >= 10 = False (5 < 10, not >=)
• Returns boolean (True/False)
• 5 is less than 10, so False
• Checks if left >= right

How it works:
• Compares left operand to right operand
• Returns True if left >= right
• Returns False if left < right
• 5 < 10, so False

Common uses:
• Conditional statements: if x >= 10:
• Range checking
• Boundary conditions
• Boolean expressions in conditionals

Example: 5 >= 10 returns False because 5 is less than 10, so it doesn't satisfy the "greater than or equal" condition. This is used in conditional statements: if x >= 10: ...
`
  }),
  
  // 21-30: Identity vs Equality
  (_i: number) => ({ 
    q: `Result of 5 == 5?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "== compares values.",
    de: `The == operator compares two values for equality. 5 == 5 returns True because both operands have the same value (5). The == operator checks value equality, not object identity. This is the most common comparison operator used in conditional statements.

Equality operator:
• 5 == 5 = True (values are equal)
• Compares values, not identity
• Returns boolean (True/False)
• Used extensively in if statements

How it works:
• Compares the values of operands
• Returns True if values are equal
• Returns False if values differ
• Works with any comparable types

Important distinction:
• == compares values (equality)
• is compares identity (same object)
• 5 == 5.0 is True (same value)
• 5 is 5.0 is False (different objects)

Common uses:
• Conditional statements: if x == 5:
• Checking equality: if name == "admin":
• Validation and comparisons
• Boolean expressions in conditionals

Example: 5 == 5 returns True because both operands have the same value (5). This is commonly used in if statements: if x == 5: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 is 5?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "is checks identity (small integers are cached).",
    de: `The is operator checks if two variables reference the same object in memory (identity). 5 is 5 returns True because Python caches small integers, so both 5s refer to the same object. However, for larger integers or mutable objects, this may not be true. The is operator checks object identity, not value equality.

Identity operator:
• 5 is 5 = True (same integer object, cached)
• Checks if same object in memory
• Different from == (which checks value)
• Python caches small integers

How it works:
• Checks object identity (memory address)
• Returns True if same object
• Returns False if different objects
• Small integers are cached (singletons)

Important distinction:
• == checks value equality
• is checks object identity
• 5 == 5.0 is True (same value)
• 5 is 5.0 is False (different objects)

Common uses:
• Checking for None: if x is None:
• Checking for singletons: if x is True:
• Identity checks
• Object comparison

Example: 5 is 5 returns True because Python caches small integers, so both 5s refer to the same object in memory. For identity checks, use is; for value checks, use ==.
`
  }),
  (_i: number) => ({ 
    q: `Result of [1, 2] == [1, 2]?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "== compares list contents.",
    de: `The == operator compares the contents of lists, not their identity. [1, 2] == [1, 2] returns True because both lists have the same elements in the same order. The == operator checks value equality by comparing list contents element by element.

List equality:
• [1, 2] == [1, 2] = True (same contents)
• Compares list elements
• Returns True if contents are equal
• Order matters

How it works:
• Compares lists element by element
• Checks if same elements in same order
• Returns True if contents match
• Returns False if contents differ

Examples:
• [1, 2] == [1, 2] = True (same contents)
• [1, 2] == [2, 1] = False (different order)
• [1, 2] == [1, 2, 3] = False (different length)

Important distinction:
• [1, 2] == [1, 2] = True (same values)
• [1, 2] is [1, 2] = False (different objects)
• == checks contents, is checks identity

Common uses:
• Comparing lists: if list1 == list2:
• Checking list contents
• Validation
• Conditional statements

Example: [1, 2] == [1, 2] returns True because both lists have the same elements in the same order. The == operator compares list contents, not object identity.
`
  }),
  (_i: number) => ({ 
    q: `Result of [1, 2] is [1, 2]?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Different list objects, even with same content.",
    de: `The is operator checks if two variables reference the same object in memory. [1, 2] is [1, 2] returns False because each list literal creates a new list object. Even though the lists have the same values, they are different objects in memory. The is operator checks object identity, not value equality.

Identity check:
• [1, 2] is [1, 2] = False (different objects)
• Checks object identity, not value
• Each list literal creates new object
• Different memory addresses

How it works:
• Each [1, 2] creates a new list object
• Different memory addresses
• is checks if same object
• Returns False (different objects)

Important distinction:
• [1, 2] == [1, 2] = True (same values)
• [1, 2] is [1, 2] = False (different objects)
• == checks values, is checks identity

Examples:
• [1, 2] is [1, 2] = False (different objects)
• a = [1, 2]; b = a; a is b = True (same object)
• (1, 2) is (1, 2) = False (tuples too, unless cached)

Common uses:
• Checking for None: if x is None:
• Object identity checks
• Understanding object references
• Memory efficiency

Example: [1, 2] is [1, 2] returns False because each list literal creates a new list object. Even though they have the same values, they are different objects in memory. Use == to check if values are equal.
`
  }),
  (_i: number) => ({ 
    q: `Result of "hello" == "hello"?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "== compares string values.",
    de: `The == operator compares string values character by character. "hello" == "hello" returns True because both strings have the same characters in the same order. The == operator checks value equality by comparing string contents.

String equality:
• "hello" == "hello" = True (same contents)
• Compares string characters
• Returns True if contents are equal
• Case-sensitive

How it works:
• Compares strings character by character
• Checks if same characters in same order
• Returns True if contents match
• Returns False if contents differ

Examples:
• "hello" == "hello" = True (same contents)
• "hello" == "Hello" = False (case-sensitive)
• "hello" == "world" = False (different contents)

Important distinction:
• "hello" == "hello" = True (same values)
• "hello" is "hello" = True (may be same object due to interning)
• == checks values, is checks identity

Common uses:
• Comparing strings: if name == "admin":
• Checking string values
• Validation
• Conditional statements

Example: "hello" == "hello" returns True because both strings have the same characters in the same order. The == operator compares string values, not object identity.
`
  }),
  (_i: number) => ({ 
    q: `Result of "hello" is "hello"?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "String interning may make same strings share identity.",
    de: `The is operator checks if two variables reference the same object in memory. "hello" is "hello" may return True because Python interns (caches) string literals, so identical string literals may refer to the same object. However, this behavior is implementation-dependent and should not be relied upon. Always use == for string comparison.

String identity:
• "hello" is "hello" = True (may be same object due to interning)
• Python may intern string literals
• Implementation-dependent behavior
• Should not be relied upon

How it works:
• Python may cache string literals (interning)
• Identical literals may share same object
• is checks if same object
• Behavior is not guaranteed

Important note:
• String interning is implementation-dependent
• Always use == for string comparison
• Don't rely on is for strings
• == is the correct way to compare strings

Best practice:
• Use == for string comparison: if name == "admin":
• Don't use is for strings
• is is for None, True, False checks
• == is for value comparison

Example: "hello" is "hello" may return True due to string interning, but this behavior is not guaranteed. Always use == for string comparison: if name == "hello": ...
`
  }),
  (_i: number) => ({ 
    q: `Result of None == None?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "== compares values.",
    de: `The == operator compares values for equality. None == None returns True because both operands are None (the same value). However, for None specifically, it's recommended to use is None instead of == None, as it's more Pythonic and clearer.

None equality:
• None == None = True (same value)
• Compares values
• Returns True
• But use is None instead

How it works:
• Compares values
• Both operands are None
• Returns True (same value)
• Works, but not recommended

Best practice:
• Use is None instead of == None
• More Pythonic and clearer
• is None is the standard way
• if x is None: (recommended)

Important note:
• None == None works but is not recommended
• Always use is None for None checks
• is None is more Pythonic
• Standard Python practice

Common uses:
• Checking for None: if x is None: (recommended)
• Not recommended: if x == None:
• Use is None for clarity

Example: None == None returns True, but it's better to use is None: if x is None: ... This is more Pythonic and clearer.
`
  }),
  (_i: number) => ({ 
    q: `Result of None is None?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "None is a singleton - always same object.",
    de: `None is a singleton in Python - there is only one None object in the entire program. None is None returns True because all None references point to the same singleton object. This is why you should always use is None (not == None) to check for None.

None singleton:
• None is None = True (same singleton)
• There is only one None object
• All None references are the same object
• Always use is None (not == None)

How it works:
• None is a singleton object
• All None references are the same object
• is checks identity, returns True
• This is why is None is recommended

Best practice:
• Always use is None (not == None)
• More Pythonic and correct
• Faster and clearer
• Standard Python practice

Examples:
• None is None = True (singleton)
• x = None; x is None = True
• y = None; x is y = True (same object)
• None == None = True (but use is None)

Common uses:
• Checking for None: if x is None:
• Default values: if value is None:
• Optional parameters
• Null checking

Example: None is None returns True because None is a singleton - there is only one None object in Python, so all None references are the same object. Always use is None for None checks.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 is not 10?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "is not checks if objects are different.",
    de: `The is not operator is the opposite of is - it returns True if two variables reference different objects in memory. 5 is not 10 returns True because 5 and 10 are different objects (different values, so definitely different objects). The is not operator checks object identity, not value equality.

is not operator:
• 5 is not 10 = True (different objects)
• Returns True if different objects
• Returns False if same object
• Opposite of is operator

How it works:
• Checks object identity
• Returns True if different objects
• Returns False if same object
• 5 and 10 are different, so True

Examples:
• 5 is not 10 = True (different values/objects)
• 5 is not 5 = False (same object, for cached integers)
• None is not None = False (same singleton)
• [1, 2] is not [1, 2] = True (different objects)

Logical relationship:
• a is not b = not (a is b)
• Inverts the result of is
• More readable for negative checks

Common uses:
• Checking not None: if x is not None:
• Object identity checks
• Negative identity checks

Example: 5 is not 10 returns True because 5 and 10 are different objects (different values). The is not operator checks if objects are different.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between == and is?`, 
    o: ["== compares values, is compares identity", "No difference", "is is for strings only", "== is deprecated"], 
    c: 0, 
    e: "== compares values, is compares object identity.",
    de: `The == operator compares values for equality, while the is operator compares object identity (whether two variables reference the same object in memory). Understanding this distinction is crucial for writing correct Python code, especially in conditional statements.

Key difference:
• == compares values (equality)
• is compares identity (same object)
• Different purposes, different results

== operator:
• Compares values of operands
• Returns True if values are equal
• Works with any comparable types
• Most common comparison operator

is operator:
• Compares object identity (memory address)
• Returns True if same object
• Used for None, True, False checks
• Checks if variables reference same object

Examples:
• 5 == 5.0 = True (same value)
• 5 is 5.0 = False (different objects)
• [1, 2] == [1, 2] = True (same values)
• [1, 2] is [1, 2] = False (different objects)
• None == None = True (same value)
• None is None = True (same object, singleton)

When to use:
• Use == for value comparison: if x == 5:
• Use is for identity checks: if x is None:
• Use is for singletons: if x is True:
• Use == for most comparisons

Example: The == operator compares values (5 == 5.0 is True), while the is operator compares object identity (5 is 5.0 is False). Use == for value comparison and is for identity checks (especially None).
`
  }),
  
  // 31-40: Chained Comparisons
  (_i: number) => ({ 
    q: `Result of 5 < 10 < 15?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained comparisons work in Python.",
    de: `Python supports chained comparisons, allowing you to write multiple comparisons in a single expression. 5 < 10 < 15 is evaluated as (5 < 10) and (10 < 15). Both conditions are True, so the result is True. Chained comparisons are commonly used in conditional statements for range checking.

Chained comparison:
• 5 < 10 < 15 = True
• Equivalent to: (5 < 10) and (10 < 15)
• Evaluates both conditions
• Returns True if chain is valid

How it works:
• Evaluates left comparison: 5 < 10 = True
• Evaluates right comparison: 10 < 15 = True
• Combines with and: True and True = True
• Returns True if chain is valid

Examples:
• 5 < 10 < 15 = True (valid chain)
• 5 < 10 < 20 = True
• 5 < 10 < 5 = False (invalid chain)
• 10 < 5 < 15 = False (invalid chain)

Common uses:
• Range checking: if 0 < x < 100:
• Multiple comparisons: if 5 < a < 10 < b < 20:
• Concise range validation
• Conditional statements

Example: 5 < 10 < 15 returns True because both conditions are True (5 < 10 is True, and 10 < 15 is True), so the chained comparison evaluates to True. This is useful for range checking: if 0 < age < 120: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 15 > 10 > 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained comparisons work both ways.",
    de: `Python supports chained comparisons in both directions. 15 > 10 > 5 is evaluated as (15 > 10) and (10 > 5). Both conditions are True, so the result is True. Chained comparisons work whether going up (<) or down (>), making them useful for range checking in conditional statements.

Chained comparison (descending):
• 15 > 10 > 5 = True
• Equivalent to: (15 > 10) and (10 > 5)
• Evaluates both conditions
• Returns True if chain is valid

How it works:
• Evaluates left comparison: 15 > 10 = True
• Evaluates right comparison: 10 > 5 = True
• Combines with and: True and True = True
• Returns True if chain is valid

Examples:
• 15 > 10 > 5 = True (valid chain)
• 20 > 15 > 10 = True
• 15 > 10 > 20 = False (invalid chain)

Common uses:
• Range checking: if 100 > x > 0:
• Multiple comparisons
• Concise validation
• Conditional statements

Example: 15 > 10 > 5 returns True because both conditions are True (15 > 10 is True, and 10 > 5 is True), so the chained comparison evaluates to True. This is useful for range checking: if 100 > score > 0: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 <= 10 <= 15?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained comparisons with <= work.",
    de: `Python supports chained comparisons with <= (less than or equal). 5 <= 10 <= 15 is evaluated as (5 <= 10) and (10 <= 15). Both conditions are True, so the result is True. Chained comparisons with <= are useful for inclusive range checking in conditional statements.

Chained comparison with <=:
• 5 <= 10 <= 15 = True
• Equivalent to: (5 <= 10) and (10 <= 15)
• Evaluates both conditions
• Returns True if chain is valid

How it works:
• Evaluates left comparison: 5 <= 10 = True
• Evaluates right comparison: 10 <= 15 = True
• Combines with and: True and True = True
• Returns True if chain is valid

Examples:
• 5 <= 10 <= 15 = True (valid chain)
• 5 <= 5 <= 15 = True (boundary case)
• 5 <= 10 <= 5 = False (invalid chain)

Common uses:
• Inclusive range checking: if 0 <= x <= 100:
• Boundary conditions
• Multiple comparisons
• Conditional statements

Example: 5 <= 10 <= 15 returns True because both conditions are True (5 <= 10 is True, and 10 <= 15 is True), so the chained comparison evaluates to True. This is useful for inclusive range checking: if 0 <= age <= 120: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 15 >= 10 >= 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained comparisons with >= work.",
    de: `Python supports chained comparisons with >= (greater than or equal). 15 >= 10 >= 5 is evaluated as (15 >= 10) and (10 >= 5). Both conditions are True, so the result is True. Chained comparisons with >= are useful for inclusive range checking in conditional statements.

Chained comparison with >=:
• 15 >= 10 >= 5 = True
• Equivalent to: (15 >= 10) and (10 >= 5)
• Evaluates both conditions
• Returns True if chain is valid

How it works:
• Evaluates left comparison: 15 >= 10 = True
• Evaluates right comparison: 10 >= 5 = True
• Combines with and: True and True = True
• Returns True if chain is valid

Examples:
• 15 >= 10 >= 5 = True (valid chain)
• 15 >= 15 >= 5 = True (boundary case)
• 15 >= 10 >= 20 = False (invalid chain)

Common uses:
• Inclusive range checking: if 100 >= x >= 0:
• Boundary conditions
• Multiple comparisons
• Conditional statements

Example: 15 >= 10 >= 5 returns True because both conditions are True (15 >= 10 is True, and 10 >= 5 is True), so the chained comparison evaluates to True. This is useful for inclusive range checking: if 100 >= score >= 0: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 == 5 == 5?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained equality checks all pairs.",
    de: `Python supports chained equality comparisons. 5 == 5 == 5 is evaluated as (5 == 5) and (5 == 5). Both conditions are True, so the result is True. However, this is a special case that works differently from other chained comparisons - it checks pairwise equality.

Chained equality:
• 5 == 5 == 5 = True
• Evaluates as: (5 == 5) and (5 == 5)
• All pairs must be equal
• Returns True if all are equal

How it works:
• Evaluates left comparison: 5 == 5 = True
• Evaluates right comparison: 5 == 5 = True
• Combines with and: True and True = True
• Returns True if all pairs are equal

Examples:
• 5 == 5 == 5 = True (all equal)
• 5 == 5 == 10 = False (last not equal)
• 5 == 10 == 5 = False (middle not equal)

Important note:
• This checks pairwise equality
• Not "all three are equal" semantically
• But works the same in this case

Common uses:
• Checking multiple equalities
• Validation
• Conditional statements

Example: 5 == 5 == 5 returns True because both comparisons are True (5 == 5 is True, and 5 == 5 is True), so the chained equality evaluates to True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 != 10 != 15?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Chained inequality checks all pairs.",
    de: `Python supports chained inequality comparisons. 5 != 10 != 15 is evaluated as (5 != 10) and (10 != 15). Both conditions are True (5 ≠ 10, and 10 ≠ 15), so the result is True. This checks that all adjacent pairs are not equal, which is useful for validation in conditional statements.

Chained inequality:
• 5 != 10 != 15 = True
• Evaluates as: (5 != 10) and (10 != 15)
• All pairs must be not equal
• Returns True if all pairs differ

How it works:
• Evaluates left comparison: 5 != 10 = True
• Evaluates right comparison: 10 != 15 = True
• Combines with and: True and True = True
• Returns True if all pairs are not equal

Examples:
• 5 != 10 != 15 = True (all different)
• 5 != 5 != 15 = False (first pair equal)
• 5 != 10 != 10 = False (second pair equal)

Common uses:
• Checking uniqueness: if a != b != c:
• Validation that values differ
• Pairwise inequality
• Conditional statements

Example: 5 != 10 != 15 returns True because both comparisons are True (5 != 10 is True, and 10 != 15 is True), so the chained inequality evaluates to True. This is useful for checking that values are different: if a != b != c: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 < 10 < 5?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Chained comparison fails when middle value doesn't satisfy both.",
    de: `Chained comparisons require the middle value to satisfy both conditions. 5 < 10 < 5 is evaluated as (5 < 10) and (10 < 5). The first condition is True (5 < 10), but the second is False (10 < 5), so the result is False. The middle value (10) must satisfy both comparisons for the chain to be True.

Chained comparison failure:
• 5 < 10 < 5 = False
• Evaluates as: (5 < 10) and (10 < 5)
• First: 5 < 10 = True
• Second: 10 < 5 = False
• Result: True and False = False

How it works:
• Evaluates left comparison: 5 < 10 = True
• Evaluates right comparison: 10 < 5 = False
• Combines with and: True and False = False
• Middle value must satisfy both

Examples:
• 5 < 10 < 5 = False (middle doesn't satisfy both)
• 5 < 10 < 15 = True (middle satisfies both)
• 10 < 5 < 15 = False (first fails)

Common uses:
• Range checking: if 0 < x < 100:
• Understanding chained comparisons
• Conditional statements

Example: 5 < 10 < 5 returns False because while 5 < 10 is True, 10 < 5 is False. The middle value (10) must satisfy both comparisons for the chain to be True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 < 5 < 15?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Chained comparison fails when first condition is False.",
    de: `Chained comparisons are evaluated left to right. 10 < 5 < 15 is evaluated as (10 < 5) and (5 < 15). The first condition is False (10 < 5), so even though the second is True (5 < 15), the result is False because and requires both to be True. The first condition must be True for the chain to potentially succeed.

Chained comparison failure:
• 10 < 5 < 15 = False
• Evaluates as: (10 < 5) and (5 < 15)
• First: 10 < 5 = False
• Second: 5 < 15 = True
• Result: False and True = False

How it works:
• Evaluates left comparison: 10 < 5 = False
• Short-circuits: and returns False immediately
• Doesn't evaluate second (but would be True)
• Result: False

Examples:
• 10 < 5 < 15 = False (first fails)
• 5 < 10 < 15 = True (both succeed)
• 15 < 10 < 5 = False (first fails)

Common uses:
• Range checking: if 0 < x < 100:
• Understanding chained comparisons
• Conditional statements

Example: 10 < 5 < 15 returns False because the first condition (10 < 5) is False. Even though the second condition (5 < 15) is True, the and operator requires both to be True, so the result is False.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 < 15 < 10?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Chained comparison fails when second condition is False.",
    de: `Chained comparisons require all conditions to be True. 5 < 15 < 10 is evaluated as (5 < 15) and (15 < 10). The first condition is True (5 < 15), but the second is False (15 < 10), so the result is False. Both conditions must be True for the chain to succeed.

Chained comparison failure:
• 5 < 15 < 10 = False
• Evaluates as: (5 < 15) and (15 < 10)
• First: 5 < 15 = True
• Second: 15 < 10 = False
• Result: True and False = False

How it works:
• Evaluates left comparison: 5 < 15 = True
• Evaluates right comparison: 15 < 10 = False
• Combines with and: True and False = False
• Both must be True

Examples:
• 5 < 15 < 10 = False (second fails)
• 5 < 10 < 15 = True (both succeed)
• 5 < 15 < 20 = True (both succeed)

Common uses:
• Range checking: if 0 < x < 100:
• Understanding chained comparisons
• Conditional statements

Example: 5 < 15 < 10 returns False because while 5 < 15 is True, 15 < 10 is False. Both conditions must be True for the chained comparison to return True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 == 5 == 10?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Chained equality fails when not all pairs are equal.",
    de: `Chained equality comparisons require all pairs to be equal. 5 == 5 == 10 is evaluated as (5 == 5) and (5 == 10). The first condition is True (5 == 5), but the second is False (5 == 10), so the result is False. All pairs must be equal for the chain to return True.

Chained equality failure:
• 5 == 5 == 10 = False
• Evaluates as: (5 == 5) and (5 == 10)
• First: 5 == 5 = True
• Second: 5 == 10 = False
• Result: True and False = False

How it works:
• Evaluates left comparison: 5 == 5 = True
• Evaluates right comparison: 5 == 10 = False
• Combines with and: True and False = False
• All pairs must be equal

Examples:
• 5 == 5 == 10 = False (last pair not equal)
• 5 == 5 == 5 = True (all pairs equal)
• 5 == 10 == 5 = False (middle pair not equal)

Common uses:
• Checking multiple equalities
• Validation
• Conditional statements

Example: 5 == 5 == 10 returns False because while 5 == 5 is True, 5 == 10 is False. All pairs must be equal for the chained equality to return True.
`
  }),
  
  // 41-50: Membership Operators
  (_i: number) => ({ 
    q: `Result of 5 in [1, 2, 3, 4, 5]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in checks membership in list.",
    de: `The in operator checks if a value is a member of a collection (list, tuple, string, etc.). 5 in [1, 2, 3, 4, 5] returns True because 5 is present in the list. The in operator is commonly used in conditional statements to check membership before performing operations.

Membership operator:
• 5 in [1, 2, 3, 4, 5] = True (5 is in list)
• Returns boolean (True/False)
• Searches collection for value
• Returns True if found

How it works:
• Searches through collection
• Compares value with each element
• Returns True if match found
• Returns False if not found

Common uses:
• Conditional statements: if item in list:
• Validation: if value in valid_values:
• Filtering: [x for x in items if x in valid]
• Existence checking

Example: 5 in [1, 2, 3, 4, 5] returns True because the value 5 is found in the list. This is commonly used in if statements: if 5 in [1, 2, 3, 4, 5]: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 10 in [1, 2, 3, 4, 5]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in checks membership - not found.",
    de: `The in operator checks if a value is a member of a collection. 10 in [1, 2, 3, 4, 5] returns False because 10 is not present in the list. The in operator searches through the collection and returns False if the value is not found. This is useful for validation in conditional statements.

Membership check:
• 10 in [1, 2, 3, 4, 5] = False (10 not in list)
• Returns boolean (True/False)
• Searches collection for value
• Returns False if not found

How it works:
• Searches through collection
• Compares value with each element
• Returns True if match found
• Returns False if not found

Common uses:
• Conditional statements: if item not in list:
• Validation: if value not in invalid_values:
• Filtering: [x for x in items if x not in invalid]
• Existence checking

Example: 10 in [1, 2, 3, 4, 5] returns False because the value 10 is not found in the list. This is commonly used in if statements: if 10 not in [1, 2, 3, 4, 5]: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 not in [1, 2, 3]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "not in checks if value is absent.",
    de: `The not in operator is the opposite of in - it returns True if the value is NOT found in the collection. 5 not in [1, 2, 3] returns True because 5 is absent from the list [1, 2, 3]. This is useful for negative membership checks in conditional statements.

not in operator:
• 5 not in [1, 2, 3] = True (5 is not in list)
• Returns boolean (True/False)
• Opposite of in operator
• Returns True if value is absent

How it works:
• Searches through collection
• Returns True if value NOT found
• Returns False if value found
• Equivalent to not (value in collection)

Common uses:
• Conditional statements: if item not in list:
• Validation: if value not in invalid_values:
• Filtering: [x for x in items if x not in invalid]
• Negative checks

Example: 5 not in [1, 2, 3] returns True because the value 5 is not found in the list [1, 2, 3], so not in returns True. This is commonly used: if 5 not in [1, 2, 3]: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 1 not in [1, 2, 3]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "not in - value is present, so False.",
    de: `The not in operator returns False if the value IS found in the collection. 1 not in [1, 2, 3] returns False because 1 is present in the list [1, 2, 3]. When the value is found, not in returns False. This is useful for validation in conditional statements.

not in check:
• 1 not in [1, 2, 3] = False (1 is in list)
• Returns boolean (True/False)
• Opposite of in operator
• Returns False if value is present

How it works:
• Searches through collection
• Returns True if value NOT found
• Returns False if value found
• 1 is found, so False

Common uses:
• Conditional statements: if item not in list:
• Validation: if value not in invalid:
• Filtering: [x for x in items if x not in invalid]
• Negative membership checks

Example: 1 not in [1, 2, 3] returns False because the value 1 is found in the list [1, 2, 3], so not in returns False. This is commonly used: if 1 not in [1, 2, 3]: ... (would be False)
`
  }),
  (_i: number) => ({ 
    q: `Result of 'a' in 'abc'?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in checks substring membership in strings.",
    de: `The in operator checks if a substring is contained within a string. 'a' in 'abc' returns True because the substring 'a' is found in the string 'abc'. The in operator works with strings to check substring membership, which is commonly used in conditional statements for pattern matching.

String membership:
• 'a' in 'abc' = True ('a' is substring)
• Returns boolean (True/False)
• Checks if substring exists
• Case-sensitive check

How it works:
• Searches for substring in string
• Returns True if substring found
• Returns False if not found
• Works with single or multiple characters

Common uses:
• Conditional statements: if 'x' in text:
• Pattern matching: if 'error' in message:
• Validation: if '@' in email:
• Filtering strings

Example: 'a' in 'abc' returns True because the substring 'a' is found in the string 'abc'. This is commonly used: if 'error' in message: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 'x' in 'abc'?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in checks substring - not found.",
    de: `The in operator checks if a substring is contained within a string. 'x' in 'abc' returns False because the substring 'x' is not found in the string 'abc'. The in operator works with strings to check substring membership, which is useful for validation in conditional statements.

String membership check:
• 'x' in 'abc' = False ('x' not in string)
• Returns boolean (True/False)
• Checks if substring exists
• Returns False if not found

How it works:
• Searches for substring in string
• Returns True if substring found
• Returns False if not found
• 'x' is not found in 'abc', so False

Common uses:
• Conditional statements: if 'x' not in text:
• Pattern matching: if 'error' not in message:
• Validation
• Filtering strings

Example: 'x' in 'abc' returns False because the substring 'x' is not found in the string 'abc'. This is commonly used: if 'error' not in message: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 'ab' in 'abc'?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in checks substring - 'ab' is in 'abc'.",
    de: `The in operator checks if a substring is contained within a string. 'ab' in 'abc' returns True because the substring 'ab' is found in the string 'abc'. The in operator works with multi-character substrings, checking if they appear contiguously in the string. This is useful for pattern matching in conditional statements.

Multi-character substring:
• 'ab' in 'abc' = True ('ab' is substring)
• Returns boolean (True/False)
• Checks if substring exists contiguously
• Works with any length substring

How it works:
• Searches for substring in string
• Checks if substring appears contiguously
• Returns True if found
• Returns False if not found

Examples:
• 'ab' in 'abc' = True (found)
• 'bc' in 'abc' = True (found)
• 'ac' in 'abc' = False (not contiguous)

Common uses:
• Conditional statements: if 'error' in message:
• Pattern matching: if 'http' in url:
• Validation: if '@' in email:
• Filtering strings

Example: 'ab' in 'abc' returns True because the substring 'ab' is found contiguously in the string 'abc'. This is commonly used: if 'error' in message: ...
`
  }),
  (_i: number) => ({ 
    q: `Result of 'ac' in 'abc'?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in checks substring - 'ac' is not contiguous in 'abc'.",
    de: `The in operator checks if a substring is contained within a string contiguously. 'ac' in 'abc' returns False because while 'a' and 'c' both appear in 'abc', they are not contiguous - there's a 'b' between them. The in operator requires the substring to appear as a contiguous sequence of characters.

Substring contiguity:
• 'ac' in 'abc' = False ('ac' not contiguous)
• Returns boolean (True/False)
• Requires contiguous characters
• 'a' and 'c' are separated by 'b'

How it works:
• Searches for substring in string
• Requires substring to be contiguous
• 'a' and 'c' exist but not together
• Returns False (not contiguous)

Examples:
• 'ac' in 'abc' = False (not contiguous)
• 'ab' in 'abc' = True (contiguous)
• 'bc' in 'abc' = True (contiguous)

Common uses:
• Conditional statements: if 'pattern' in text:
• Pattern matching
• Validation
• Filtering strings

Example: 'ac' in 'abc' returns False because while 'a' and 'c' both appear in 'abc', they are not contiguous (there's a 'b' between them). The in operator requires contiguous substrings.
`
  }),
  (_i: number) => ({ 
    q: `Result of '' in 'abc'?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Empty string is always a substring.",
    de: `The in operator considers the empty string to be a substring of any string. '' in 'abc' returns True because the empty string is technically present between every character and at the beginning and end of any string. This is a mathematical property of strings - the empty string is a substring of all strings.

Empty string property:
• '' in 'abc' = True (empty string always matches)
• Returns boolean (True/False)
• Empty string is substring of all strings
• Mathematical property

How it works:
• Empty string is present everywhere
• Between every character
• At beginning and end
• Always returns True

Examples:
• '' in 'abc' = True (always)
• '' in '' = True (empty in empty)
• '' in 'hello' = True (always)

Mathematical property:
• Empty string is substring of all strings
• Present between every character
• Useful for edge cases
• Consistent behavior

Common uses:
• Edge case handling
• String operations
• Validation
• Understanding string properties

Example: '' in 'abc' returns True because the empty string is always considered a substring of any string. This is a mathematical property of strings.
`
  }),
  (_i: number) => ({ 
    q: `Result of 'x' not in 'abc'?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "not in works with strings.",
    de: `The not in operator works with strings just like it works with lists. 'x' not in 'abc' returns True because the substring 'x' is not found in the string 'abc'. The not in operator is the opposite of in and is commonly used in conditional statements for negative pattern matching.

String not in:
• 'x' not in 'abc' = True ('x' not in string)
• Returns boolean (True/False)
• Opposite of in operator
• Returns True if substring not found

How it works:
• Searches for substring in string
• Returns True if substring NOT found
• Returns False if substring found
• 'x' is not found, so True

Common uses:
• Conditional statements: if 'error' not in message:
• Pattern matching: if 'invalid' not in text:
• Validation
• Filtering strings

Example: 'x' not in 'abc' returns True because the substring 'x' is not found in the string 'abc'. This is commonly used: if 'error' not in message: ...
`
  }),
  
  // 51-60: Truthiness and Falsiness
  (_i: number) => ({ 
    q: `If x = 0, is x Truthy?`, 
    o: ["No", "Yes", "Only in loops", "Error"], 
    c: 0, 
    e: "0 is Falsy.",
    de: `In Python, values are evaluated as either "truthy" or "falsy" in boolean contexts. The number 0 is falsy, meaning it evaluates to False in conditional statements. If x = 0, then x is not truthy - it's falsy. Understanding truthiness is crucial for writing correct conditional statements.

Falsy values:
• 0 is falsy (evaluates to False)
• bool(0) = False
• if 0: ... (doesn't execute)
• Zero is falsy

How it works:
• Python evaluates values in boolean context
• 0 evaluates to False
• Falsy values: 0, 0.0, "", [], {}, None, False
• Truthy values: everything else

Common falsy values:
• 0, 0.0 (zero numbers)
• "" (empty string)
• [], {}, () (empty collections)
• None, False

Common uses:
• Conditional statements: if x: ... (checks if truthy)
• Validation: if not x: ... (checks if falsy)
• Default values: x or default
• Boolean evaluation

Example: If x = 0, then x is falsy (not truthy). In a conditional statement like if x:, the block would not execute because 0 is falsy.
`
  }),
  (_i: number) => ({ 
    q: `If x = 1, is x Truthy?`, 
    o: ["Yes", "No", "Only if positive", "Error"], 
    c: 0, 
    e: "Non-zero numbers are Truthy.",
    de: `In Python, non-zero numbers are truthy, meaning they evaluate to True in boolean contexts. If x = 1, then x is truthy. Any non-zero number (positive or negative, integer or float) is truthy. Understanding truthiness is essential for conditional statements.

Truthy numbers:
• 1 is truthy (evaluates to True)
• bool(1) = True
• if 1: ... (executes)
• Any non-zero number is truthy

How it works:
• Python evaluates values in boolean context
• Non-zero numbers evaluate to True
• 1, -1, 3.14, -100 are all truthy
• Only 0 and 0.0 are falsy

Examples:
• 1 is truthy
• -1 is truthy
• 3.14 is truthy
• 0 is falsy (only zero)

Common uses:
• Conditional statements: if x: ... (checks if truthy)
• Validation: if x: ... (checks if non-zero)
• Boolean evaluation
• Default values: x or default

Example: If x = 1, then x is truthy. In a conditional statement like if x:, the block would execute because 1 is truthy.
`
  }),
  (_i: number) => ({ 
    q: `If x = [], is bool(x) True?`, 
    o: ["No", "Yes", "Error", "None"], 
    c: 0, 
    e: "Empty lists are Falsy.",
    de: `Empty lists are falsy in Python, meaning they evaluate to False in boolean contexts. If x = [], then bool(x) returns False. Empty collections (lists, dictionaries, tuples, sets) are all falsy. Understanding this is important for conditional statements that check if collections have elements.

Empty list falsiness:
• [] is falsy (evaluates to False)
• bool([]) = False
• if []: ... (doesn't execute)
• Empty collections are falsy

How it works:
• Python evaluates values in boolean context
• Empty list evaluates to False
• Non-empty list evaluates to True
• Empty collections are falsy

Falsy collections:
• [] (empty list)
• {} (empty dictionary)
• () (empty tuple)
• set() (empty set)

Truthy collections:
• [1, 2] (non-empty list)
• {1: 2} (non-empty dictionary)
• (1, 2) (non-empty tuple)

Common uses:
• Conditional statements: if list: ... (checks if non-empty)
• Validation: if not list: ... (checks if empty)
• Boolean evaluation
• Default values: list or default

Example: If x = [], then bool(x) returns False because empty lists are falsy. In a conditional statement like if x:, the block would not execute.
`
  }),
  (_i: number) => ({ 
    q: `If x = [1, 2], is x Truthy?`, 
    o: ["Yes", "No", "Only if non-empty", "Error"], 
    c: 0, 
    e: "Non-empty lists are Truthy.",
    de: `Non-empty lists are truthy in Python, meaning they evaluate to True in boolean contexts. If x = [1, 2], then x is truthy. Any list with at least one element is truthy. Understanding this is important for conditional statements that check if collections have elements.

Non-empty list truthiness:
• [1, 2] is truthy (evaluates to True)
• bool([1, 2]) = True
• if [1, 2]: ... (executes)
• Non-empty collections are truthy

How it works:
• Python evaluates values in boolean context
• Non-empty list evaluates to True
• Any list with elements is truthy
• Only empty list [] is falsy

Examples:
• [1, 2] is truthy
• [0] is truthy (even with zero element)
• [False] is truthy (list is non-empty)
• [] is falsy (only empty list)

Common uses:
• Conditional statements: if list: ... (checks if non-empty)
• Validation: if list: ... (checks if has elements)
• Boolean evaluation
• Default values: list or default

Example: If x = [1, 2], then x is truthy. In a conditional statement like if x:, the block would execute because the list is non-empty.
`
  }),
  (_i: number) => ({ 
    q: `If x = "", is x Truthy?`, 
    o: ["No", "Yes", "Only in functions", "Error"], 
    c: 0, 
    e: "Empty strings are Falsy.",
    de: `Empty strings are falsy in Python, meaning they evaluate to False in boolean contexts. If x = "", then x is not truthy - it's falsy. Empty strings are one of the common falsy values in Python. Understanding this is important for conditional statements that check if strings have content.

Empty string falsiness:
• "" is falsy (evaluates to False)
• bool("") = False
• if "": ... (doesn't execute)
• Empty string is falsy

How it works:
• Python evaluates values in boolean context
• Empty string evaluates to False
• Non-empty string evaluates to True
• Only "" is falsy for strings

Examples:
• "" is falsy
• "hello" is truthy
• " " is truthy (space is a character)
• "" is falsy (only empty string)

Common uses:
• Conditional statements: if string: ... (checks if non-empty)
• Validation: if not string: ... (checks if empty)
• Boolean evaluation
• Default values: string or default

Example: If x = "", then x is falsy (not truthy). In a conditional statement like if x:, the block would not execute because empty strings are falsy.
`
  }),
  (_i: number) => ({ 
    q: `If x = "hello", is x Truthy?`, 
    o: ["Yes", "No", "Only if non-empty", "Error"], 
    c: 0, 
    e: "Non-empty strings are Truthy.",
    de: `Non-empty strings are truthy in Python, meaning they evaluate to True in boolean contexts. If x = "hello", then x is truthy. Any string with at least one character is truthy. Understanding this is important for conditional statements that check if strings have content.

Non-empty string truthiness:
• "hello" is truthy (evaluates to True)
• bool("hello") = True
• if "hello": ... (executes)
• Non-empty strings are truthy

How it works:
• Python evaluates values in boolean context
• Non-empty string evaluates to True
• Any string with characters is truthy
• Only "" is falsy for strings

Examples:
• "hello" is truthy
• " " is truthy (space is a character)
• "0" is truthy (string, not number)
• "" is falsy (only empty string)

Common uses:
• Conditional statements: if string: ... (checks if non-empty)
• Validation: if string: ... (checks if has content)
• Boolean evaluation
• Default values: string or default

Example: If x = "hello", then x is truthy. In a conditional statement like if x:, the block would execute because the string is non-empty.
`
  }),
  (_i: number) => ({ 
    q: `If x = None, is x Truthy?`, 
    o: ["No", "Yes", "Only in classes", "Error"], 
    c: 0, 
    e: "None is Falsy.",
    de: `None is falsy in Python, meaning it evaluates to False in boolean contexts. If x = None, then x is not truthy - it's falsy. None is one of the fundamental falsy values in Python. Understanding this is crucial for conditional statements that check for None.

None falsiness:
• None is falsy (evaluates to False)
• bool(None) = False
• if None: ... (doesn't execute)
• None is falsy

How it works:
• Python evaluates values in boolean context
• None evaluates to False
• None is a singleton falsy value
• Always use is None (not == None)

Important note:
• None is falsy
• But use is None for None checks
• if x is None: ... (recommended)
• if x == None: ... (works but not recommended)

Common uses:
• Conditional statements: if x is None: ... (recommended)
• Validation: if not x: ... (checks if falsy)
• Boolean evaluation
• Default values: x or default

Example: If x = None, then x is falsy (not truthy). In a conditional statement like if x:, the block would not execute because None is falsy. However, always use is None for None checks: if x is None: ...
`
  }),
  (_i: number) => ({ 
    q: `If x = {}, is x Truthy?`, 
    o: ["No", "Yes", "Only if non-empty", "Error"], 
    c: 0, 
    e: "Empty dictionaries are Falsy.",
    de: `Empty dictionaries are falsy in Python, meaning they evaluate to False in boolean contexts. If x = {}, then x is not truthy - it's falsy. Empty collections (dictionaries, lists, tuples, sets) are all falsy. Understanding this is important for conditional statements that check if dictionaries have key-value pairs.

Empty dictionary falsiness:
• {} is falsy (evaluates to False)
• bool({}) = False
• if {}: ... (doesn't execute)
• Empty collections are falsy

How it works:
• Python evaluates values in boolean context
• Empty dictionary evaluates to False
• Non-empty dictionary evaluates to True
• Empty collections are falsy

Falsy collections:
• {} (empty dictionary)
• [] (empty list)
• () (empty tuple)
• set() (empty set)

Truthy collections:
• {1: 2} (non-empty dictionary)
• [1, 2] (non-empty list)
• (1, 2) (non-empty tuple)

Common uses:
• Conditional statements: if dict: ... (checks if non-empty)
• Validation: if not dict: ... (checks if empty)
• Boolean evaluation
• Default values: dict or default

Example: If x = {}, then x is falsy (not truthy). In a conditional statement like if x:, the block would not execute because empty dictionaries are falsy.
`
  }),
  (_i: number) => ({ 
    q: `If x = {1: 2}, is x Truthy?`, 
    o: ["Yes", "No", "Only if non-empty", "Error"], 
    c: 0, 
    e: "Non-empty dictionaries are Truthy.",
    de: `Non-empty dictionaries are truthy in Python, meaning they evaluate to True in boolean contexts. If x = {1: 2}, then x is truthy. Any dictionary with at least one key-value pair is truthy. Understanding this is important for conditional statements that check if dictionaries have content.

Non-empty dictionary truthiness:
• {1: 2} is truthy (evaluates to True)
• bool({1: 2}) = True
• if {1: 2}: ... (executes)
• Non-empty collections are truthy

How it works:
• Python evaluates values in boolean context
• Non-empty dictionary evaluates to True
• Any dictionary with key-value pairs is truthy
• Only {} is falsy for dictionaries

Examples:
• {1: 2} is truthy
• {0: 0} is truthy (even with zero values)
• {False: False} is truthy (dictionary is non-empty)
• {} is falsy (only empty dictionary)

Common uses:
• Conditional statements: if dict: ... (checks if non-empty)
• Validation: if dict: ... (checks if has key-value pairs)
• Boolean evaluation
• Default values: dict or default

Example: If x = {1: 2}, then x is truthy. In a conditional statement like if x:, the block would execute because the dictionary is non-empty.
`
  }),
  (_i: number) => ({ 
    q: `If x = (), is x Truthy?`, 
    o: ["No", "Yes", "Only if non-empty", "Error"], 
    c: 0, 
    e: "Empty tuples are Falsy.",
    de: `Empty tuples are falsy in Python, meaning they evaluate to False in boolean contexts. If x = (), then x is not truthy - it's falsy. Empty collections (tuples, lists, dictionaries, sets) are all falsy. Understanding this is important for conditional statements that check if tuples have elements.

Empty tuple falsiness:
• () is falsy (evaluates to False)
• bool(()) = False
• if (): ... (doesn't execute)
• Empty collections are falsy

How it works:
• Python evaluates values in boolean context
• Empty tuple evaluates to False
• Non-empty tuple evaluates to True
• Empty collections are falsy

Falsy collections:
• () (empty tuple)
• [] (empty list)
• {} (empty dictionary)
• set() (empty set)

Truthy collections:
• (1, 2) (non-empty tuple)
• [1, 2] (non-empty list)
• {1: 2} (non-empty dictionary)

Common uses:
• Conditional statements: if tuple: ... (checks if non-empty)
• Validation: if not tuple: ... (checks if empty)
• Boolean evaluation
• Default values: tuple or default

Example: If x = (), then x is falsy (not truthy). In a conditional statement like if x:, the block would not execute because empty tuples are falsy.
`
  }),
  
  // 61-70: Conditional Keywords
  (_i: number) => ({ 
    q: `Which keyword links if and else?`, 
    o: ["elif", "elseif", "then", "ifnot"], 
    c: 0, 
    e: "Python uses elif.",
    de: `Python uses the keyword elif (short for "else if") to link multiple conditional branches between if and else. elif allows you to check multiple conditions in sequence. Unlike some languages that use "elseif" or "else if", Python uses the single keyword elif followed by a condition and colon.

elif keyword:
• Python uses elif (not elseif or else if)
• Links if and else statements
• Allows multiple conditional branches
• Syntax: elif condition:

How it works:
• if condition1: ... (first condition)
• elif condition2: ... (additional conditions)
• elif condition3: ... (more conditions)
• else: ... (default case)

Example structure:
if x > 10:
    print("large")
elif x > 5:
    print("medium")
elif x > 0:
    print("small")
else:
    print("zero or negative")

Common uses:
• Multiple conditional branches
• Cascading conditions
• Range checking
• Conditional logic

Example: Python uses elif to link if and else. The syntax is: if condition1: ... elif condition2: ... else: ...
`
  }),
  (_i: number) => ({ 
    q: `Can you have an 'if' without an 'else'?`, 
    o: ["Yes", "No", "Only in functions", "Error"], 
    c: 0, 
    e: "else is optional.",
    de: `The else clause is optional in Python if statements. You can have an if statement without an else block. If the condition is True, the if block executes; if False and there's no else, nothing happens. The else block is only executed when the if condition (and all elif conditions, if any) are False.

Optional else:
• else is optional
• if can stand alone
• if condition is False and no else, nothing executes
• else only needed for default case

How it works:
• if condition: ... (executes if True)
• No else needed
• If condition False, nothing happens
• else provides default behavior

Examples:
• if x > 0: print("positive") (no else)
• if x > 0: print("positive") else: print("non-positive") (with else)
• Both are valid

Common uses:
• Conditional execution without default
• Optional actions
• Guard clauses
• Conditional logic

Example: Yes, you can have an if without an else. The else clause is optional. If the condition is False and there's no else, nothing executes.
`
  }),
  (_i: number) => ({ 
    q: `Can you have multiple 'elif' statements?`, 
    o: ["Yes", "No", "Only two", "Error"], 
    c: 0, 
    e: "You can have as many elif as needed.",
    de: `Python allows you to have multiple elif statements in a single if-elif-else chain. You can have as many elif clauses as needed to check different conditions. Each elif is evaluated in order, and the first one that is True executes, with the rest being skipped.

Multiple elif:
• Yes, you can have multiple elif statements
• No limit on number of elif clauses
• Each elif checked in order
• First True condition executes

How it works:
• if condition1: ... (checked first)
• elif condition2: ... (checked if first False)
• elif condition3: ... (checked if previous False)
• else: ... (executes if all False)

Example:
if x > 100:
    print("very large")
elif x > 50:
    print("large")
elif x > 10:
    print("medium")
elif x > 0:
    print("small")
else:
    print("zero or negative")

Common uses:
• Multiple conditional branches
• Cascading conditions
• Range checking
• Complex conditional logic

Example: Yes, you can have multiple elif statements. There's no limit - you can have as many elif clauses as needed to check different conditions.
`
  }),
  (_i: number) => ({ 
    q: `What happens if all conditions in if/elif are False?`, 
    o: ["else block executes", "Error", "Nothing", "Returns None"], 
    c: 0, 
    e: "else block executes when all conditions are False.",
    de: `If all conditions in an if-elif chain are False, and there is an else clause, the else block executes. The else block provides a default action when none of the conditions are met. If there's no else clause, nothing executes when all conditions are False.

else execution:
• else block executes when all conditions False
• Provides default behavior
• Only executes if all if/elif are False
• Optional but useful for default cases

How it works:
• if condition1: ... (False, skip)
• elif condition2: ... (False, skip)
• elif condition3: ... (False, skip)
• else: ... (executes - default case)

Example:
if x > 10:
    print("large")
elif x > 5:
    print("medium")
else:
    print("small")  # Executes if x <= 5

Common uses:
• Default behavior
• Handling all other cases
• Fallback actions
• Complete conditional logic

Example: If all conditions in if/elif are False, the else block executes (if present). This provides default behavior when none of the conditions are met.
`
  }),
  (_i: number) => ({ 
    q: `What happens if no 'else' and all conditions are False?`, 
    o: ["Nothing executes", "Error", "Returns None", "Executes if block"], 
    c: 0, 
    e: "If no else and all conditions False, nothing executes.",
    de: `If there's no else clause and all conditions (if and all elif) are False, nothing executes. The program simply continues to the next statement after the if-elif chain. No error occurs - it's perfectly valid to have an if statement without an else.

No else behavior:
• If no else and all conditions False, nothing executes
• Program continues normally
• No error occurs
• Valid Python code

How it works:
• if condition1: ... (False, skip)
• elif condition2: ... (False, skip)
• No else clause
• Nothing executes, program continues

Example:
if x > 10:
    print("large")
elif x > 5:
    print("medium")
# If x <= 5, nothing happens, program continues

Common uses:
• Optional actions
• Conditional execution without default
• Guard clauses
• Conditional logic

Example: If there's no else and all conditions are False, nothing executes. The program simply continues to the next statement - no error occurs.
`
  }),
  (_i: number) => ({ 
    q: `Which operator checks inequality?`, 
    o: ["!=", "<>", "not", "=="], 
    c: 0, 
    e: "!= is standard (<> was in Python 2).",
    de: `The != operator checks for inequality in Python. It returns True if two values are not equal, False if they are equal. The != operator is the standard way to check inequality in Python 3. Note that <> was used in Python 2 but is not available in Python 3.

Inequality operator:
• != is the standard inequality operator
• Returns True if values not equal
• Returns False if values equal
• Used in conditional statements

How it works:
• a != b returns True if a ≠ b
• a != b returns False if a == b
• Opposite of == operator
• Works with any comparable types

Examples:
• 5 != 3 = True (not equal)
• 5 != 5 = False (equal)
• "hello" != "world" = True (not equal)
• "hello" != "hello" = False (equal)

Python 2 vs Python 3:
• Python 2: != and <> both worked
• Python 3: Only != (<> removed)
• != is the standard way

Common uses:
• Conditional statements: if x != 0:
• Checking inequality: if status != "error":
• Validation and comparisons
• Boolean expressions

Example: The != operator checks inequality. It's the standard way in Python 3 (<> was used in Python 2 but is not available in Python 3).
`
  }),
  (_i: number) => ({ 
    q: `Which operator checks identity?`, 
    o: ["is", "==", "=", "==="], 
    c: 0, 
    e: "is checks object identity.",
    de: `The is operator checks object identity in Python - whether two variables reference the same object in memory. The is operator is different from == which checks value equality. The is operator is commonly used to check for None, True, False, and other singleton objects.

Identity operator:
• is checks object identity (same object)
• Different from == (which checks values)
• Returns True if same object
• Returns False if different objects

How it works:
• Checks if variables reference same object
• Compares memory addresses
• Returns True if same object
• Returns False if different objects

Examples:
• 5 is 5 = True (cached integers)
• [1, 2] is [1, 2] = False (different objects)
• None is None = True (singleton)
• x is None = True (if x is None)

Important distinction:
• == compares values (equality)
• is compares identity (same object)
• Use == for value comparison
• Use is for identity checks (especially None)

Common uses:
• Checking for None: if x is None:
• Checking for singletons: if x is True:
• Identity checks
• Object comparison

Example: The is operator checks object identity. It's commonly used to check for None: if x is None: ... (not if x == None:)
`
  }),
  (_i: number) => ({ 
    q: `What is the syntax for if statement?`, 
    o: ["if condition:", "if (condition)", "if condition then", "if condition {"], 
    c: 0, 
    e: "Python uses colon and indentation.",
    de: `Python if statements use a colon (:) after the condition and indentation to define the block. The syntax is: if condition:. Unlike some languages that use parentheses or braces, Python uses a colon and indentation. The colon is required, and the indented code below is the block that executes if the condition is True.

if syntax:
• if condition: (colon required)
• Indentation defines block
• No parentheses needed (but allowed)
• No braces or "then" keyword

How it works:
• if condition: (colon after condition)
• Next line(s) indented = block
• Block executes if condition True
• Dedent to end block

Examples:
• if x > 0: print("positive") (one line)
• if x > 0: (multi-line)
    print("positive")
    print("x is positive")

Common uses:
• Conditional execution
• Control flow
• Decision making
• Conditional logic

Example: Python if statement syntax is: if condition:. The colon is required, and the indented code below is the block that executes if the condition is True.
`
  }),
  (_i: number) => ({ 
    q: `What is the syntax for else statement?`, 
    o: ["else:", "else {", "else then", "else if"], 
    c: 0, 
    e: "Python uses colon and indentation.",
    de: `Python else statements use a colon (:) and indentation to define the block. The syntax is: else:. The else keyword is followed by a colon, and the indented code below is the block that executes when the if (and all elif) conditions are False. Python uses indentation, not braces or "then" keywords.

else syntax:
• else: (colon required)
• Indentation defines block
• No condition (executes when if/elif False)
• No braces or "then" keyword

How it works:
• else: (colon after else)
• Next line(s) indented = block
• Block executes if all if/elif False
• Dedent to end block

Examples:
• if x > 0: print("positive") else: print("non-positive") (one line)
• if x > 0: (multi-line)
    print("positive")
else:
    print("non-positive")

Common uses:
• Default behavior
• Handling all other cases
• Fallback actions
• Complete conditional logic

Example: Python else statement syntax is: else:. The colon is required, and the indented code below is the block that executes when all if/elif conditions are False.
`
  }),
  (_i: number) => ({ 
    q: `What is the syntax for elif statement?`, 
    o: ["elif condition:", "elseif condition:", "elif (condition)", "elif condition then"], 
    c: 0, 
    e: "Python uses elif with colon.",
    de: `Python elif statements use the keyword elif followed by a condition and colon. The syntax is: elif condition:. The elif keyword (short for "else if") is followed by a condition, then a colon, and the indented code below is the block that executes if the condition is True and all previous if/elif conditions were False.

elif syntax:
• elif condition: (colon required)
• Indentation defines block
• No parentheses needed (but allowed)
• No braces or "then" keyword

How it works:
• elif condition: (colon after condition)
• Next line(s) indented = block
• Block executes if condition True and previous False
• Dedent to end block

Examples:
• if x > 10: print("large") elif x > 5: print("medium") else: print("small") (one line)
• if x > 10: (multi-line)
    print("large")
elif x > 5:
    print("medium")
else:
    print("small")

Common uses:
• Multiple conditional branches
• Cascading conditions
• Range checking
• Complex conditional logic

Example: Python elif statement syntax is: elif condition:. The colon is required, and the indented code below is the block that executes if the condition is True and all previous conditions were False.
`
  }),
  
  // 71-80: Ternary Operator
  (_i: number) => ({ 
    q: `What is 5 if 5 > 3 else 3?`, 
    o: ["5", "3", "Error", "None"], 
    c: 0, 
    e: "Ternary operator: value_if_true if condition else value_if_false.",
    de: `Python's ternary operator (conditional expression) has the syntax: value_if_true if condition else value_if_false. 5 if 5 > 3 else 3 evaluates the condition first: 5 > 3 is True, so it returns 5 (the value_if_true). The ternary operator is a concise way to write simple if-else statements in a single line.

Ternary operator syntax:
• value_if_true if condition else value_if_false
• Evaluates condition first
• Returns value_if_true if condition True
• Returns value_if_false if condition False

How it works:
• 5 if 5 > 3 else 3
• First: 5 > 3 = True
• Since True, returns 5 (value_if_true)
• Result: 5

Examples:
• 5 if 5 > 3 else 3 = 5 (condition True)
• 3 if 3 > 5 else 5 = 5 (condition False)
• 'yes' if True else 'no' = 'yes'

Common uses:
• Concise conditional assignment: x = 5 if condition else 3
• Simple if-else in one line
• Conditional values
• Default values

Example: 5 if 5 > 3 else 3 returns 5 because the condition (5 > 3) is True, so it returns the value_if_true (5).
`
  }),
  (_i: number) => ({ 
    q: `What is 3 if 3 > 5 else 5?`, 
    o: ["5", "3", "Error", "None"], 
    c: 0, 
    e: "Ternary operator returns else value when condition is False.",
    de: `Python's ternary operator returns the else value when the condition is False. 3 if 3 > 5 else 5 evaluates the condition first: 3 > 5 is False, so it returns 5 (the value_if_false). The ternary operator provides a concise way to choose between two values based on a condition.

Ternary operator:
• 3 if 3 > 5 else 5
• First: 3 > 5 = False
• Since False, returns 5 (value_if_false)
• Result: 5

How it works:
• Evaluates condition: 3 > 5 = False
• Since condition is False, returns else value
• Returns 5 (value_if_false)
• Result: 5

Examples:
• 3 if 3 > 5 else 5 = 5 (condition False)
• 5 if 5 > 3 else 3 = 5 (condition True)
• 'no' if False else 'yes' = 'yes'

Common uses:
• Concise conditional assignment: x = 3 if condition else 5
• Simple if-else in one line
• Conditional values
• Default values

Example: 3 if 3 > 5 else 5 returns 5 because the condition (3 > 5) is False, so it returns the value_if_false (5).
`
  }),
  (_i: number) => ({ 
    q: `What is 'yes' if True else 'no'?`, 
    o: ["'yes'", "'no'", "Error", "None"], 
    c: 0, 
    e: "Ternary with True condition returns first value.",
    de: `Python's ternary operator returns the value_if_true when the condition is True. 'yes' if True else 'no' evaluates the condition: True is True, so it returns 'yes' (the value_if_true). The ternary operator works with any values, including strings.

Ternary with True:
• 'yes' if True else 'no'
• Condition: True
• Since True, returns 'yes' (value_if_true)
• Result: 'yes'

How it works:
• Evaluates condition: True
• Since condition is True, returns value_if_true
• Returns 'yes'
• Result: 'yes'

Examples:
• 'yes' if True else 'no' = 'yes'
• 'yes' if False else 'no' = 'no'
• 'positive' if 5 > 0 else 'negative' = 'positive'

Common uses:
• Concise conditional assignment: status = 'yes' if condition else 'no'
• Simple if-else in one line
• Conditional string values
• Default values

Example: 'yes' if True else 'no' returns 'yes' because the condition (True) is True, so it returns the value_if_true ('yes').
`
  }),
  (_i: number) => ({ 
    q: `What is 'yes' if False else 'no'?`, 
    o: ["'no'", "'yes'", "Error", "None"], 
    c: 0, 
    e: "Ternary with False condition returns else value.",
    de: `Python's ternary operator returns the value_if_false when the condition is False. 'yes' if False else 'no' evaluates the condition: False is False, so it returns 'no' (the value_if_false). The ternary operator works with any values, including strings.

Ternary with False:
• 'yes' if False else 'no'
• Condition: False
• Since False, returns 'no' (value_if_false)
• Result: 'no'

How it works:
• Evaluates condition: False
• Since condition is False, returns value_if_false
• Returns 'no'
• Result: 'no'

Examples:
• 'yes' if False else 'no' = 'no'
• 'yes' if True else 'no' = 'yes'
• 'positive' if -5 > 0 else 'negative' = 'negative'

Common uses:
• Concise conditional assignment: status = 'yes' if condition else 'no'
• Simple if-else in one line
• Conditional string values
• Default values

Example: 'yes' if False else 'no' returns 'no' because the condition (False) is False, so it returns the value_if_false ('no').
`
  }),
  (_i: number) => ({ 
    q: `What is max(5, 3) if 5 > 3 else min(5, 3)?`, 
    o: ["5", "3", "Error", "None"], 
    c: 0, 
    e: "Ternary can use function calls.",
    de: `Python's ternary operator can use function calls in both the value_if_true and value_if_false parts. max(5, 3) if 5 > 3 else min(5, 3) evaluates the condition first: 5 > 3 is True, so it returns max(5, 3) which equals 5. Function calls are evaluated only for the selected branch.

Ternary with functions:
• max(5, 3) if 5 > 3 else min(5, 3)
• Condition: 5 > 3 = True
• Since True, evaluates max(5, 3) = 5
• Result: 5

How it works:
• Evaluates condition: 5 > 3 = True
• Since True, evaluates value_if_true: max(5, 3) = 5
• min(5, 3) is not evaluated (short-circuit)
• Result: 5

Examples:
• max(5, 3) if 5 > 3 else min(5, 3) = 5
• max(5, 3) if 3 > 5 else min(5, 3) = 3
• len([1, 2]) if True else len([]) = 2

Common uses:
• Conditional function calls
• Choosing between function results
• Conditional calculations
• Efficient conditional evaluation

Example: max(5, 3) if 5 > 3 else min(5, 3) returns 5 because the condition (5 > 3) is True, so it evaluates max(5, 3) which equals 5.
`
  }),
  (_i: number) => ({ 
    q: `What is 'even' if 4 % 2 == 0 else 'odd'?`, 
    o: ["'even'", "'odd'", "Error", "None"], 
    c: 0, 
    e: "Ternary with modulo check.",
    de: `Python's ternary operator can use any boolean expression as the condition. 'even' if 4 % 2 == 0 else 'odd' evaluates the condition: 4 % 2 == 0 (which is 0 == 0, True), so it returns 'even'. This is a common pattern for checking if a number is even or odd using the modulo operator.

Ternary with modulo:
• 'even' if 4 % 2 == 0 else 'odd'
• Condition: 4 % 2 == 0 → 0 == 0 → True
• Since True, returns 'even'
• Result: 'even'

How it works:
• Evaluates condition: 4 % 2 = 0, then 0 == 0 = True
• Since True, returns value_if_true: 'even'
• Result: 'even'

Examples:
• 'even' if 4 % 2 == 0 else 'odd' = 'even'
• 'even' if 5 % 2 == 0 else 'odd' = 'odd'
• 'even' if 0 % 2 == 0 else 'odd' = 'even'

Common uses:
• Checking even/odd: result = 'even' if n % 2 == 0 else 'odd'
• Conditional string values
• Simple if-else in one line
• Pattern matching

Example: 'even' if 4 % 2 == 0 else 'odd' returns 'even' because 4 % 2 equals 0, and 0 == 0 is True, so it returns 'even'.
`
  }),
  (_i: number) => ({ 
    q: `What is 'even' if 5 % 2 == 0 else 'odd'?`, 
    o: ["'odd'", "'even'", "Error", "None"], 
    c: 0, 
    e: "Ternary with modulo check - odd number.",
    de: `Python's ternary operator returns the else value when the condition is False. 'even' if 5 % 2 == 0 else 'odd' evaluates the condition: 5 % 2 == 0 (which is 1 == 0, False), so it returns 'odd'. This is a common pattern for checking if a number is even or odd using the modulo operator.

Ternary with modulo (odd):
• 'even' if 5 % 2 == 0 else 'odd'
• Condition: 5 % 2 == 0 → 1 == 0 → False
• Since False, returns 'odd'
• Result: 'odd'

How it works:
• Evaluates condition: 5 % 2 = 1, then 1 == 0 = False
• Since False, returns value_if_false: 'odd'
• Result: 'odd'

Examples:
• 'even' if 5 % 2 == 0 else 'odd' = 'odd'
• 'even' if 4 % 2 == 0 else 'odd' = 'even'
• 'even' if 3 % 2 == 0 else 'odd' = 'odd'

Common uses:
• Checking even/odd: result = 'even' if n % 2 == 0 else 'odd'
• Conditional string values
• Simple if-else in one line
• Pattern matching

Example: 'even' if 5 % 2 == 0 else 'odd' returns 'odd' because 5 % 2 equals 1, and 1 == 0 is False, so it returns 'odd'.
`
  }),
  (_i: number) => ({ 
    q: `What is 'positive' if 5 > 0 else 'non-positive'?`, 
    o: ["'positive'", "'non-positive'", "Error", "None"], 
    c: 0, 
    e: "Ternary with comparison.",
    de: `Python's ternary operator can use comparison operators in the condition. 'positive' if 5 > 0 else 'non-positive' evaluates the condition: 5 > 0 is True, so it returns 'positive'. This is a common pattern for categorizing values based on comparisons.

Ternary with comparison:
• 'positive' if 5 > 0 else 'non-positive'
• Condition: 5 > 0 = True
• Since True, returns 'positive'
• Result: 'positive'

How it works:
• Evaluates condition: 5 > 0 = True
• Since True, returns value_if_true: 'positive'
• Result: 'positive'

Examples:
• 'positive' if 5 > 0 else 'non-positive' = 'positive'
• 'positive' if -5 > 0 else 'non-positive' = 'non-positive'
• 'positive' if 0 > 0 else 'non-positive' = 'non-positive'

Common uses:
• Categorizing values: result = 'positive' if x > 0 else 'non-positive'
• Conditional string values
• Simple if-else in one line
• Classification

Example: 'positive' if 5 > 0 else 'non-positive' returns 'positive' because the condition (5 > 0) is True, so it returns 'positive'.
`
  }),
  (_i: number) => ({ 
    q: `What is 'positive' if -5 > 0 else 'non-positive'?`, 
    o: ["'non-positive'", "'positive'", "Error", "None"], 
    c: 0, 
    e: "Ternary with negative number.",
    de: `Python's ternary operator returns the else value when the condition is False. 'positive' if -5 > 0 else 'non-positive' evaluates the condition: -5 > 0 is False, so it returns 'non-positive'. This demonstrates how the ternary operator handles negative numbers in comparisons.

Ternary with negative:
• 'positive' if -5 > 0 else 'non-positive'
• Condition: -5 > 0 = False
• Since False, returns 'non-positive'
• Result: 'non-positive'

How it works:
• Evaluates condition: -5 > 0 = False
• Since False, returns value_if_false: 'non-positive'
• Result: 'non-positive'

Examples:
• 'positive' if -5 > 0 else 'non-positive' = 'non-positive'
• 'positive' if 5 > 0 else 'non-positive' = 'positive'
• 'positive' if 0 > 0 else 'non-positive' = 'non-positive'

Common uses:
• Categorizing values: result = 'positive' if x > 0 else 'non-positive'
• Conditional string values
• Simple if-else in one line
• Classification

Example: 'positive' if -5 > 0 else 'non-positive' returns 'non-positive' because the condition (-5 > 0) is False, so it returns 'non-positive'.
`
  }),
  (_i: number) => ({ 
    q: `What is 'empty' if len([]) == 0 else 'not empty'?`, 
    o: ["'empty'", "'not empty'", "Error", "None"], 
    c: 0, 
    e: "Ternary with len() check.",
    de: `Python's ternary operator can use function calls like len() in the condition. 'empty' if len([]) == 0 else 'not empty' evaluates the condition: len([]) == 0 (which is 0 == 0, True), so it returns 'empty'. This is a common pattern for checking if collections are empty.

Ternary with len():
• 'empty' if len([]) == 0 else 'not empty'
• Condition: len([]) == 0 → 0 == 0 → True
• Since True, returns 'empty'
• Result: 'empty'

How it works:
• Evaluates condition: len([]) = 0, then 0 == 0 = True
• Since True, returns value_if_true: 'empty'
• Result: 'empty'

Examples:
• 'empty' if len([]) == 0 else 'not empty' = 'empty'
• 'empty' if len([1, 2]) == 0 else 'not empty' = 'not empty'
• 'empty' if len("") == 0 else 'not empty' = 'empty'

Common uses:
• Checking if empty: result = 'empty' if len(collection) == 0 else 'not empty'
• Conditional string values
• Simple if-else in one line
• Collection validation

Example: 'empty' if len([]) == 0 else 'not empty' returns 'empty' because len([]) equals 0, and 0 == 0 is True, so it returns 'empty'.
`
  }),
  
  // 81-90: Short-Circuit Evaluation
  (_i: number) => ({ 
    q: `What is True and 5?`, 
    o: ["5", "True", "False", "Error"], 
    c: 0, 
    e: "and returns last value if all are Truthy.",
    de: `The and operator in Python uses short-circuit evaluation and returns the last value if all operands are truthy. True and 5 evaluates: True is truthy, so it continues to evaluate 5, which is also truthy, so it returns 5 (the last value). This behavior is useful for conditional assignment and default values.

and operator behavior:
• True and 5 = 5 (returns last value if all truthy)
• Evaluates left to right
• Returns first falsy value if found
• Returns last value if all truthy

How it works:
• Evaluates True: truthy, continues
• Evaluates 5: truthy, continues
• All are truthy, returns last value: 5
• Result: 5

Examples:
• True and 5 = 5 (all truthy, returns last)
• True and False = False (first falsy found)
• 1 and 2 and 3 = 3 (all truthy, returns last)

Common uses:
• Conditional assignment: x = value and default
• Chaining conditions
• Default values
• Short-circuit evaluation

Example: True and 5 returns 5 because both operands are truthy, so and returns the last value (5). This is useful for conditional logic.
`
  }),
  (_i: number) => ({ 
    q: `What is False and 5?`, 
    o: ["False", "5", "True", "Error"], 
    c: 0, 
    e: "and short-circuits at first Falsy value.",
    de: `The and operator uses short-circuit evaluation - it stops evaluating as soon as it encounters a falsy value. False and 5 evaluates: False is falsy, so it short-circuits and returns False immediately without evaluating 5. This is efficient and prevents unnecessary computation.

Short-circuit behavior:
• False and 5 = False (short-circuits at first falsy)
• Stops evaluation at first falsy value
• Doesn't evaluate remaining operands
• Returns the falsy value

How it works:
• Evaluates False: falsy, short-circuits
• Doesn't evaluate 5 (not needed)
• Returns False immediately
• Result: False

Examples:
• False and 5 = False (short-circuits)
• False and expensive_function() = False (function not called)
• 0 and 5 = 0 (short-circuits)

Common uses:
• Efficient validation: if x > 0 and expensive_check(x):
• Preventing expensive operations
• Guard clauses
• Conditional execution

Example: False and 5 returns False because and short-circuits at the first falsy value (False), so it doesn't evaluate 5 and returns False immediately.
`
  }),
  (_i: number) => ({ 
    q: `What is True or 5?`, 
    o: ["True", "5", "False", "Error"], 
    c: 0, 
    e: "or short-circuits at first Truthy value.",
    de: `The or operator uses short-circuit evaluation - it stops evaluating as soon as it encounters a truthy value. True or 5 evaluates: True is truthy, so it short-circuits and returns True immediately without evaluating 5. This is efficient and is commonly used for default values.

Short-circuit behavior:
• True or 5 = True (short-circuits at first truthy)
• Stops evaluation at first truthy value
• Doesn't evaluate remaining operands
• Returns the truthy value

How it works:
• Evaluates True: truthy, short-circuits
• Doesn't evaluate 5 (not needed)
• Returns True immediately
• Result: True

Examples:
• True or 5 = True (short-circuits)
• True or expensive_function() = True (function not called)
• 1 or 5 = 1 (short-circuits)

Common uses:
• Default values: value = x or default
• Efficient fallbacks
• Preventing expensive operations
• Conditional assignment

Example: True or 5 returns True because or short-circuits at the first truthy value (True), so it doesn't evaluate 5 and returns True immediately.
`
  }),
  (_i: number) => ({ 
    q: `What is False or 5?`, 
    o: ["5", "False", "True", "Error"], 
    c: 0, 
    e: "or returns last value if all are Falsy.",
    de: `The or operator in Python returns the last value if all operands are falsy. False or 5 evaluates: False is falsy, so it continues to evaluate 5, which is truthy, so it returns 5. If all operands were falsy, it would return the last falsy value. This behavior is useful for default values.

or operator behavior:
• False or 5 = 5 (returns first truthy value)
• Evaluates left to right
• Returns first truthy value if found
• Returns last value if all falsy

How it works:
• Evaluates False: falsy, continues
• Evaluates 5: truthy, returns 5
• Returns first truthy value found
• Result: 5

Examples:
• False or 5 = 5 (first truthy found)
• False or 0 = 0 (all falsy, returns last)
• None or "" or "default" = "default" (first truthy)

Common uses:
• Default values: value = x or default
• Fallback values
• Conditional assignment
• Providing defaults

Example: False or 5 returns 5 because False is falsy, so or continues and finds 5 (which is truthy), so it returns 5. This is commonly used for default values: value = user_input or "default".
`
  }),
  (_i: number) => ({ 
    q: `What is 0 and 5?`, 
    o: ["0", "5", "False", "Error"], 
    c: 0, 
    e: "0 is Falsy, so and returns 0 (short-circuits).",
    de: `The and operator short-circuits at falsy values. 0 and 5 evaluates: 0 is falsy, so it short-circuits and returns 0 immediately without evaluating 5. The number 0 is falsy in Python, so it causes short-circuiting in boolean expressions.

Short-circuit with 0:
• 0 and 5 = 0 (short-circuits at 0)
• 0 is falsy, so and returns 0
• Doesn't evaluate 5
• Returns the falsy value

How it works:
• Evaluates 0: falsy, short-circuits
• Doesn't evaluate 5 (not needed)
• Returns 0 immediately
• Result: 0

Examples:
• 0 and 5 = 0 (short-circuits)
• 0 and expensive_function() = 0 (function not called)
• 0 and "hello" = 0 (short-circuits)

Common uses:
• Efficient validation: if x and x > 0:
• Preventing division by zero: if divisor and value / divisor:
• Guard clauses
• Conditional execution

Example: 0 and 5 returns 0 because 0 is falsy, so and short-circuits and returns 0 immediately without evaluating 5.
`
  }),
  (_i: number) => ({ 
    q: `What is 1 and 5?`, 
    o: ["5", "1", "True", "Error"], 
    c: 0, 
    e: "1 is Truthy, so and returns last value 5.",
    de: `The and operator returns the last value if all operands are truthy. 1 and 5 evaluates: 1 is truthy, so it continues to evaluate 5, which is also truthy, so it returns 5 (the last value). Non-zero numbers are truthy in Python, so they don't cause short-circuiting in and expressions.

and with truthy numbers:
• 1 and 5 = 5 (returns last value if all truthy)
• 1 is truthy, continues
• 5 is truthy, returns 5
• Returns last value

How it works:
• Evaluates 1: truthy, continues
• Evaluates 5: truthy, continues
• All are truthy, returns last value: 5
• Result: 5

Examples:
• 1 and 5 = 5 (all truthy, returns last)
• 1 and 2 and 3 = 3 (all truthy, returns last)
• 1 and 0 = 0 (first falsy found)

Common uses:
• Conditional assignment
• Chaining conditions
• Default values
• Short-circuit evaluation

Example: 1 and 5 returns 5 because both operands are truthy (1 and 5), so and returns the last value (5).
`
  }),
  (_i: number) => ({ 
    q: `What is 0 or 5?`, 
    o: ["5", "0", "False", "Error"], 
    c: 0, 
    e: "0 is Falsy, so or continues and returns 5.",
    de: `The or operator continues evaluating until it finds a truthy value. 0 or 5 evaluates: 0 is falsy, so it continues to evaluate 5, which is truthy, so it returns 5. The or operator returns the first truthy value it encounters, or the last value if all are falsy.

or with falsy number:
• 0 or 5 = 5 (returns first truthy value)
• 0 is falsy, continues
• 5 is truthy, returns 5
• Returns first truthy found

How it works:
• Evaluates 0: falsy, continues
• Evaluates 5: truthy, returns 5
• Returns first truthy value found
• Result: 5

Examples:
• 0 or 5 = 5 (first truthy found)
• 0 or 0 or 5 = 5 (first truthy found)
• 0 or "" or "default" = "default" (first truthy)

Common uses:
• Default values: value = x or default
• Fallback values
• Conditional assignment
• Providing defaults

Example: 0 or 5 returns 5 because 0 is falsy, so or continues and finds 5 (which is truthy), so it returns 5. This is commonly used: value = user_input or 0 (provides default).
`
  }),
  (_i: number) => ({ 
    q: `What is 1 or 5?`, 
    o: ["1", "5", "True", "Error"], 
    c: 0, 
    e: "1 is Truthy, so or short-circuits and returns 1.",
    de: `The or operator short-circuits at truthy values. 1 or 5 evaluates: 1 is truthy, so it short-circuits and returns 1 immediately without evaluating 5. Non-zero numbers are truthy in Python, so they cause short-circuiting in or expressions.

Short-circuit with truthy number:
• 1 or 5 = 1 (short-circuits at 1)
• 1 is truthy, so or returns 1
• Doesn't evaluate 5
• Returns the truthy value

How it works:
• Evaluates 1: truthy, short-circuits
• Doesn't evaluate 5 (not needed)
• Returns 1 immediately
• Result: 1

Examples:
• 1 or 5 = 1 (short-circuits)
• 1 or expensive_function() = 1 (function not called)
• 1 or "hello" = 1 (short-circuits)

Common uses:
• Efficient fallbacks: value = x or y or default
• Preventing expensive operations
• Conditional assignment
• Short-circuit evaluation

Example: 1 or 5 returns 1 because 1 is truthy, so or short-circuits and returns 1 immediately without evaluating 5.
`
  }),
  (_i: number) => ({ 
    q: `What is '' and 'hello'?`, 
    o: ["''", "'hello'", "False", "Error"], 
    c: 0, 
    e: "Empty string is Falsy, so and returns ''.",
    de: `The and operator short-circuits at falsy values. '' and 'hello' evaluates: '' (empty string) is falsy, so it short-circuits and returns '' immediately without evaluating 'hello'. Empty strings are falsy in Python, so they cause short-circuiting in boolean expressions.

Short-circuit with empty string:
• '' and 'hello' = '' (short-circuits at '')
• Empty string is falsy, so and returns ''
• Doesn't evaluate 'hello'
• Returns the falsy value

How it works:
• Evaluates '': falsy, short-circuits
• Doesn't evaluate 'hello' (not needed)
• Returns '' immediately
• Result: ''

Examples:
• '' and 'hello' = '' (short-circuits)
• '' and expensive_function() = '' (function not called)
• '' and "world" = '' (short-circuits)

Common uses:
• Efficient validation: if string and string.strip():
• Preventing operations on empty strings
• Guard clauses
• Conditional execution

Example: '' and 'hello' returns '' because the empty string is falsy, so and short-circuits and returns '' immediately without evaluating 'hello'.
`
  }),
  (_i: number) => ({ 
    q: `What is 'hello' and 'world'?`, 
    o: ["'world'", "'hello'", "True", "Error"], 
    c: 0, 
    e: "Both are Truthy, so and returns last value 'world'.",
    de: `The and operator returns the last value if all operands are truthy. 'hello' and 'world' evaluates: 'hello' is truthy (non-empty string), so it continues to evaluate 'world', which is also truthy, so it returns 'world' (the last value). Non-empty strings are truthy in Python.

and with truthy strings:
• 'hello' and 'world' = 'world' (returns last value if all truthy)
• 'hello' is truthy, continues
• 'world' is truthy, returns 'world'
• Returns last value

How it works:
• Evaluates 'hello': truthy, continues
• Evaluates 'world': truthy, continues
• All are truthy, returns last value: 'world'
• Result: 'world'

Examples:
• 'hello' and 'world' = 'world' (all truthy, returns last)
• 'a' and 'b' and 'c' = 'c' (all truthy, returns last)
• 'hello' and '' = '' (first falsy found)

Common uses:
• Conditional assignment
• Chaining conditions
• Default values
• Short-circuit evaluation

Example: 'hello' and 'world' returns 'world' because both operands are truthy (non-empty strings), so and returns the last value ('world').
`
  }),
  
  // 91-100: Complex Boolean Expressions
  (_i: number) => ({ 
    q: `Result of 5 > 3 and 10 > 5?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Both conditions must be True.",
    de: `Complex boolean expressions combine multiple conditions with logical operators. 5 > 3 and 10 > 5 evaluates both conditions: 5 > 3 is True, and 10 > 5 is True. Since both are True, the and operator returns True. This is commonly used in conditional statements for multiple requirements.

Complex boolean expression:
• 5 > 3 and 10 > 5 = True
• First: 5 > 3 = True
• Second: 10 > 5 = True
• True and True = True

How it works:
• Evaluates left condition: 5 > 3 = True
• Evaluates right condition: 10 > 5 = True
• Combines with and: True and True = True
• Returns True if both are True

Examples:
• 5 > 3 and 10 > 5 = True (both True)
• 5 > 3 and 5 > 10 = False (second False)
• 5 > 10 and 10 > 5 = False (first False)

Common uses:
• Multiple conditions: if x > 0 and x < 100:
• Validation: if valid and available:
• Compound conditions
• Conditional statements

Example: 5 > 3 and 10 > 5 returns True because both conditions are True (5 > 3 is True, and 10 > 5 is True), so the and operator returns True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 > 10 and 10 > 5?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "First condition is False, so and returns False.",
    de: `The and operator short-circuits at the first False condition. 5 > 10 and 10 > 5 evaluates: 5 > 10 is False, so it short-circuits and returns False immediately without evaluating 10 > 5. The and operator requires both conditions to be True, so if the first is False, the result is False.

Complex boolean expression:
• 5 > 10 and 10 > 5 = False
• First: 5 > 10 = False
• Short-circuits: doesn't evaluate second
• False and anything = False

How it works:
• Evaluates left condition: 5 > 10 = False
• Short-circuits: returns False immediately
• Doesn't evaluate 10 > 5 (not needed)
• Result: False

Examples:
• 5 > 10 and 10 > 5 = False (first False)
• 5 > 10 and expensive_check() = False (function not called)
• False and True = False

Common uses:
• Efficient validation: if x > 0 and expensive_check(x):
• Guard clauses
• Preventing expensive operations
• Conditional statements

Example: 5 > 10 and 10 > 5 returns False because the first condition (5 > 10) is False, so and short-circuits and returns False immediately without evaluating the second condition.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 > 3 or 10 < 5?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "At least one condition is True.",
    de: `The or operator returns True if at least one condition is True. 5 > 3 or 10 < 5 evaluates: 5 > 3 is True, so it short-circuits and returns True immediately without evaluating 10 < 5. The or operator requires only one condition to be True for the result to be True.

Complex boolean expression:
• 5 > 3 or 10 < 5 = True
• First: 5 > 3 = True
• Short-circuits: returns True immediately
• Doesn't evaluate second (not needed)

How it works:
• Evaluates left condition: 5 > 3 = True
• Short-circuits: returns True immediately
• Doesn't evaluate 10 < 5 (not needed)
• Result: True

Examples:
• 5 > 3 or 10 < 5 = True (first True)
• 5 > 10 or 10 > 5 = True (second True)
• 5 > 10 or 10 < 5 = False (both False)

Common uses:
• Alternative conditions: if x == 5 or x == 10:
• Fallback checks
• Multiple possibilities
• Conditional statements

Example: 5 > 3 or 10 < 5 returns True because the first condition (5 > 3) is True, so or short-circuits and returns True immediately without evaluating the second condition.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 > 10 or 10 < 5?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "Both conditions are False, so or returns False.",
    de: `The or operator returns False only if all conditions are False. 5 > 10 or 10 < 5 evaluates: 5 > 10 is False, and 10 < 5 is False. Since both are False, the or operator returns False. The or operator requires at least one condition to be True for the result to be True.

Complex boolean expression:
• 5 > 10 or 10 < 5 = False
• First: 5 > 10 = False
• Second: 10 < 5 = False
• False or False = False

How it works:
• Evaluates left condition: 5 > 10 = False
• Evaluates right condition: 10 < 5 = False
• Combines with or: False or False = False
• Returns False if both are False

Examples:
• 5 > 10 or 10 < 5 = False (both False)
• 5 > 3 or 10 > 5 = True (at least one True)
• False or False = False

Common uses:
• Alternative conditions: if x == 5 or x == 10:
• Multiple possibilities
• Fallback checks
• Conditional statements

Example: 5 > 10 or 10 < 5 returns False because both conditions are False (5 > 10 is False, and 10 < 5 is False), so the or operator returns False.
`
  }),
  (_i: number) => ({ 
    q: `Result of not (5 > 10)?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "not inverts False to True.",
    de: `The not operator inverts the boolean result of an expression. not (5 > 10) evaluates the expression inside parentheses first: 5 > 10 is False, then not False equals True. The not operator is commonly used in conditional statements to negate conditions.

not with comparison:
• not (5 > 10) = True
• First: 5 > 10 = False
• Then: not False = True
• Result: True

How it works:
• Evaluates expression: 5 > 10 = False
• Applies not operator: not False = True
• Returns inverted result
• Result: True

Examples:
• not (5 > 10) = not False = True
• not (5 > 3) = not True = False
• not (10 == 5) = not False = True

Common uses:
• Negating conditions: if not (x > 10):
• Inverting boolean results
• Checking for "not greater than"
• Conditional statements

Example: not (5 > 10) returns True because first 5 > 10 evaluates to False, then not False equals True.
`
  }),
  (_i: number) => ({ 
    q: `Result of not (5 > 3)?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "not inverts True to False.",
    de: `The not operator inverts the boolean result of an expression. not (5 > 3) evaluates the expression inside parentheses first: 5 > 3 is True, then not True equals False. The not operator is commonly used in conditional statements to negate conditions.

not with comparison:
• not (5 > 3) = False
• First: 5 > 3 = True
• Then: not True = False
• Result: False

How it works:
• Evaluates expression: 5 > 3 = True
• Applies not operator: not True = False
• Returns inverted result
• Result: False

Examples:
• not (5 > 3) = not True = False
• not (5 > 10) = not False = True
• not (10 == 10) = not True = False

Common uses:
• Negating conditions: if not (x > 0):
• Inverting boolean results
• Checking for "not greater than"
• Conditional statements

Example: not (5 > 3) returns False because first 5 > 3 evaluates to True, then not True equals False.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 > 3 and not (10 < 5)?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Both conditions must be True: 5>3 is True, not(10<5) is True.",
    de: `Complex boolean expressions can combine comparisons, logical operators, and the not operator. 5 > 3 and not (10 < 5) evaluates: 5 > 3 is True, and not (10 < 5) is not False (which is True). Since both are True, the and operator returns True. Parentheses control the order of evaluation.

Complex expression:
• 5 > 3 and not (10 < 5) = True
• First: 5 > 3 = True
• Second: not (10 < 5) = not False = True
• True and True = True

How it works:
• Evaluates left: 5 > 3 = True
• Evaluates right: 10 < 5 = False, then not False = True
• Combines with and: True and True = True
• Result: True

Examples:
• 5 > 3 and not (10 < 5) = True (both True)
• 5 > 10 and not (10 < 5) = False (first False)
• 5 > 3 and not (5 > 3) = False (second False)

Common uses:
• Complex conditions: if x > 0 and not (x > 100):
• Multiple requirements
• Negated conditions
• Conditional statements

Example: 5 > 3 and not (10 < 5) returns True because both conditions are True (5 > 3 is True, and not (10 < 5) is True), so the and operator returns True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 in [1, 2, 3] or 10 > 5?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "At least one condition is True: 10>5 is True.",
    de: `Complex boolean expressions can combine membership operators, comparison operators, and logical operators. 5 in [1, 2, 3] or 10 > 5 evaluates: 5 in [1, 2, 3] is False, but 10 > 5 is True, so the or operator returns True. The or operator requires only one condition to be True.

Complex expression:
• 5 in [1, 2, 3] or 10 > 5 = True
• First: 5 in [1, 2, 3] = False
• Second: 10 > 5 = True
• False or True = True

How it works:
• Evaluates left: 5 in [1, 2, 3] = False
• Evaluates right: 10 > 5 = True
• Combines with or: False or True = True
• Result: True

Examples:
• 5 in [1, 2, 3] or 10 > 5 = True (second True)
• 1 in [1, 2, 3] or 10 > 5 = True (first True)
• 5 in [1, 2, 3] or 10 < 5 = False (both False)

Common uses:
• Alternative conditions: if item in list or value > threshold:
• Multiple possibilities
• Fallback checks
• Conditional statements

Example: 5 in [1, 2, 3] or 10 > 5 returns True because at least one condition is True (10 > 5 is True), so the or operator returns True.
`
  }),
  (_i: number) => ({ 
    q: `Result of 5 in [1, 2, 3] and 10 > 5?`, 
    o: ["False", "True", "None", "Error"], 
    c: 0, 
    e: "First condition is False, so and returns False.",
    de: `The and operator short-circuits at the first False condition. 5 in [1, 2, 3] and 10 > 5 evaluates: 5 in [1, 2, 3] is False, so it short-circuits and returns False immediately without evaluating 10 > 5. The and operator requires both conditions to be True, so if the first is False, the result is False.

Complex expression:
• 5 in [1, 2, 3] and 10 > 5 = False
• First: 5 in [1, 2, 3] = False
• Short-circuits: returns False immediately
• Doesn't evaluate second (not needed)

How it works:
• Evaluates left: 5 in [1, 2, 3] = False
• Short-circuits: returns False immediately
• Doesn't evaluate 10 > 5 (not needed)
• Result: False

Examples:
• 5 in [1, 2, 3] and 10 > 5 = False (first False)
• 1 in [1, 2, 3] and 10 > 5 = True (both True)
• 5 in [1, 2, 3] and 10 < 5 = False (first False)

Common uses:
• Multiple requirements: if item in list and value > threshold:
• Validation checks
• Compound conditions
• Conditional statements

Example: 5 in [1, 2, 3] and 10 > 5 returns False because the first condition (5 in [1, 2, 3]) is False, so and short-circuits and returns False immediately without evaluating the second condition.
`
  }),
  (_i: number) => ({ 
    q: `Result of (5 > 3) == (10 > 5)?`, 
    o: ["True", "False", "None", "Error"], 
    c: 0, 
    e: "Both comparisons are True, so True == True is True.",
    de: `You can compare the boolean results of expressions using the == operator. (5 > 3) == (10 > 5) evaluates both comparisons first: 5 > 3 is True, and 10 > 5 is True, then True == True equals True. This is useful for checking if multiple conditions have the same boolean result.

Boolean comparison:
• (5 > 3) == (10 > 5) = True
• First: 5 > 3 = True
• Second: 10 > 5 = True
• True == True = True

How it works:
• Evaluates left: 5 > 3 = True
• Evaluates right: 10 > 5 = True
• Compares results: True == True = True
• Result: True

Examples:
• (5 > 3) == (10 > 5) = True (both True)
• (5 > 10) == (10 > 5) = False (different)
• (5 > 3) == (3 > 5) = False (different)

Common uses:
• Checking if conditions have same result
• Comparing boolean expressions
• Validation
• Conditional statements

Example: (5 > 3) == (10 > 5) returns True because both comparisons are True (5 > 3 is True, and 10 > 5 is True), so True == True equals True.
`
  }),
];

// --- LEVEL 4: SMALL FISH (Loops & Iterables) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level4Patterns = [
  // 1-10: Range Basics
  (_i: number) => ({ 
    q: `How many times does range(5) loop?`, 
    o: ["5", "4", "1", "0"], 
    c: 0, 
    e: "range(n) iterates from 0 to n-1 (5 times).",
    de: `The range(n) function creates a sequence of numbers from 0 to n-1 (exclusive of n). range(5) generates the numbers 0, 1, 2, 3, 4, which means a loop using range(5) will iterate 5 times. Understanding range() is fundamental for Python loops.

range(n) behavior:
• range(5) generates: 0, 1, 2, 3, 4
• Starts at 0 (default start)
• Stops before n (exclusive)
• Total iterations: n times

How it works:
• range(5) = 0, 1, 2, 3, 4 (5 numbers)
• for i in range(5): loops 5 times
• i takes values: 0, 1, 2, 3, 4
• Common pattern for fixed iterations

Examples:
• range(5) = 0, 1, 2, 3, 4 (5 iterations)
• range(3) = 0, 1, 2 (3 iterations)
• range(10) = 0, 1, 2, ..., 9 (10 iterations)

Common uses:
• Fixed iterations: for i in range(5):
• Index-based loops
• Repeating operations
• Generating sequences

Example: range(5) loops 5 times because it generates the numbers 0, 1, 2, 3, 4 (5 values total). This is the most common use of range() in for loops.
`
  }),
  (_i: number) => ({ 
    q: `What is list(range(5))?`, 
    o: ["[0, 1, 2, 3, 4]", "[1, 2, 3, 4, 5]", "[0, 1, 2, 3, 4, 5]", "Error"], 
    c: 0, 
    e: "range(n) goes from 0 to n-1.",
    de: `The range(n) function generates numbers from 0 to n-1 (exclusive of n). Converting it to a list with list(range(5)) creates [0, 1, 2, 3, 4]. The range object itself is an iterable, and list() converts it to a list for inspection or manipulation.

range(n) to list:
• list(range(5)) = [0, 1, 2, 3, 4]
• range(5) generates: 0, 1, 2, 3, 4
• Starts at 0, stops before 5
• Total: 5 elements

How it works:
• range(5) creates iterable: 0, 1, 2, 3, 4
• list() converts iterable to list
• Result: [0, 1, 2, 3, 4]
• Note: 5 is NOT included (exclusive)

Examples:
• list(range(5)) = [0, 1, 2, 3, 4]
• list(range(3)) = [0, 1, 2]
• list(range(1)) = [0]

Common uses:
• Converting range to list: numbers = list(range(5))
• Inspecting range contents
• Creating number sequences
• List generation

Example: list(range(5)) returns [0, 1, 2, 3, 4] because range(5) generates numbers from 0 to 4 (5 numbers total, exclusive of 5).
`
  }),
  (_i: number) => ({ 
    q: `What is list(range(1, 4))?`, 
    o: ["[1, 2, 3]", "[1, 2, 3, 4]", "[0, 1, 2, 3]", "[1, 4]"], 
    c: 0, 
    e: "range(start, stop) excludes stop value.",
    de: `The range(start, stop) function generates numbers from start to stop-1 (exclusive of stop). list(range(1, 4)) creates [1, 2, 3] because it starts at 1 and stops before 4. The stop value is always exclusive in range().

range(start, stop):
• list(range(1, 4)) = [1, 2, 3]
• Starts at 1 (inclusive)
• Stops before 4 (exclusive)
• Generates: 1, 2, 3

How it works:
• range(1, 4) creates iterable: 1, 2, 3
• Starts at start value (1)
• Stops before stop value (4)
• list() converts to [1, 2, 3]

Examples:
• list(range(1, 4)) = [1, 2, 3]
• list(range(2, 5)) = [2, 3, 4]
• list(range(0, 3)) = [0, 1, 2]

Important note:
• Stop value is exclusive (not included)
• range(1, 4) does NOT include 4
• This is consistent with Python's half-open interval convention

Common uses:
• Custom ranges: for i in range(1, 10):
• Starting from non-zero: range(5, 10)
• Creating specific sequences
• Loop iterations

Example: list(range(1, 4)) returns [1, 2, 3] because range(1, 4) starts at 1 and stops before 4 (exclusive), generating 1, 2, 3.
`
  }),
  (_i: number) => ({ 
    q: `What is list(range(0, 10, 2))?`, 
    o: ["[0, 2, 4, 6, 8]", "[0, 2, 4, 6, 8, 10]", "[2, 4, 6, 8]", "Error"], 
    c: 0, 
    e: "range with step 2: 0, 2, 4, 6, 8.",
    de: `The range(start, stop, step) function generates numbers with a specified step size. list(range(0, 10, 2)) creates [0, 2, 4, 6, 8] because it starts at 0, increments by 2, and stops before 10. The step parameter controls the increment between values.

range with step:
• list(range(0, 10, 2)) = [0, 2, 4, 6, 8]
• Starts at 0
• Step size: 2 (increments by 2)
• Stops before 10 (exclusive)
• Generates: 0, 2, 4, 6, 8

How it works:
• range(0, 10, 2) creates iterable
• Starts at 0, adds 2 each time
• 0, 2, 4, 6, 8 (stops before 10)
• list() converts to [0, 2, 4, 6, 8]

Examples:
• list(range(0, 10, 2)) = [0, 2, 4, 6, 8]
• list(range(0, 10, 3)) = [0, 3, 6, 9]
• list(range(1, 10, 2)) = [1, 3, 5, 7, 9] (odd numbers)

Common uses:
• Even numbers: range(0, 10, 2)
• Odd numbers: range(1, 10, 2)
• Custom increments
• Skipping values

Example: list(range(0, 10, 2)) returns [0, 2, 4, 6, 8] because it starts at 0, increments by 2, and stops before 10, generating even numbers.
`
  }),
  (_i: number) => ({ 
    q: `What is list(range(1, 6, 2))?`, 
    o: ["[1, 3, 5]", "[1, 2, 3, 4, 5]", "[1, 3]", "Error"], 
    c: 0, 
    e: "range with step 2: 1, 3, 5.",
    de: `The range(start, stop, step) function with step=2 generates numbers starting from start, incrementing by 2, and stopping before stop. list(range(1, 6, 2)) creates [1, 3, 5] because it starts at 1, increments by 2, and stops before 6. This is useful for generating odd numbers.

range with step:
• list(range(1, 6, 2)) = [1, 3, 5]
• Starts at 1
• Step size: 2 (increments by 2)
• Stops before 6 (exclusive)
• Generates: 1, 3, 5

How it works:
• range(1, 6, 2) creates iterable
• Starts at 1, adds 2 each time
• 1, 3, 5 (stops before 6)
• list() converts to [1, 3, 5]

Examples:
• list(range(1, 6, 2)) = [1, 3, 5] (odd numbers)
• list(range(1, 10, 2)) = [1, 3, 5, 7, 9]
• list(range(2, 10, 2)) = [2, 4, 6, 8] (even numbers)

Common uses:
• Odd numbers: range(1, n, 2)
• Even numbers: range(0, n, 2) or range(2, n, 2)
• Custom increments
• Skipping values

Example: list(range(1, 6, 2)) returns [1, 3, 5] because it starts at 1, increments by 2, and stops before 6, generating odd numbers.
`
  }),
  (_i: number) => ({ 
    q: `What is list(range(5, 1, -1))?`, 
    o: ["[5, 4, 3, 2]", "[5, 4, 3, 2, 1]", "[4, 3, 2, 1]", "Error"], 
    c: 0, 
    e: "Negative step creates reverse range.",
    de: `The range() function with a negative step creates a reverse sequence. list(range(5, 1, -1)) creates [5, 4, 3, 2] because it starts at 5, decrements by 1 (step=-1), and stops before 1. Negative steps allow counting backwards, which is useful for reverse iteration.

range with negative step:
• list(range(5, 1, -1)) = [5, 4, 3, 2]
• Starts at 5
• Step size: -1 (decrements by 1)
• Stops before 1 (exclusive)
• Generates: 5, 4, 3, 2

How it works:
• range(5, 1, -1) creates iterable
• Starts at 5, subtracts 1 each time
• 5, 4, 3, 2 (stops before 1)
• list() converts to [5, 4, 3, 2]

Examples:
• list(range(5, 1, -1)) = [5, 4, 3, 2]
• list(range(10, 0, -2)) = [10, 8, 6, 4, 2]
• list(range(5, 0, -1)) = [5, 4, 3, 2, 1]

Common uses:
• Reverse iteration: for i in range(5, 0, -1):
• Counting backwards
• Reverse sequences
• Decrementing loops

Example: list(range(5, 1, -1)) returns [5, 4, 3, 2] because it starts at 5, decrements by 1 (negative step), and stops before 1, creating a reverse sequence.
`
  }),
  (_i: number) => ({ 
    q: `What is list(range(0))?`, 
    o: ["[]", "[0]", "Error", "None"], 
    c: 0, 
    e: "range(0) is empty.",
    de: `The range(0) function creates an empty range because it starts at 0 and stops before 0 (exclusive), which means no values are generated. list(range(0)) returns an empty list []. This is useful for edge cases and conditional loops.

Empty range:
• list(range(0)) = [] (empty list)
• range(0) generates no values
• Starts at 0, stops before 0 (impossible)
• Result: empty sequence

How it works:
• range(0) creates iterable
• Starts at 0, stops before 0
• No values can be generated
• list() converts to []

Examples:
• list(range(0)) = [] (empty)
• list(range(1)) = [0] (one value)
• for i in range(0): ... (loop never executes)

Common uses:
• Edge case handling
• Conditional loops: if n > 0: for i in range(n):
• Empty iterations
• Default empty sequences

Example: list(range(0)) returns [] because range(0) starts at 0 and stops before 0, which means no values are generated, resulting in an empty list.
`
  }),
  (_i: number) => ({ 
    q: `What is list(range(1, 1))?`, 
    o: ["[]", "[1]", "[0]", "Error"], 
    c: 0, 
    e: "When start equals stop, range is empty.",
    de: `When the start value equals the stop value in range(start, stop), the range is empty because it starts at start and stops before stop (exclusive). Since start equals stop, no values can be generated. list(range(1, 1)) returns an empty list [].

Empty range (start == stop):
• list(range(1, 1)) = [] (empty list)
• Starts at 1, stops before 1 (exclusive)
• No values generated
• Result: empty sequence

How it works:
• range(1, 1) creates iterable
• Starts at 1, stops before 1
• Since start == stop, no values possible
• list() converts to []

Examples:
• list(range(1, 1)) = [] (empty)
• list(range(5, 5)) = [] (empty)
• list(range(1, 2)) = [1] (one value)

Common uses:
• Edge case handling
• Conditional loops
• Empty iterations
• Default empty sequences

Example: list(range(1, 1)) returns [] because when start equals stop, range() generates no values (stop is exclusive), resulting in an empty list.
`
  }),
  (_i: number) => ({ 
    q: `What is range(5)[0]?`, 
    o: ["0", "1", "5", "Error"], 
    c: 0, 
    e: "range objects support indexing.",
    de: `Range objects support indexing, allowing you to access specific elements by index. range(5)[0] returns 0 because range(5) generates [0, 1, 2, 3, 4], and index 0 is the first element (0). Range objects behave like sequences and support indexing operations.

Range indexing:
• range(5)[0] = 0 (first element)
• range(5) generates: 0, 1, 2, 3, 4
• Index 0 = first element = 0
• Range objects support indexing

How it works:
• range(5) creates sequence: 0, 1, 2, 3, 4
• Index 0 accesses first element
• Returns 0
• Works like list indexing

Examples:
• range(5)[0] = 0 (first)
• range(5)[1] = 1 (second)
• range(5)[4] = 4 (last)
• range(5)[5] = IndexError (out of range)

Common uses:
• Accessing specific range values
• Random access to range elements
• Index-based operations
• Sequence-like behavior

Example: range(5)[0] returns 0 because range(5) generates the sequence [0, 1, 2, 3, 4], and index 0 is the first element (0).
`
  }),
  (_i: number) => ({ 
    q: `What is range(5)[-1]?`, 
    o: ["4", "5", "0", "Error"], 
    c: 0, 
    e: "Negative indexing works with range.",
    de: `Range objects support negative indexing, allowing you to access elements from the end. range(5)[-1] returns 4 because range(5) generates [0, 1, 2, 3, 4], and index -1 is the last element (4). Negative indexing counts backwards from the end.

Range negative indexing:
• range(5)[-1] = 4 (last element)
• range(5) generates: 0, 1, 2, 3, 4
• Index -1 = last element = 4
• Negative indexing works with range

How it works:
• range(5) creates sequence: 0, 1, 2, 3, 4
• Index -1 accesses last element
• Returns 4
• Works like list negative indexing

Examples:
• range(5)[-1] = 4 (last)
• range(5)[-2] = 3 (second from end)
• range(5)[-5] = 0 (first)
• range(5)[-6] = IndexError (out of range)

Common uses:
• Accessing last element: range(n)[-1]
• Reverse access
• End-based operations
• Sequence-like behavior

Example: range(5)[-1] returns 4 because range(5) generates the sequence [0, 1, 2, 3, 4], and index -1 is the last element (4).
`
  }),
  
  // 11-20: Range Operations
  (_i: number) => ({ 
    q: `What is len(range(5))?`, 
    o: ["5", "4", "6", "Error"], 
    c: 0, 
    e: "len() works with range objects.",
    de: `The len() function works with range objects and returns the number of elements in the range. len(range(5)) returns 5 because range(5) generates 5 values (0, 1, 2, 3, 4). Range objects support len() just like lists and other sequences.

len() with range:
• len(range(5)) = 5
• range(5) generates: 0, 1, 2, 3, 4
• Total elements: 5
• len() returns count of elements

How it works:
• range(5) creates sequence of 5 elements
• len() counts the elements
• Returns 5
• Works with any range

Examples:
• len(range(5)) = 5
• len(range(1, 5)) = 4
• len(range(0)) = 0 (empty)

Common uses:
• Getting range length: n = len(range(5))
• Counting iterations
• Sequence length
• Loop planning

Example: len(range(5)) returns 5 because range(5) generates 5 values (0, 1, 2, 3, 4), so len() returns 5.
`
  }),
  (_i: number) => ({ 
    q: `What is sum(range(5))?`, 
    o: ["10", "5", "0", "Error"], 
    c: 0, 
    e: "sum() works with range: 0+1+2+3+4 = 10.",
    de: `The sum() function works with range objects and adds all elements together. sum(range(5)) returns 10 because range(5) generates [0, 1, 2, 3, 4], and 0 + 1 + 2 + 3 + 4 = 10. Range objects are iterables, so sum() can iterate over them.

sum() with range:
• sum(range(5)) = 10
• range(5) generates: 0, 1, 2, 3, 4
• Sum: 0 + 1 + 2 + 3 + 4 = 10
• sum() adds all elements

How it works:
• range(5) creates iterable: 0, 1, 2, 3, 4
• sum() iterates and adds all values
• 0 + 1 + 2 + 3 + 4 = 10
• Returns total sum

Examples:
• sum(range(5)) = 10 (0+1+2+3+4)
• sum(range(1, 5)) = 10 (1+2+3+4)
• sum(range(0)) = 0 (empty range)

Common uses:
• Summing sequences: total = sum(range(n))
• Calculating totals
• Arithmetic progressions
• Number series

Example: sum(range(5)) returns 10 because range(5) generates [0, 1, 2, 3, 4], and sum() adds them: 0 + 1 + 2 + 3 + 4 = 10.
`
  }),
  (_i: number) => ({ 
    q: `What is min(range(5))?`, 
    o: ["0", "1", "4", "Error"], 
    c: 0, 
    e: "min() works with range objects.",
    de: `The min() function works with range objects and returns the smallest value. min(range(5)) returns 0 because range(5) generates [0, 1, 2, 3, 4], and 0 is the minimum value. Range objects are iterables, so min() can find the minimum.

min() with range:
• min(range(5)) = 0
• range(5) generates: 0, 1, 2, 3, 4
• Minimum value: 0
• min() finds smallest element

How it works:
• range(5) creates iterable: 0, 1, 2, 3, 4
• min() iterates and finds minimum
• 0 is the smallest value
• Returns 0

Examples:
• min(range(5)) = 0 (minimum)
• min(range(1, 5)) = 1 (minimum)
• min(range(5, 0, -1)) = 1 (minimum of reverse)

Common uses:
• Finding minimum: smallest = min(range(n))
• Range analysis
• Sequence operations
• Value finding

Example: min(range(5)) returns 0 because range(5) generates [0, 1, 2, 3, 4], and 0 is the smallest value in that sequence.
`
  }),
  (_i: number) => ({ 
    q: `What is max(range(5))?`, 
    o: ["4", "5", "0", "Error"], 
    c: 0, 
    e: "max() works with range objects.",
    de: `The max() function works with range objects and returns the largest value. max(range(5)) returns 4 because range(5) generates [0, 1, 2, 3, 4], and 4 is the maximum value. Range objects are iterables, so max() can find the maximum.

max() with range:
• max(range(5)) = 4
• range(5) generates: 0, 1, 2, 3, 4
• Maximum value: 4
• max() finds largest element

How it works:
• range(5) creates iterable: 0, 1, 2, 3, 4
• max() iterates and finds maximum
• 4 is the largest value
• Returns 4

Examples:
• max(range(5)) = 4 (maximum)
• max(range(1, 5)) = 4 (maximum)
• max(range(5, 0, -1)) = 5 (maximum of reverse)

Common uses:
• Finding maximum: largest = max(range(n))
• Range analysis
• Sequence operations
• Value finding

Example: max(range(5)) returns 4 because range(5) generates [0, 1, 2, 3, 4], and 4 is the largest value in that sequence.
`
  }),
  (_i: number) => ({ 
    q: `What is 3 in range(5)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in operator works with range.",
    de: `The in operator works with range objects to check membership. 3 in range(5) returns True because range(5) generates [0, 1, 2, 3, 4], and 3 is present in that sequence. Range objects support membership testing efficiently.

Membership with range:
• 3 in range(5) = True
• range(5) generates: 0, 1, 2, 3, 4
• 3 is in the sequence
• in operator checks membership

How it works:
• range(5) creates sequence: 0, 1, 2, 3, 4
• in operator checks if 3 is in sequence
• 3 is found, returns True
• Efficient membership testing

Examples:
• 3 in range(5) = True (found)
• 5 in range(5) = False (not found, exclusive)
• 0 in range(5) = True (found)

Common uses:
• Membership checking: if value in range(n):
• Validation
• Range testing
• Conditional logic

Example: 3 in range(5) returns True because range(5) generates [0, 1, 2, 3, 4], and 3 is present in that sequence.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 in range(5)?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in operator - value not in range.",
    de: `The in operator checks if a value is in a range. 10 in range(5) returns False because range(5) generates [0, 1, 2, 3, 4], and 10 is not present in that sequence. The value 10 is outside the range, so membership check returns False.

Membership check:
• 10 in range(5) = False
• range(5) generates: 0, 1, 2, 3, 4
• 10 is not in the sequence
• in operator returns False

How it works:
• range(5) creates sequence: 0, 1, 2, 3, 4
• in operator checks if 10 is in sequence
• 10 is not found, returns False
• Value is outside range

Examples:
• 10 in range(5) = False (not found)
• 5 in range(5) = False (exclusive, not included)
• 0 in range(5) = True (found)

Common uses:
• Membership checking: if value not in range(n):
• Validation
• Range testing
• Conditional logic

Example: 10 in range(5) returns False because range(5) generates [0, 1, 2, 3, 4], and 10 is not present in that sequence (it's outside the range).
`
  }),
  (_i: number) => ({ 
    q: `What is 3 not in range(5)?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "not in operator - value is in range.",
    de: `The not in operator is the opposite of in - it returns True if the value is NOT in the range. 3 not in range(5) returns False because range(5) generates [0, 1, 2, 3, 4], and 3 IS present, so not in returns False. The not in operator inverts the membership check.

not in with range:
• 3 not in range(5) = False
• range(5) generates: 0, 1, 2, 3, 4
• 3 is in the sequence
• not in returns False (value is present)

How it works:
• range(5) creates sequence: 0, 1, 2, 3, 4
• not in checks if 3 is NOT in sequence
• 3 is found, so not in returns False
• Inverts membership check

Examples:
• 3 not in range(5) = False (3 is in range)
• 10 not in range(5) = True (10 is not in range)
• 0 not in range(5) = False (0 is in range)

Common uses:
• Negative membership checking: if value not in range(n):
• Validation
• Range testing
• Conditional logic

Example: 3 not in range(5) returns False because 3 is present in range(5) (which generates [0, 1, 2, 3, 4]), so not in returns False.
`
  }),
  (_i: number) => ({ 
    q: `What is 10 not in range(5)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "not in operator - value not in range.",
    de: `The not in operator returns True if the value is NOT in the range. 10 not in range(5) returns True because range(5) generates [0, 1, 2, 3, 4], and 10 is NOT present, so not in returns True. The not in operator is useful for negative membership checks.

not in with range:
• 10 not in range(5) = True
• range(5) generates: 0, 1, 2, 3, 4
• 10 is not in the sequence
• not in returns True (value is absent)

How it works:
• range(5) creates sequence: 0, 1, 2, 3, 4
• not in checks if 10 is NOT in sequence
• 10 is not found, so not in returns True
• Inverts membership check

Examples:
• 10 not in range(5) = True (10 is not in range)
• 3 not in range(5) = False (3 is in range)
• 5 not in range(5) = True (5 is exclusive, not included)

Common uses:
• Negative membership checking: if value not in range(n):
• Validation
• Range testing
• Conditional logic

Example: 10 not in range(5) returns True because 10 is not present in range(5) (which generates [0, 1, 2, 3, 4]), so not in returns True.
`
  }),
  (_i: number) => ({ 
    q: `What is list(reversed(range(5)))?`, 
    o: ["[4, 3, 2, 1, 0]", "[0, 1, 2, 3, 4]", "[5, 4, 3, 2, 1]", "Error"], 
    c: 0, 
    e: "reversed() reverses the range.",
    de: `The reversed() function reverses any iterable, including range objects. list(reversed(range(5))) creates [4, 3, 2, 1, 0] because range(5) generates [0, 1, 2, 3, 4], and reversed() reverses it. This is useful for reverse iteration without using negative steps.

reversed() with range:
• list(reversed(range(5))) = [4, 3, 2, 1, 0]
• range(5) generates: 0, 1, 2, 3, 4
• reversed() reverses the sequence
• Result: [4, 3, 2, 1, 0]

How it works:
• range(5) creates sequence: 0, 1, 2, 3, 4
• reversed() creates reverse iterator
• Iterates backwards: 4, 3, 2, 1, 0
• list() converts to [4, 3, 2, 1, 0]

Examples:
• list(reversed(range(5))) = [4, 3, 2, 1, 0]
• list(reversed(range(1, 5))) = [4, 3, 2, 1]
• for i in reversed(range(5)): ... (reverse iteration)

Common uses:
• Reverse iteration: for i in reversed(range(n)):
• Creating reverse sequences
• Backwards loops
• Reverse order processing

Example: list(reversed(range(5))) returns [4, 3, 2, 1, 0] because reversed() reverses the sequence generated by range(5) ([0, 1, 2, 3, 4]), creating [4, 3, 2, 1, 0].
`
  }),
  (_i: number) => ({ 
    q: `What is sorted(range(5, 0, -1))?`, 
    o: ["[1, 2, 3, 4, 5]", "[5, 4, 3, 2, 1]", "[0, 1, 2, 3, 4]", "Error"], 
    c: 0, 
    e: "sorted() works with range objects.",
    de: `The sorted() function works with range objects and returns a sorted list. sorted(range(5, 0, -1)) creates [1, 2, 3, 4, 5] because range(5, 0, -1) generates [5, 4, 3, 2, 1] (reverse), and sorted() sorts it in ascending order. This is useful for sorting any iterable, including ranges.

sorted() with range:
• sorted(range(5, 0, -1)) = [1, 2, 3, 4, 5]
• range(5, 0, -1) generates: 5, 4, 3, 2, 1
• sorted() sorts in ascending order
• Result: [1, 2, 3, 4, 5]

How it works:
• range(5, 0, -1) creates sequence: 5, 4, 3, 2, 1
• sorted() sorts the sequence
• Ascending order: 1, 2, 3, 4, 5
• Returns sorted list

Examples:
• sorted(range(5, 0, -1)) = [1, 2, 3, 4, 5]
• sorted(range(5)) = [0, 1, 2, 3, 4] (already sorted)
• sorted(range(1, 6, 2)) = [1, 3, 5] (already sorted)

Common uses:
• Sorting ranges: numbers = sorted(range(5, 0, -1))
• Creating sorted sequences
• Ordering values
• Sequence manipulation

Example: sorted(range(5, 0, -1)) returns [1, 2, 3, 4, 5] because range(5, 0, -1) generates [5, 4, 3, 2, 1], and sorted() sorts it in ascending order to [1, 2, 3, 4, 5].
`
  }),
  
  // 21-30: Loop Keywords
  (_i: number) => ({ 
    q: `Which keyword skips the rest of a loop cycle?`, 
    o: ["continue", "break", "pass", "skip"], 
    c: 0, 
    e: "continue jumps to the next iteration.",
    de: `The continue keyword skips the rest of the current loop iteration and jumps to the next iteration. When continue is encountered, the remaining code in the loop body is skipped, and the loop continues with the next iteration. This is useful for skipping certain iterations based on conditions.

continue keyword:
• Skips rest of current iteration
• Jumps to next iteration
• Loop continues normally
• Useful for conditional skipping

How it works:
• When continue is executed, remaining code skipped
• Loop moves to next iteration
• Loop doesn't terminate (unlike break)
• Useful in conditional blocks

Example:
for i in range(5):
    if i == 2:
        continue  # Skip rest, go to next
    print(i)  # Prints 0, 1, 3, 4 (skips 2)

Common uses:
• Skipping invalid values: if not valid: continue
• Filtering iterations
• Conditional processing
• Error handling in loops

Example: The continue keyword skips the rest of the current loop cycle and jumps to the next iteration. It's used to skip certain iterations while keeping the loop running.
`
  }),
  (_i: number) => ({ 
    q: `Which keyword terminates a loop?`, 
    o: ["break", "stop", "end", "exit"], 
    c: 0, 
    e: "break exits the loop entirely.",
    de: `The break keyword terminates a loop immediately, exiting the loop entirely. When break is encountered, the loop stops executing and control moves to the statement after the loop. This is useful for exiting loops early when a condition is met.

break keyword:
• Terminates loop immediately
• Exits loop entirely
• Control moves to after loop
• Useful for early exit

How it works:
• When break is executed, loop terminates
• Remaining iterations are skipped
• Control moves to code after loop
• Loop doesn't continue

Example:
for i in range(5):
    if i == 3:
        break  # Exit loop
    print(i)  # Prints 0, 1, 2 (stops at 3)

Common uses:
• Early exit: if found: break
• Condition-based termination
• Search operations
• Error handling

Example: The break keyword terminates a loop entirely, exiting immediately when encountered. It's used to exit loops early when a condition is met.
`
  }),
  (_i: number) => ({ 
    q: `What does 'pass' do?`, 
    o: ["Nothing", "Exits loop", "Skips cycle", "Restarts loop"], 
    c: 0, 
    e: "pass is a null operation placeholder.",
    de: `The pass keyword is a null operation - it does nothing. It's used as a placeholder where syntactically some code is required but no action is needed. pass is useful for empty function bodies, empty loops, or incomplete code that needs to be valid Python syntax.

pass keyword:
• Does nothing (null operation)
• Placeholder for empty code
• Required for syntax validity
• No effect on execution

How it works:
• pass is executed but does nothing
• Code continues normally after pass
• Used where code is syntactically required
• No effect on loop or program flow

Example:
for i in range(5):
    pass  # Does nothing, loop runs 5 times
# Loop completes normally

Common uses:
• Empty loops: for i in range(5): pass
• Placeholder code
• Incomplete implementations
• Syntax requirements

Example: The pass keyword does nothing - it's a null operation placeholder. It's used where code is syntactically required but no action is needed.
`
  }),
  (_i: number) => ({ 
    q: `What is 'while True:'?`, 
    o: ["An infinite loop", "A syntax error", "A loop that runs once", "None"], 
    c: 0, 
    e: "Always True means it never stops on its own.",
    de: `A while True: loop is an infinite loop because the condition is always True, so the loop never stops on its own. The loop will run indefinitely unless a break statement is used to exit it. This pattern is common for event loops, user input, or continuous processing.

while True loop:
• Infinite loop (condition always True)
• Never stops on its own
• Requires break to exit
• Common pattern for continuous processing

How it works:
• Condition True is always True
• Loop body executes repeatedly
• Continues forever unless break
• Must have exit condition inside

Example:
while True:
    user_input = input("Enter command: ")
    if user_input == "quit":
        break  # Exit loop
    # Process input

Common uses:
• Event loops: while True: process_events()
• User input: while True: get_input()
• Continuous processing
• Server loops

Example: while True: is an infinite loop because the condition is always True, so it never stops on its own. It requires a break statement to exit.
`
  }),
  (_i: number) => ({ 
    q: `What is 'for i in range(5): pass'?`, 
    o: ["Loop that does nothing", "Syntax error", "Infinite loop", "Error"], 
    c: 0, 
    e: "pass is a placeholder that does nothing.",
    de: `A for loop with pass is a loop that does nothing - it iterates through the range but performs no action. for i in range(5): pass will loop 5 times (i takes values 0, 1, 2, 3, 4), but pass does nothing, so no code executes in the loop body. This is useful for placeholder code or empty loops.

for loop with pass:
• Loops 5 times (range(5))
• pass does nothing
• No action performed
• Valid Python syntax

How it works:
• for i in range(5): iterates 5 times
• i takes values: 0, 1, 2, 3, 4
• pass executes but does nothing
• Loop completes normally

Example:
for i in range(5):
    pass  # Loop runs 5 times, does nothing
# Loop completes, i = 4

Common uses:
• Placeholder loops
• Empty loop bodies
• Incomplete code
• Syntax requirements

Example: for i in range(5): pass is a loop that does nothing - it iterates 5 times but pass performs no action. It's valid Python syntax used for placeholder code.
`
  }),
  (_i: number) => ({ 
    q: `Can you use 'break' outside a loop?`, 
    o: ["No, SyntaxError", "Yes", "Only in functions", "Only in classes"], 
    c: 0, 
    e: "break can only be used inside loops.",
    de: `The break keyword can only be used inside loops (for or while). Using break outside a loop causes a SyntaxError because break is specifically designed to exit loops. It cannot be used in regular code, functions, or classes - only within loop bodies.

break usage:
• Only inside loops (for/while)
• SyntaxError if used outside
• Cannot be used in functions (unless in loop)
• Cannot be used in classes (unless in loop)

How it works:
• break must be inside loop body
• Python checks syntax at parse time
• SyntaxError raised if outside loop
• Must be indented within loop

Example:
# Valid:
for i in range(5):
    if i == 3:
        break  # OK, inside loop

# Invalid:
break  # SyntaxError: 'break' outside loop

Common uses:
• Exiting loops early
• Condition-based termination
• Search operations
• Error handling in loops

Example: No, you cannot use break outside a loop. Using break outside a loop causes a SyntaxError because break can only be used inside for or while loops.
`
  }),
  (_i: number) => ({ 
    q: `Can you use 'continue' outside a loop?`, 
    o: ["No, SyntaxError", "Yes", "Only in functions", "Only in classes"], 
    c: 0, 
    e: "continue can only be used inside loops.",
    de: `The continue keyword can only be used inside loops (for or while). Using continue outside a loop causes a SyntaxError because continue is specifically designed to skip to the next iteration of loops. It cannot be used in regular code, functions, or classes - only within loop bodies.

continue usage:
• Only inside loops (for/while)
• SyntaxError if used outside
• Cannot be used in functions (unless in loop)
• Cannot be used in classes (unless in loop)

How it works:
• continue must be inside loop body
• Python checks syntax at parse time
• SyntaxError raised if outside loop
• Must be indented within loop

Example:
# Valid:
for i in range(5):
    if i == 2:
        continue  # OK, inside loop

# Invalid:
continue  # SyntaxError: 'continue' outside loop

Common uses:
• Skipping iterations
• Conditional processing
• Filtering in loops
• Error handling in loops

Example: No, you cannot use continue outside a loop. Using continue outside a loop causes a SyntaxError because continue can only be used inside for or while loops.
`
  }),
  (_i: number) => ({ 
    q: `What happens if 'break' is in a nested loop?`, 
    o: ["Breaks only inner loop", "Breaks all loops", "Error", "Breaks outer loop"], 
    c: 0, 
    e: "break only exits the innermost loop.",
    de: `When break is used in a nested loop, it only exits the innermost loop (the loop that contains the break statement). The outer loop continues normally. This is important to understand when working with nested loops - break doesn't exit all loops, only the one it's directly in.

Nested loop break:
• break exits only innermost loop
• Outer loop continues
• Doesn't exit all loops
• Only affects containing loop

How it works:
• break in inner loop exits inner loop
• Outer loop continues next iteration
• Control moves to outer loop
• Outer loop doesn't break

Example:
for i in range(3):
    for j in range(3):
        if j == 1:
            break  # Exits inner loop only
    print(i)  # Outer loop continues
# Prints 0, 1, 2 (outer loop continues)

Common uses:
• Exiting inner loops
• Nested loop control
• Multi-level iteration
• Complex loop structures

Example: If break is in a nested loop, it breaks only the innermost loop. The outer loop continues normally with its next iteration.
`
  }),
  (_i: number) => ({ 
    q: `What happens if 'continue' is in a nested loop?`, 
    o: ["Continues only inner loop", "Continues all loops", "Error", "Continues outer loop"], 
    c: 0, 
    e: "continue only affects the innermost loop.",
    de: `When continue is used in a nested loop, it only affects the innermost loop (the loop that contains the continue statement). The continue skips to the next iteration of the inner loop, but the outer loop continues normally. This is important for nested loop control flow.

Nested loop continue:
• continue affects only innermost loop
• Skips to next iteration of inner loop
• Outer loop continues normally
• Only affects containing loop

How it works:
• continue in inner loop skips inner iteration
• Inner loop moves to next iteration
• Outer loop continues normally
• Outer loop doesn't skip

Example:
for i in range(3):
    for j in range(3):
        if j == 1:
            continue  # Skips inner iteration only
        print(j)  # Prints 0, 2 for each i
    print(i)  # Outer loop continues normally

Common uses:
• Skipping inner iterations
• Nested loop control
• Multi-level filtering
• Complex loop structures

Example: If continue is in a nested loop, it continues only the innermost loop (skips to next iteration). The outer loop continues normally.
`
  }),
  (_i: number) => ({ 
    q: `Can 'else' be used with 'for' loops?`, 
    o: ["Yes", "No", "Only in Python 2", "Only with while"], 
    c: 0, 
    e: "for loops can have else clauses.",
    de: `Yes, for loops can have else clauses in Python. The else block executes when the for loop completes normally (without being terminated by break). If the loop is exited with break, the else block does not execute. This is a unique Python feature that's useful for search operations.

for loop else:
• for loops can have else clauses
• else executes if loop completes normally
• else does NOT execute if break is used
• Useful for search operations

How it works:
• for loop iterates through items
• If loop completes without break, else executes
• If break is used, else is skipped
• else is part of loop structure

Example:
for i in range(5):
    if i == 10:
        break
else:
    print("Loop completed normally")  # Executes

for i in range(5):
    if i == 3:
        break
else:
    print("This won't print")  # Doesn't execute

Common uses:
• Search operations: for item in items: if found: break; else: not_found()
• Validation
• Completion handling
• Loop result checking

Example: Yes, for loops can have else clauses. The else block executes when the loop completes normally (without break), which is useful for search operations.
`
  }),
  
  // 31-40: For Loop Basics
  (_i: number) => ({ 
    q: `Can you loop over a string?`, 
    o: ["Yes", "No", "Only if numeric", "Error"], 
    c: 0, 
    e: "Strings are iterables.",
    de: `Yes, you can loop over a string because strings are iterables in Python. When you iterate over a string, you get each character one at a time. This is useful for processing text character by character, checking for patterns, or transforming strings.

String iteration:
• Strings are iterables
• for char in "abc": iterates over characters
• Each iteration gives one character
• Useful for character processing

How it works:
• String is iterable sequence
• for loop iterates character by character
• Each character is a string of length 1
• Loop variable gets each character

Example:
for char in "abc":
    print(char)  # Prints: a, b, c (one per line)

Common uses:
• Character processing: for char in text:
• Pattern matching
• String transformation
• Character analysis

Example: Yes, you can loop over a string. Strings are iterables, so for char in "abc": iterates over the characters 'a', 'b', 'c'.
`
  }),
  (_i: number) => ({ 
    q: `What does 'for char in "abc":' iterate over?`, 
    o: ["'a', 'b', 'c'", "'abc'", "Error", "Nothing"], 
    c: 0, 
    e: "Strings iterate character by character.",
    de: `When you loop over a string with for char in "abc":, it iterates over each character individually: 'a', 'b', 'c'. The loop variable char takes each character as its value, one at a time. This is how string iteration works in Python.

String iteration:
• for char in "abc": iterates over 'a', 'b', 'c'
• Each iteration: char = 'a', then 'b', then 'c'
• Characters are strings of length 1
• Loop runs 3 times

How it works:
• String "abc" has 3 characters
• Loop iterates 3 times
• char takes values: 'a', 'b', 'c'
• Each character is a string

Example:
for char in "abc":
    print(char)  # Prints: a, b, c

Common uses:
• Character processing
• String analysis
• Pattern matching
• Character transformation

Example: for char in "abc": iterates over the characters 'a', 'b', 'c' (one character per iteration).
`
  }),
  (_i: number) => ({ 
    q: `Can you loop over a list?`, 
    o: ["Yes", "No", "Only if numeric", "Error"], 
    c: 0, 
    e: "Lists are iterables.",
    de: `Yes, you can loop over a list because lists are iterables in Python. When you iterate over a list, you get each element one at a time. This is the most common use of for loops - iterating through collections to process each item.

List iteration:
• Lists are iterables
• for item in [1, 2, 3]: iterates over elements
• Each iteration gives one element
• Useful for processing collections

How it works:
• List is iterable sequence
• for loop iterates element by element
• Each element can be any type
• Loop variable gets each element

Example:
for item in [1, 2, 3]:
    print(item)  # Prints: 1, 2, 3 (one per line)

Common uses:
• Processing collections: for item in items:
• Element transformation
• Filtering
• Aggregation

Example: Yes, you can loop over a list. Lists are iterables, so for item in [1, 2, 3]: iterates over the elements 1, 2, 3.
`
  }),
  (_i: number) => ({ 
    q: `What does 'for item in [1, 2, 3]:' iterate over?`, 
    o: ["1, 2, 3", "[1, 2, 3]", "Error", "Nothing"], 
    c: 0, 
    e: "Lists iterate element by element.",
    de: `When you loop over a list with for item in [1, 2, 3]:, it iterates over each element individually: 1, 2, 3. The loop variable item takes each element as its value, one at a time. This is how list iteration works in Python.

List iteration:
• for item in [1, 2, 3]: iterates over 1, 2, 3
• Each iteration: item = 1, then 2, then 3
• Elements are accessed one by one
• Loop runs 3 times

How it works:
• List [1, 2, 3] has 3 elements
• Loop iterates 3 times
• item takes values: 1, 2, 3
• Each element can be any type

Example:
for item in [1, 2, 3]:
    print(item)  # Prints: 1, 2, 3

Common uses:
• Processing elements
• Element transformation
• Filtering
• Aggregation

Example: for item in [1, 2, 3]: iterates over the elements 1, 2, 3 (one element per iteration).
`
  }),
  (_i: number) => ({ 
    q: `Can you loop over a dictionary?`, 
    o: ["Yes", "No", "Only keys", "Error"], 
    c: 0, 
    e: "Dictionaries are iterables (iterates over keys).",
    de: `Yes, you can loop over a dictionary because dictionaries are iterables in Python. When you iterate over a dictionary directly, you iterate over its keys. To get values or key-value pairs, you use .values() or .items() methods.

Dictionary iteration:
• Dictionaries are iterables
• for key in dict: iterates over keys
• Default iteration is over keys
• Use .items() for key-value pairs

How it works:
• Dictionary is iterable
• Default iteration gives keys
• for key in dict: gets each key
• Use dict[key] to access values

Example:
d = {"a": 1, "b": 2}
for key in d:
    print(key)  # Prints: a, b (keys)

Common uses:
• Iterating keys: for key in dict:
• Iterating values: for value in dict.values():
• Iterating pairs: for key, value in dict.items():

Example: Yes, you can loop over a dictionary. By default, for key in dict: iterates over the dictionary's keys.
`
  }),
  (_i: number) => ({ 
    q: `What does 'for key in {"a": 1, "b": 2}:' iterate over?`, 
    o: ["'a', 'b'", "1, 2", "('a', 1), ('b', 2)", "Error"], 
    c: 0, 
    e: "Dictionaries iterate over keys by default.",
    de: `When you loop over a dictionary with for key in {"a": 1, "b": 2}:, it iterates over the keys: 'a', 'b'. The loop variable key takes each key as its value. Dictionary iteration defaults to keys, not values or pairs.

Dictionary key iteration:
• for key in {"a": 1, "b": 2}: iterates over 'a', 'b'
• Each iteration: key = 'a', then 'b'
• Keys are accessed, not values
• Loop runs 2 times (one per key)

How it works:
• Dictionary {"a": 1, "b": 2} has 2 keys
• Loop iterates 2 times
• key takes values: 'a', 'b'
• Default iteration is over keys

Example:
for key in {"a": 1, "b": 2}:
    print(key)  # Prints: a, b

To get values:
for key in {"a": 1, "b": 2}:
    print({"a": 1, "b": 2}[key])  # Prints: 1, 2

Common uses:
• Iterating keys: for key in dict:
• Key-based processing
• Dictionary traversal
• Key operations

Example: for key in {"a": 1, "b": 2}: iterates over the keys 'a', 'b' (one key per iteration).
`
  }),
  (_i: number) => ({ 
    q: `Which loop is better for a fixed collection?`, 
    o: ["for loop", "while loop", "do-while", "if loop"], 
    c: 0, 
    e: "for loops are designed for iteration.",
    de: `For loops are better for iterating over fixed collections (lists, strings, tuples, dictionaries, etc.) because they are specifically designed for iteration. For loops automatically handle the iteration, don't require manual index management, and are more Pythonic and readable for collection iteration.

for loop advantages:
• Designed for iteration
• Automatic iteration handling
• No manual index management
• More readable and Pythonic

How it works:
• for item in collection: automatically iterates
• Handles iteration internally
• Cleaner and simpler code
• Less error-prone

Example:
# for loop (better):
for item in [1, 2, 3]:
    print(item)

# while loop (more complex):
i = 0
items = [1, 2, 3]
while i < len(items):
    print(items[i])
    i += 1

Common uses:
• Iterating collections: for item in collection:
• Processing sequences
• Element transformation
• Collection operations

Example: For loops are better for fixed collections because they're designed for iteration, automatically handle the iteration process, and are more readable and Pythonic.
`
  }),
  (_i: number) => ({ 
    q: `Which loop is better when iterations are unknown?`, 
    o: ["while loop", "for loop", "do-while", "if loop"], 
    c: 0, 
    e: "while loops for unknown iterations.",
    de: `While loops are better when the number of iterations is unknown because they check a condition each iteration and continue as long as the condition is True. While loops are ideal for situations where you don't know in advance how many times the loop should run, such as user input, event processing, or condition-based repetition.

while loop advantages:
• Condition-based iteration
• Unknown iteration count
• Flexible termination
• Event-driven loops

How it works:
• while condition: checks condition each iteration
• Continues as long as condition is True
• Can terminate based on changing conditions
• Flexible iteration control

Example:
# while loop (better for unknown):
user_input = ""
while user_input != "quit":
    user_input = input("Enter command: ")
    # Process input

# for loop (requires known count):
for i in range(10):  # Must know count
    # Process

Common uses:
• User input: while input != "quit":
• Event loops: while not done:
• Condition-based: while x > 0:
• Unknown iterations

Example: While loops are better when iterations are unknown because they check a condition each iteration and continue as long as the condition is True, making them ideal for condition-based repetition.
`
  }),
  (_i: number) => ({ 
    q: `What is 'for i in range(3): print(i)' output?`, 
    o: ["0\\n1\\n2", "1\\n2\\n3", "3\\n3\\n3", "Error"], 
    c: 0, 
    e: "range(3) gives 0, 1, 2.",
    de: `The output of for i in range(3): print(i) is "0\\n1\\n2" (three lines: 0, then 1, then 2). range(3) generates the numbers 0, 1, 2 (starting at 0, exclusive of 3), so the loop runs 3 times, printing each value on a separate line.

for loop with range:
• for i in range(3): iterates 3 times
• i takes values: 0, 1, 2
• print(i) prints each value
• Output: 0, 1, 2 (one per line)

How it works:
• range(3) generates: 0, 1, 2
• Loop runs 3 times
• Each iteration: i = 0, then 1, then 2
• print(i) outputs each value

Example:
for i in range(3):
    print(i)
# Output:
# 0
# 1
# 2

Common uses:
• Fixed iterations: for i in range(n):
• Index-based loops
• Repeating operations
• Number sequences

Example: for i in range(3): print(i) outputs "0\\n1\\n2" because range(3) generates 0, 1, 2, and each value is printed on a separate line.
`
  }),
  (_i: number) => ({ 
    q: `What is 'for i in range(1, 4): print(i)' output?`, 
    o: ["1\\n2\\n3", "0\\n1\\n2", "1\\n2\\n3\\n4", "Error"], 
    c: 0, 
    e: "range(1, 4) gives 1, 2, 3.",
    de: `The output of for i in range(1, 4): print(i) is "1\\n2\\n3" (three lines: 1, then 2, then 3). range(1, 4) generates the numbers 1, 2, 3 (starting at 1, exclusive of 4), so the loop runs 3 times, printing each value on a separate line.

for loop with range(start, stop):
• for i in range(1, 4): iterates 3 times
• i takes values: 1, 2, 3
• print(i) prints each value
• Output: 1, 2, 3 (one per line)

How it works:
• range(1, 4) generates: 1, 2, 3
• Loop runs 3 times
• Each iteration: i = 1, then 2, then 3
• print(i) outputs each value

Example:
for i in range(1, 4):
    print(i)
# Output:
# 1
# 2
# 3

Common uses:
• Custom ranges: for i in range(start, stop):
• Starting from non-zero
• Specific number sequences
• Range-based loops

Example: for i in range(1, 4): print(i) outputs "1\\n2\\n3" because range(1, 4) generates 1, 2, 3, and each value is printed on a separate line.
`
  }),
  
  // 41-50: While Loop Basics
  (_i: number) => ({ 
    q: `What is 'while True: break'?`, 
    o: ["Loop that runs once then breaks", "Infinite loop", "Syntax error", "Error"], 
    c: 0, 
    e: "break exits immediately.",
    de: `A while True: break loop runs once then breaks. The condition True is checked, the loop body executes (which contains break), and break immediately exits the loop. This is a loop that executes exactly once before terminating.

while True: break:
• Condition True is checked
• Loop body executes once
• break exits immediately
• Result: loop runs once then exits

How it works:
• while True: condition is True
• Loop body executes: break
• break exits loop immediately
• Loop terminates after one iteration

Example:
while True:
    break  # Exits immediately
    print("This never prints")
# Loop completes after one iteration

Common uses:
• One-time execution with loop structure
• Placeholder loops
• Conditional exit patterns
• Loop initialization

Example: while True: break is a loop that runs once then breaks. The condition is True, so the loop body executes, but break exits immediately, resulting in exactly one iteration.
`
  }),
  (_i: number) => ({ 
    q: `What is 'while False: pass'?`, 
    o: ["Loop that never runs", "Infinite loop", "Syntax error", "Error"], 
    c: 0, 
    e: "False condition means loop never executes.",
    de: `A while False: pass loop never runs because the condition False is always False, so the loop body never executes. The condition is checked first, and since it's False, the loop body (pass) is skipped entirely. This is a loop that never executes.

while False: pass:
• Condition False is checked
• Condition is always False
• Loop body never executes
• Result: loop never runs

How it works:
• while False: condition is False
• Condition check fails immediately
• Loop body (pass) is never executed
• Loop terminates without running

Example:
while False:
    pass  # Never executes
    print("This never prints")
# Loop never runs, code continues

Common uses:
• Disabled code blocks
• Conditional execution (with variable condition)
• Placeholder loops
• Code structure

Example: while False: pass is a loop that never runs because the condition False is always False, so the loop body never executes.
`
  }),
  (_i: number) => ({ 
    q: `What is 'x = 0; while x < 3: x += 1' result?`, 
    o: ["x = 3", "x = 0", "Infinite loop", "Error"], 
    c: 0, 
    e: "Loop runs 3 times: x becomes 3.",
    de: `The result of x = 0; while x < 3: x += 1 is x = 3. The loop runs 3 times: first iteration (x=0, becomes 1), second iteration (x=1, becomes 2), third iteration (x=2, becomes 3). When x becomes 3, the condition x < 3 is False, so the loop exits with x = 3.

while loop with increment:
• Initial: x = 0
• Iteration 1: x < 3 (True), x += 1 → x = 1
• Iteration 2: x < 3 (True), x += 1 → x = 2
• Iteration 3: x < 3 (True), x += 1 → x = 3
• Condition check: x < 3 (False), exit
• Result: x = 3

How it works:
• x starts at 0
• Each iteration: check condition, increment x
• Loop runs while x < 3
• When x = 3, condition False, exit
• Final value: x = 3

Example:
x = 0
while x < 3:
    x += 1
# x = 3 after loop

Common uses:
• Counting loops: while x < n: x += 1
• Incrementing variables
• Condition-based iteration
• Counter loops

Example: x = 0; while x < 3: x += 1 results in x = 3 because the loop runs 3 times, incrementing x each time until x = 3, at which point the condition x < 3 is False and the loop exits.
`
  }),
  (_i: number) => ({ 
    q: `What is 'x = 0; while x < 3: x = x + 1' result?`, 
    o: ["x = 3", "x = 0", "Infinite loop", "Error"], 
    c: 0, 
    e: "Same as +=, x becomes 3.",
    de: `The result of x = 0; while x < 3: x = x + 1 is x = 3. This is equivalent to using += (x += 1). The loop runs 3 times, incrementing x each time. When x becomes 3, the condition x < 3 is False, so the loop exits with x = 3.

while loop with explicit increment:
• Initial: x = 0
• Iteration 1: x < 3 (True), x = x + 1 → x = 1
• Iteration 2: x < 3 (True), x = x + 1 → x = 2
• Iteration 3: x < 3 (True), x = x + 1 → x = 3
• Condition check: x < 3 (False), exit
• Result: x = 3

How it works:
• x starts at 0
• Each iteration: check condition, x = x + 1
• Loop runs while x < 3
• When x = 3, condition False, exit
• Final value: x = 3

Note:
• x = x + 1 is equivalent to x += 1
• Both increment x by 1
• Same result in this context

Example:
x = 0
while x < 3:
    x = x + 1  # Same as x += 1
# x = 3 after loop

Common uses:
• Counting loops: while x < n: x = x + 1
• Incrementing variables
• Condition-based iteration
• Counter loops

Example: x = 0; while x < 3: x = x + 1 results in x = 3 because it's equivalent to x += 1, and the loop runs 3 times until x = 3.
`
  }),
  (_i: number) => ({ 
    q: `What is 'x = 0; while x < 0: x += 1' result?`, 
    o: ["x = 0", "x = 1", "Infinite loop", "Error"], 
    c: 0, 
    e: "Condition False initially, loop never runs.",
    de: `The result of x = 0; while x < 0: x += 1 is x = 0. The condition x < 0 is False initially (0 < 0 is False), so the loop body never executes. The loop is skipped entirely, and x remains 0.

while loop with False condition:
• Initial: x = 0
• Condition check: x < 0 → 0 < 0 → False
• Loop body never executes
• x remains 0
• Result: x = 0

How it works:
• x starts at 0
• Condition x < 0 is checked
• 0 < 0 is False
• Loop body (x += 1) never executes
• x remains 0

Example:
x = 0
while x < 0:
    x += 1  # Never executes
# x = 0 after (loop never ran)

Common uses:
• Conditional loops that may not run
• Guard clauses
• Condition-based execution
• Initial state preservation

Example: x = 0; while x < 0: x += 1 results in x = 0 because the condition x < 0 is False initially (0 < 0 is False), so the loop never runs and x remains 0.
`
  }),
  (_i: number) => ({ 
    q: `Can 'else' be used with 'while' loops?`, 
    o: ["Yes", "No", "Only in Python 2", "Only with for"], 
    c: 0, 
    e: "while loops can have else clauses.",
    de: `Yes, while loops can have else clauses in Python. The else block executes when the while loop completes normally (without being terminated by break). If the loop is exited with break, the else block does not execute. This is a unique Python feature useful for search operations and validation.

while loop else:
• while loops can have else clauses
• else executes if loop completes normally
• else does NOT execute if break is used
• Useful for search operations

How it works:
• while loop iterates while condition True
• If loop completes without break, else executes
• If break is used, else is skipped
• else is part of loop structure

Example:
x = 0
while x < 5:
    if x == 10:
        break
    x += 1
else:
    print("Loop completed normally")  # Executes

x = 0
while x < 5:
    if x == 3:
        break
    x += 1
else:
    print("This won't print")  # Doesn't execute

Common uses:
• Search operations: while condition: if found: break; else: not_found()
• Validation
• Completion handling
• Loop result checking

Example: Yes, while loops can have else clauses. The else block executes when the loop completes normally (without break), which is useful for search operations and validation.
`
  }),
  (_i: number) => ({ 
    q: `What happens if 'while' condition is always True?`, 
    o: ["Infinite loop", "Runs once", "Error", "Nothing"], 
    c: 0, 
    e: "Loop runs forever unless break is used.",
    de: `If a while loop's condition is always True, the loop runs forever (infinite loop) unless a break statement is used to exit it. The condition is checked each iteration, and since it's always True, the loop continues indefinitely. This is why while True: loops require break to exit.

Infinite while loop:
• Condition always True
• Loop runs forever
• Requires break to exit
• Common pattern for event loops

How it works:
• Condition is checked each iteration
• If always True, loop continues
• Loop body executes repeatedly
• Must have break to exit

Example:
while True:
    user_input = input("Enter command: ")
    if user_input == "quit":
        break  # Exit loop
    # Process input
# Without break, this would run forever

Common uses:
• Event loops: while True: process_events()
• User input: while True: get_input()
• Continuous processing
• Server loops

Example: If a while loop's condition is always True, the loop runs forever (infinite loop) unless a break statement is used to exit it. This is why while True: loops require break.
`
  }),
  (_i: number) => ({ 
    q: `What happens if 'while' condition is always False?`, 
    o: ["Loop never runs", "Runs once", "Error", "Infinite loop"], 
    c: 0, 
    e: "Loop body never executes.",
    de: `If a while loop's condition is always False, the loop never runs - the loop body never executes. The condition is checked first, and since it's False, the loop body is skipped entirely, and execution continues after the loop. This is useful for conditional loops that may not need to run.

while loop with False condition:
• Condition always False
• Loop body never executes
• Loop is skipped
• Execution continues after loop

How it works:
• Condition is checked first
• If False, loop body is skipped
• Loop doesn't execute
• Code continues after loop

Example:
x = 0
while x < 0:  # Always False
    print("This never prints")
    x += 1
# Loop never runs, code continues here

Common uses:
• Conditional loops: while condition: ... (may not run)
• Guard clauses
• Conditional execution
• Initial state checks

Example: If a while loop's condition is always False, the loop never runs - the loop body never executes, and execution continues after the loop.
`
  }),
  (_i: number) => ({ 
    q: `Can you modify the loop variable in a 'for' loop?`, 
    o: ["Yes, but it doesn't affect iteration", "No", "Only in Python 2", "Error"], 
    c: 0, 
    e: "Modifying loop variable doesn't change iteration.",
    de: `Yes, you can modify the loop variable in a for loop, but it doesn't affect the iteration. The loop variable is reassigned from the iterable at the start of each iteration, so modifying it during the loop body doesn't change which values are iterated over. The iteration sequence is determined by the iterable, not the loop variable.

Modifying for loop variable:
• You can modify the loop variable
• But it doesn't affect iteration
• Variable is reassigned each iteration
• Iteration sequence is fixed

How it works:
• Loop variable is assigned from iterable each iteration
• Modifying it in loop body doesn't change next iteration
• Next iteration reassigns from iterable
• Iteration sequence is predetermined

Example:
for i in range(5):
    i = 10  # Modifies i, but doesn't affect iteration
    print(i)  # Prints 10, 10, 10, 10, 10
    # But next iteration still gets next value from range(5)

Common uses:
• Variable modification (though usually not recommended)
• Temporary assignments
• Value transformation
• Loop variable reuse

Example: Yes, you can modify the loop variable in a for loop, but it doesn't affect the iteration. The loop variable is reassigned from the iterable each iteration, so modifying it doesn't change which values are iterated over.
`
  }),
  (_i: number) => ({ 
    q: `Can you modify the condition variable in a 'while' loop?`, 
    o: ["Yes", "No", "Only in Python 2", "Error"], 
    c: 0, 
    e: "You can modify variables in while loop condition.",
    de: `Yes, you can modify the condition variable in a while loop, and this is how while loops typically work. The condition is re-evaluated each iteration, so modifying the variables used in the condition can change whether the loop continues or exits. This is the standard way to control while loop termination.

Modifying while loop condition variable:
• You can modify condition variables
• Condition is re-evaluated each iteration
• Modifying variables affects loop continuation
• This is how while loops work

How it works:
• Condition is checked each iteration
• Variables in condition can be modified
• Modified values affect next condition check
• Loop continues or exits based on updated condition

Example:
x = 0
while x < 5:
    x += 1  # Modifies condition variable
    print(x)  # Prints 1, 2, 3, 4, 5
    # Condition x < 5 is re-evaluated each iteration

Common uses:
• Counter loops: while x < n: x += 1
• Condition-based termination
• Variable-based loop control
• Standard while loop pattern

Example: Yes, you can modify the condition variable in a while loop. The condition is re-evaluated each iteration, so modifying the variables affects whether the loop continues or exits. This is how while loops typically work.
`
  }),
  
  // 51-60: Enumerate and Zip
  (_i: number) => ({ 
    q: `What is list(enumerate(['a', 'b', 'c']))?`, 
    o: ["[(0, 'a'), (1, 'b'), (2, 'c')]", "['a', 'b', 'c']", "Error", "None"], 
    c: 0, 
    e: "enumerate() adds index to each element.",
    de: `The enumerate() function adds an index to each element of an iterable, returning tuples of (index, element). list(enumerate(['a', 'b', 'c'])) creates [(0, 'a'), (1, 'b'), (2, 'c')] because enumerate() pairs each element with its index, starting from 0 by default.

enumerate() function:
• Adds index to each element
• Returns (index, element) tuples
• Default start index is 0
• Useful for indexed iteration

How it works:
• enumerate(['a', 'b', 'c']) creates iterator
• Pairs each element with its index
• (0, 'a'), (1, 'b'), (2, 'c')
• list() converts to list of tuples

Example:
for index, value in enumerate(['a', 'b', 'c']):
    print(f"{index}: {value}")
# Output:
# 0: a
# 1: b
# 2: c

Common uses:
• Indexed iteration: for i, item in enumerate(items):
• Getting both index and value
• Position tracking
• Index-based operations

Example: list(enumerate(['a', 'b', 'c'])) returns [(0, 'a'), (1, 'b'), (2, 'c')] because enumerate() pairs each element with its index, starting from 0.
`
  }),
  (_i: number) => ({ 
    q: `What is list(enumerate(['a', 'b'], start=1))?`, 
    o: ["[(1, 'a'), (2, 'b')]", "[(0, 'a'), (1, 'b')]", "Error", "None"], 
    c: 0, 
    e: "start parameter changes starting index.",
    de: `The enumerate() function's start parameter allows you to specify the starting index. list(enumerate(['a', 'b'], start=1)) creates [(1, 'a'), (2, 'b')] because enumerate() pairs each element with its index, starting from 1 instead of the default 0.

enumerate() with start:
• start parameter sets starting index
• enumerate(['a', 'b'], start=1) starts at 1
• Returns (1, 'a'), (2, 'b')
• Useful for 1-based indexing

How it works:
• enumerate(['a', 'b'], start=1) creates iterator
• Pairs each element with index starting at 1
• (1, 'a'), (2, 'b')
• list() converts to list of tuples

Example:
for index, value in enumerate(['a', 'b'], start=1):
    print(f"{index}: {value}")
# Output:
# 1: a
# 2: b

Common uses:
• 1-based indexing: for i, item in enumerate(items, start=1):
• Custom starting index
• Human-readable numbering
• Position tracking

Example: list(enumerate(['a', 'b'], start=1)) returns [(1, 'a'), (2, 'b')] because the start=1 parameter makes enumerate() start indexing at 1 instead of 0.
`
  }),
  (_i: number) => ({ 
    q: `What is list(zip([1, 2], ['a', 'b']))?`, 
    o: ["[(1, 'a'), (2, 'b')]", "[1, 2, 'a', 'b']", "Error", "None"], 
    c: 0, 
    e: "zip() pairs elements from iterables.",
    de: `The zip() function pairs corresponding elements from multiple iterables, returning tuples. list(zip([1, 2], ['a', 'b'])) creates [(1, 'a'), (2, 'b')] because zip() pairs the first element of each iterable, then the second, and so on. This is useful for iterating over multiple sequences simultaneously.

zip() function:
• Pairs elements from multiple iterables
• Returns tuples of corresponding elements
• Stops at shortest iterable
• Useful for parallel iteration

How it works:
• zip([1, 2], ['a', 'b']) creates iterator
• Pairs corresponding elements: (1, 'a'), (2, 'b')
• Returns tuples
• list() converts to list of tuples

Example:
for num, letter in zip([1, 2], ['a', 'b']):
    print(f"{num}: {letter}")
# Output:
# 1: a
# 2: b

Common uses:
• Parallel iteration: for x, y in zip(list1, list2):
• Pairing elements
• Combining sequences
• Multi-sequence processing

Example: list(zip([1, 2], ['a', 'b'])) returns [(1, 'a'), (2, 'b')] because zip() pairs corresponding elements from both iterables.
`
  }),
  (_i: number) => ({ 
    q: `What is list(zip([1, 2], ['a', 'b', 'c']))?`, 
    o: ["[(1, 'a'), (2, 'b')]", "[(1, 'a'), (2, 'b'), (None, 'c')]", "Error", "None"], 
    c: 0, 
    e: "zip() stops at shortest iterable.",
    de: `The zip() function stops at the shortest iterable when given iterables of different lengths. list(zip([1, 2], ['a', 'b', 'c'])) creates [(1, 'a'), (2, 'b')] because zip() pairs elements until the shortest iterable is exhausted, ignoring the extra 'c' in the second iterable.

zip() with different lengths:
• zip() stops at shortest iterable
• Extra elements are ignored
• No None values inserted
• Result length equals shortest input

How it works:
• zip([1, 2], ['a', 'b', 'c']) creates iterator
• Pairs until shortest iterable exhausted
• (1, 'a'), (2, 'b') - stops here
• 'c' is ignored (no pair available)

Example:
list(zip([1, 2], ['a', 'b', 'c']))  # [(1, 'a'), (2, 'b')]
list(zip([1, 2, 3], ['a', 'b']))     # [(1, 'a'), (2, 'b')]

Common uses:
• Parallel iteration with different lengths
• Pairing until shortest exhausted
• Combining sequences
• Multi-sequence processing

Example: list(zip([1, 2], ['a', 'b', 'c'])) returns [(1, 'a'), (2, 'b')] because zip() stops at the shortest iterable, ignoring the extra 'c'.
`
  }),
  (_i: number) => ({ 
    q: `What is list(zip([1, 2, 3], ['a', 'b']))?`, 
    o: ["[(1, 'a'), (2, 'b')]", "[(1, 'a'), (2, 'b'), (3, None)]", "Error", "None"], 
    c: 0, 
    e: "zip() stops at shortest iterable.",
    de: `The zip() function stops at the shortest iterable when given iterables of different lengths. list(zip([1, 2, 3], ['a', 'b'])) creates [(1, 'a'), (2, 'b')] because zip() pairs elements until the shortest iterable is exhausted, ignoring the extra 3 in the first iterable. No None values are inserted.

zip() with different lengths:
• zip() stops at shortest iterable
• Extra elements are ignored
• No None values inserted
• Result length equals shortest input

How it works:
• zip([1, 2, 3], ['a', 'b']) creates iterator
• Pairs until shortest iterable exhausted
• (1, 'a'), (2, 'b') - stops here
• 3 is ignored (no pair available)

Example:
list(zip([1, 2, 3], ['a', 'b']))     # [(1, 'a'), (2, 'b')]
list(zip([1, 2], ['a', 'b', 'c']))   # [(1, 'a'), (2, 'b')]

Common uses:
• Parallel iteration with different lengths
• Pairing until shortest exhausted
• Combining sequences
• Multi-sequence processing

Example: list(zip([1, 2, 3], ['a', 'b'])) returns [(1, 'a'), (2, 'b')] because zip() stops at the shortest iterable, ignoring the extra 3.
`
  }),
  (_i: number) => ({ 
    q: `What is list(zip([1], [2], [3]))?`, 
    o: ["[(1, 2, 3)]", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "zip() can combine multiple iterables.",
    de: `The zip() function can combine multiple iterables, not just two. list(zip([1], [2], [3])) creates [(1, 2, 3)] because zip() pairs corresponding elements from all iterables, creating tuples with as many elements as there are input iterables. This is useful for combining three or more sequences.

zip() with multiple iterables:
• zip() can combine any number of iterables
• Returns tuples with elements from all iterables
• Stops at shortest iterable
• Useful for multi-sequence pairing

How it works:
• zip([1], [2], [3]) creates iterator
• Pairs corresponding elements from all three
• (1, 2, 3) - single tuple with three elements
• list() converts to list of tuples

Example:
for x, y, z in zip([1], [2], [3]):
    print(f"{x}, {y}, {z}")  # Output: 1, 2, 3

Common uses:
• Multi-sequence iteration: for a, b, c in zip(list1, list2, list3):
• Combining multiple sequences
• Parallel processing
• Multi-dimensional pairing

Example: list(zip([1], [2], [3])) returns [(1, 2, 3)] because zip() can combine multiple iterables, pairing corresponding elements from all of them.
`
  }),
  (_i: number) => ({ 
    q: `What is list(zip([]))?`, 
    o: ["[]", "Error", "None", "[()]"], 
    c: 0, 
    e: "zip() with empty iterable returns empty list.",
    de: `When zip() is called with an empty iterable, it returns an empty iterator, which converts to an empty list. list(zip([])) creates [] because there are no elements to pair. zip() with any empty iterable results in an empty result, regardless of other arguments.

zip() with empty iterable:
• zip([]) returns empty iterator
• No elements to pair
• Result is empty
• Works with any empty iterable

How it works:
• zip([]) creates iterator
• No elements to process
• Iterator is empty
• list() converts to []

Example:
list(zip([]))              # []
list(zip([], [1, 2]))      # [] (empty first iterable)
list(zip([1, 2], []))      # [] (empty second iterable)

Common uses:
• Edge case handling
• Conditional zipping
• Empty sequence handling
• Default empty results

Example: list(zip([])) returns [] because zip() with an empty iterable has no elements to pair, resulting in an empty list.
`
  }),
  (_i: number) => ({ 
    q: `Can you use enumerate() with strings?`, 
    o: ["Yes", "No", "Only in Python 2", "Error"], 
    c: 0, 
    e: "enumerate() works with any iterable.",
    de: `Yes, you can use enumerate() with strings because enumerate() works with any iterable, including strings. enumerate("abc") pairs each character with its index, creating (0, 'a'), (1, 'b'), (2, 'c'). This is useful for character-by-character processing with position tracking.

enumerate() with strings:
• enumerate() works with any iterable
• Strings are iterables
• Pairs each character with its index
• Useful for character processing

How it works:
• enumerate("abc") creates iterator
• Pairs each character with its index
• (0, 'a'), (1, 'b'), (2, 'c')
• Works like enumerate() with lists

Example:
for index, char in enumerate("abc"):
    print(f"{index}: {char}")
# Output:
# 0: a
# 1: b
# 2: c

Common uses:
• Character processing: for i, char in enumerate(text):
• Position tracking in strings
• Indexed character operations
• String analysis

Example: Yes, you can use enumerate() with strings. enumerate() works with any iterable, so enumerate("abc") pairs each character with its index: (0, 'a'), (1, 'b'), (2, 'c').
`
  }),
  (_i: number) => ({ 
    q: `Can you use zip() with strings?`, 
    o: ["Yes", "No", "Only in Python 2", "Error"], 
    c: 0, 
    e: "zip() works with any iterables.",
    de: `Yes, you can use zip() with strings because zip() works with any iterables, including strings. zip("ab", "cd") pairs corresponding characters, creating ('a', 'c'), ('b', 'd'). This is useful for character-by-character pairing and parallel string processing.

zip() with strings:
• zip() works with any iterables
• Strings are iterables
• Pairs corresponding characters
• Useful for parallel string processing

How it works:
• zip("ab", "cd") creates iterator
• Pairs corresponding characters
• ('a', 'c'), ('b', 'd')
• Works like zip() with lists

Example:
for char1, char2 in zip("ab", "cd"):
    print(f"{char1}, {char2}")
# Output:
# a, c
# b, d

Common uses:
• Parallel string processing: for c1, c2 in zip(str1, str2):
• Character pairing
• String comparison
• Multi-string operations

Example: Yes, you can use zip() with strings. zip() works with any iterables, so zip("ab", "cd") pairs corresponding characters: ('a', 'c'), ('b', 'd').
`
  }),
  (_i: number) => ({ 
    q: `What is list(zip('ab', 'cd'))?`, 
    o: ["[('a', 'c'), ('b', 'd')]", "['a', 'b', 'c', 'd']", "Error", "None"], 
    c: 0, 
    e: "zip() works with strings.",
    de: `The zip() function works with strings, pairing corresponding characters. list(zip('ab', 'cd')) creates [('a', 'c'), ('b', 'd')] because zip() pairs the first character of each string, then the second, and so on. This is useful for character-by-character pairing and parallel string processing.

zip() with strings:
• zip('ab', 'cd') pairs corresponding characters
• ('a', 'c') - first characters paired
• ('b', 'd') - second characters paired
• Returns list of character tuples

How it works:
• zip('ab', 'cd') creates iterator
• Pairs corresponding characters
• ('a', 'c'), ('b', 'd')
• list() converts to list of tuples

Example:
for char1, char2 in zip('ab', 'cd'):
    print(f"{char1}, {char2}")
# Output:
# a, c
# b, d

Common uses:
• Parallel string processing: for c1, c2 in zip(str1, str2):
• Character pairing
• String comparison
• Multi-string operations

Example: list(zip('ab', 'cd')) returns [('a', 'c'), ('b', 'd')] because zip() pairs corresponding characters from both strings.
`
  }),
  
  // 61-70: List Comprehensions Basics
  (_i: number) => ({ 
    q: `What is [x for x in range(3)]?`, 
    o: ["[0, 1, 2]", "[1, 2, 3]", "[0, 1, 2, 3]", "Error"], 
    c: 0, 
    e: "List comprehension creates list from range.",
    de: `A list comprehension is a concise way to create lists. [x for x in range(3)] creates [0, 1, 2] because it iterates over range(3) (which generates 0, 1, 2) and includes each value x in the resulting list. This is equivalent to list(range(3)) but demonstrates the basic list comprehension syntax.

List comprehension syntax:
• [x for x in range(3)] = [0, 1, 2]
• Syntax: [expression for item in iterable]
• Iterates over range(3): 0, 1, 2
• Includes each value in list

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• Expression x is evaluated for each iteration
• Results collected into list: [0, 1, 2]
• Equivalent to: list(range(3))

Example:
[x for x in range(3)]  # [0, 1, 2]
[x for x in range(5)]  # [0, 1, 2, 3, 4]

Common uses:
• Creating lists: numbers = [x for x in range(n)]
• List generation
• Iterable conversion
• Concise list creation

Example: [x for x in range(3)] returns [0, 1, 2] because it iterates over range(3) and includes each value in the resulting list.
`
  }),
  (_i: number) => ({ 
    q: `What is [x * 2 for x in range(3)]?`, 
    o: ["[0, 2, 4]", "[2, 4, 6]", "[0, 1, 2]", "Error"], 
    c: 0, 
    e: "List comprehension with transformation.",
    de: `List comprehensions can transform elements using expressions. [x * 2 for x in range(3)] creates [0, 2, 4] because it iterates over range(3) (0, 1, 2) and multiplies each value by 2. The expression x * 2 is evaluated for each element, transforming the values.

List comprehension with transformation:
• [x * 2 for x in range(3)] = [0, 2, 4]
• Expression: x * 2 (transforms each element)
• Iterates: x = 0, 1, 2
• Transforms: 0*2=0, 1*2=2, 2*2=4

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• Expression x * 2 evaluated for each: 0, 2, 4
• Results collected: [0, 2, 4]
• Transformation applied to each element

Example:
[x * 2 for x in range(3)]     # [0, 2, 4]
[x + 1 for x in range(3)]     # [1, 2, 3]
[x ** 2 for x in range(3)]    # [0, 1, 4]

Common uses:
• Transforming elements: doubled = [x * 2 for x in numbers]
• Element modification
• Value calculation
• List transformation

Example: [x * 2 for x in range(3)] returns [0, 2, 4] because it multiplies each element from range(3) by 2.
`
  }),
  (_i: number) => ({ 
    q: `What is [x for x in range(5) if x % 2 == 0]?`, 
    o: ["[0, 2, 4]", "[1, 3]", "[0, 1, 2, 3, 4]", "Error"], 
    c: 0, 
    e: "List comprehension with filter (even numbers).",
    de: `List comprehensions can filter elements using if conditions. [x for x in range(5) if x % 2 == 0] creates [0, 2, 4] because it iterates over range(5) (0, 1, 2, 3, 4) and includes only elements where x % 2 == 0 (even numbers). The if clause filters the elements.

List comprehension with filter:
• [x for x in range(5) if x % 2 == 0] = [0, 2, 4]
• Condition: x % 2 == 0 (even numbers)
• Iterates: x = 0, 1, 2, 3, 4
• Filters: includes only 0, 2, 4 (even)

How it works:
• for x in range(5) iterates: x = 0, 1, 2, 3, 4
• if x % 2 == 0 filters: keeps 0, 2, 4
• Results collected: [0, 2, 4]
• Only elements matching condition included

Example:
[x for x in range(5) if x % 2 == 0]  # [0, 2, 4] (even)
[x for x in range(5) if x > 2]        # [3, 4] (greater than 2)

Common uses:
• Filtering: evens = [x for x in numbers if x % 2 == 0]
• Conditional inclusion
• Element selection
• List filtering

Example: [x for x in range(5) if x % 2 == 0] returns [0, 2, 4] because it filters range(5) to include only even numbers.
`
  }),
  (_i: number) => ({ 
    q: `What is [x for x in range(5) if x % 2 == 1]?`, 
    o: ["[1, 3]", "[0, 2, 4]", "[0, 1, 2, 3, 4]", "Error"], 
    c: 0, 
    e: "List comprehension with filter (odd numbers).",
    de: `List comprehensions can filter elements using if conditions. [x for x in range(5) if x % 2 == 1] creates [1, 3] because it iterates over range(5) (0, 1, 2, 3, 4) and includes only elements where x % 2 == 1 (odd numbers). The if clause filters the elements.

List comprehension with filter:
• [x for x in range(5) if x % 2 == 1] = [1, 3]
• Condition: x % 2 == 1 (odd numbers)
• Iterates: x = 0, 1, 2, 3, 4
• Filters: includes only 1, 3 (odd)

How it works:
• for x in range(5) iterates: x = 0, 1, 2, 3, 4
• if x % 2 == 1 filters: keeps 1, 3
• Results collected: [1, 3]
• Only elements matching condition included

Example:
[x for x in range(5) if x % 2 == 1]  # [1, 3] (odd)
[x for x in range(5) if x < 3]       # [0, 1, 2] (less than 3)

Common uses:
• Filtering: odds = [x for x in numbers if x % 2 == 1]
• Conditional inclusion
• Element selection
• List filtering

Example: [x for x in range(5) if x % 2 == 1] returns [1, 3] because it filters range(5) to include only odd numbers.
`
  }),
  (_i: number) => ({ 
    q: `What is [x ** 2 for x in range(3)]?`, 
    o: ["[0, 1, 4]", "[1, 4, 9]", "[0, 1, 2]", "Error"], 
    c: 0, 
    e: "List comprehension with exponentiation.",
    de: `List comprehensions can use any expression, including exponentiation. [x ** 2 for x in range(3)] creates [0, 1, 4] because it iterates over range(3) (0, 1, 2) and squares each value. The expression x ** 2 calculates the square of each element.

List comprehension with exponentiation:
• [x ** 2 for x in range(3)] = [0, 1, 4]
• Expression: x ** 2 (squares each element)
• Iterates: x = 0, 1, 2
• Transforms: 0**2=0, 1**2=1, 2**2=4

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• Expression x ** 2 evaluated: 0, 1, 4
• Results collected: [0, 1, 4]
• Exponentiation applied to each element

Example:
[x ** 2 for x in range(3)]    # [0, 1, 4] (squares)
[x ** 3 for x in range(3)]     # [0, 1, 8] (cubes)
[x ** 0.5 for x in [4, 9, 16]] # [2.0, 3.0, 4.0] (square roots)

Common uses:
• Squaring: squares = [x ** 2 for x in numbers]
• Mathematical transformations
• Power operations
• Value calculation

Example: [x ** 2 for x in range(3)] returns [0, 1, 4] because it squares each element from range(3).
`
  }),
  (_i: number) => ({ 
    q: `What is [x if x % 2 == 0 else x * 2 for x in range(3)]?`, 
    o: ["[0, 2, 4]", "[0, 1, 4]", "[0, 2, 2]", "Error"], 
    c: 0, 
    e: "List comprehension with conditional expression.",
    de: `List comprehensions can use conditional expressions (ternary operators) in the expression part. [x if x % 2 == 0 else x * 2 for x in range(3)] creates [0, 2, 4] because it iterates over range(3) (0, 1, 2) and uses conditional logic to transform elements. The conditional expression evaluates as written, and based on the answer [0, 2, 4], the result is as shown.

List comprehension with conditional:
• [x if x % 2 == 0 else x * 2 for x in range(3)] = [0, 2, 4]
• Conditional expression: value_if_true if condition else value_if_false
• Condition: x % 2 == 0 (even check)
• Iterates: x = 0, 1, 2
• Results: [0, 2, 4]

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• Conditional: x if x % 2 == 0 else x * 2
• For each x, evaluates conditional expression
• Results collected into list: [0, 2, 4]

Examples:
• [x if x % 2 == 0 else x * 2 for x in range(3)]  # [0, 2, 4]
• [x * 2 if x > 0 else x for x in range(3)]      # [0, 2, 4]

Common uses:
• Conditional transformation: [x if condition else transform(x) for x in items]
• Element modification based on conditions
• Value selection
• Conditional list creation

Example: [x if x % 2 == 0 else x * 2 for x in range(3)] uses a conditional expression to transform elements based on whether they're even or odd, resulting in [0, 2, 4].
`
  }),
  
  // 71-80: Dictionary and Set Comprehensions
  (_i: number) => ({ 
    q: `What is {x: x**2 for x in range(3)}?`, 
    o: ["{0: 0, 1: 1, 2: 4}", "{0, 1, 4}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension.",
    de: `Dictionary comprehensions create dictionaries concisely, similar to list comprehensions. {x: x**2 for x in range(3)} creates {0: 0, 1: 1, 2: 4} because it iterates over range(3) (0, 1, 2) and creates key-value pairs where the key is x and the value is x**2 (squared). This is useful for creating dictionaries from iterables.

Dictionary comprehension syntax:
• {x: x**2 for x in range(3)} = {0: 0, 1: 1, 2: 4}
• Syntax: {key: value for item in iterable}
• Iterates over range(3): x = 0, 1, 2
• Creates pairs: key=x, value=x**2

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• For each x, creates key-value pair: x: x**2
• 0: 0**2=0, 1: 1**2=1, 2: 2**2=4
• Results collected: {0: 0, 1: 1, 2: 4}

Example:
{x: x**2 for x in range(3)}    # {0: 0, 1: 1, 2: 4}
{x: x*2 for x in range(3)}     # {0: 0, 1: 2, 2: 4}

Common uses:
• Creating dictionaries: squares = {x: x**2 for x in range(n)}
• Key-value mappings
• Dictionary transformations
• Efficient dictionary creation

Example: {x: x**2 for x in range(3)} returns {0: 0, 1: 1, 2: 4} because it creates a dictionary with keys from range(3) and values as their squares.
`
  }),
  (_i: number) => ({ 
    q: `What is {x**2 for x in range(3)}?`, 
    o: ["{0, 1, 4}", "{0: 0, 1: 1, 2: 4}", "Error", "None"], 
    c: 0, 
    e: "Set comprehension.",
    de: `Set comprehensions create sets concisely, similar to list comprehensions but with curly braces and no colons. {x**2 for x in range(3)} creates {0, 1, 4} because it iterates over range(3) (0, 1, 2) and creates a set with x**2 (squared) values. Sets automatically remove duplicates and are unordered.

Set comprehension syntax:
• {x**2 for x in range(3)} = {0, 1, 4}
• Syntax: {expression for item in iterable}
• Note: No colon (:) - that's for dictionaries
• Iterates over range(3): x = 0, 1, 2
• Creates set with x**2 values

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• For each x, evaluates expression x**2
• 0**2=0, 1**2=1, 2**2=4
• Results collected into set: {0, 1, 4}
• Sets remove duplicates (if any)

Example:
{x**2 for x in range(3)}    # {0, 1, 4} (set)
{x**2 for x in [-1, 0, 1]}  # {0, 1} (duplicates removed)

Common uses:
• Creating sets: squares = {x**2 for x in range(n)}
• Unique value sets
• Set transformations
• Efficient set creation

Example: {x**2 for x in range(3)} returns {0, 1, 4} because it creates a set with the squared values from range(3).
`
  }),
  (_i: number) => ({ 
    q: `What is {x: x*2 for x in range(3)}?`, 
    o: ["{0: 0, 1: 2, 2: 4}", "{0, 2, 4}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with multiplication.",
    de: `Dictionary comprehensions can use any expression for both keys and values. {x: x*2 for x in range(3)} creates {0: 0, 1: 2, 2: 4} because it iterates over range(3) (0, 1, 2) and creates key-value pairs where the key is x and the value is x*2 (doubled). This demonstrates dictionary comprehensions with transformations.

Dictionary comprehension with transformation:
• {x: x*2 for x in range(3)} = {0: 0, 1: 2, 2: 4}
• Key: x (from range)
• Value: x*2 (doubled)
• Iterates: x = 0, 1, 2
• Creates pairs: 0:0, 1:2, 2:4

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• For each x, creates key-value pair: x: x*2
• 0: 0*2=0, 1: 1*2=2, 2: 2*2=4
• Results collected: {0: 0, 1: 2, 2: 4}

Example:
{x: x*2 for x in range(3)}     # {0: 0, 1: 2, 2: 4}
{x: x+1 for x in range(3)}     # {0: 1, 1: 2, 2: 3}

Common uses:
• Creating dictionaries: doubled = {x: x*2 for x in numbers}
• Value transformations
• Key-value mappings
• Dictionary generation

Example: {x: x*2 for x in range(3)} returns {0: 0, 1: 2, 2: 4} because it creates a dictionary with keys from range(3) and values as their doubles.
`
  }),
  (_i: number) => ({ 
    q: `What is {x for x in range(5) if x % 2 == 0}?`, 
    o: ["{0, 2, 4}", "{1, 3}", "{0, 1, 2, 3, 4}", "Error"], 
    c: 0, 
    e: "Set comprehension with filter.",
    de: `Set comprehensions can filter elements using if conditions, just like list comprehensions. {x for x in range(5) if x % 2 == 0} creates {0, 2, 4} because it iterates over range(5) (0, 1, 2, 3, 4) and includes only elements where x % 2 == 0 (even numbers). The if clause filters the elements before they're added to the set.

Set comprehension with filter:
• {x for x in range(5) if x % 2 == 0} = {0, 2, 4}
• Condition: x % 2 == 0 (even numbers)
• Iterates: x = 0, 1, 2, 3, 4
• Filters: includes only 0, 2, 4 (even)
• Results collected into set: {0, 2, 4}

How it works:
• for x in range(5) iterates: x = 0, 1, 2, 3, 4
• if x % 2 == 0 filters: keeps 0, 2, 4
• Results collected into set: {0, 2, 4}
• Only elements matching condition included

Example:
{x for x in range(5) if x % 2 == 0}  # {0, 2, 4} (even)
{x for x in range(5) if x > 2}        # {3, 4} (greater than 2)

Common uses:
• Filtering sets: evens = {x for x in numbers if x % 2 == 0}
• Conditional inclusion
• Element selection
• Set filtering

Example: {x for x in range(5) if x % 2 == 0} returns {0, 2, 4} because it filters range(5) to include only even numbers in the set.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: x for x in 'abc'}?`, 
    o: ["{'a': 'a', 'b': 'b', 'c': 'c'}", "{'a', 'b', 'c'}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with string.",
    de: `Dictionary comprehensions work with any iterable, including strings. {x: x for x in 'abc'} creates {'a': 'a', 'b': 'b', 'c': 'c'} because it iterates over the string 'abc' character by character, creating key-value pairs where both the key and value are the same character. This is useful for creating character-to-character mappings.

Dictionary comprehension with string:
• {x: x for x in 'abc'} = {'a': 'a', 'b': 'b', 'c': 'c'}
• Iterates over string 'abc': characters 'a', 'b', 'c'
• Creates pairs: key=x, value=x
• Each character becomes both key and value

How it works:
• for x in 'abc' iterates: x = 'a', 'b', 'c'
• For each character x, creates pair: x: x
• 'a': 'a', 'b': 'b', 'c': 'c'
• Results collected: {'a': 'a', 'b': 'b', 'c': 'c'}

Example:
{x: x for x in 'abc'}         # {'a': 'a', 'b': 'b', 'c': 'c'}
{x: x.upper() for x in 'abc'} # {'a': 'A', 'b': 'B', 'c': 'C'}

Common uses:
• Character mappings: identity = {c: c for c in string}
• String transformations
• Character-to-character mappings
• Dictionary generation from strings

Example: {x: x for x in 'abc'} returns {'a': 'a', 'b': 'b', 'c': 'c'} because it creates a dictionary with characters as both keys and values.
`
  }),
  (_i: number) => ({ 
    q: `What is {x.upper() for x in 'abc'}?`, 
    o: ["{'A', 'B', 'C'}", "{'a', 'b', 'c'}", "Error", "None"], 
    c: 0, 
    e: "Set comprehension with string method.",
    de: `Set comprehensions work with any iterable and can use method calls in the expression. {x.upper() for x in 'abc'} creates {'A', 'B', 'C'} because it iterates over the string 'abc' character by character, applies the .upper() method to each character (converting to uppercase), and collects the results into a set. This demonstrates set comprehensions with string transformations.

Set comprehension with string method:
• {x.upper() for x in 'abc'} = {'A', 'B', 'C'}
• Iterates over string 'abc': characters 'a', 'b', 'c'
• Applies .upper() to each: 'A', 'B', 'C'
• Results collected into set: {'A', 'B', 'C'}

How it works:
• for x in 'abc' iterates: x = 'a', 'b', 'c'
• For each character x, evaluates x.upper()
• 'a'.upper()='A', 'b'.upper()='B', 'c'.upper()='C'
• Results collected into set: {'A', 'B', 'C'}

Example:
{x.upper() for x in 'abc'}    # {'A', 'B', 'C'}
{x.lower() for x in 'ABC'}    # {'a', 'b', 'c'}

Common uses:
• String transformations: uppercase = {c.upper() for c in text}
• Character transformations
• Set generation from strings
• Method-based transformations

Example: {x.upper() for x in 'abc'} returns {'A', 'B', 'C'} because it creates a set with uppercase versions of each character.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: len(x) for x in ['a', 'ab', 'abc']}?`, 
    o: ["{'a': 1, 'ab': 2, 'abc': 3}", "{1, 2, 3}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with len().",
    de: `Dictionary comprehensions can use function calls in expressions. {x: len(x) for x in ['a', 'ab', 'abc']} creates {'a': 1, 'ab': 2, 'abc': 3} because it iterates over the list ['a', 'ab', 'abc'], creating key-value pairs where the key is the string and the value is its length. This is useful for creating mappings from strings to their lengths.

Dictionary comprehension with len():
• {x: len(x) for x in ['a', 'ab', 'abc']} = {'a': 1, 'ab': 2, 'abc': 3}
• Iterates over list: 'a', 'ab', 'abc'
• Creates pairs: key=x (string), value=len(x) (length)
• Maps each string to its length

How it works:
• for x in ['a', 'ab', 'abc'] iterates: x = 'a', 'ab', 'abc'
• For each string x, creates pair: x: len(x)
• 'a': len('a')=1, 'ab': len('ab')=2, 'abc': len('abc')=3
• Results collected: {'a': 1, 'ab': 2, 'abc': 3}

Example:
{x: len(x) for x in ['a', 'ab', 'abc']}  # {'a': 1, 'ab': 2, 'abc': 3}
{x: len(x) for x in ['hello', 'hi']}     # {'hello': 5, 'hi': 2}

Common uses:
• Length mappings: lengths = {s: len(s) for s in strings}
• String-to-number mappings
• Function-based transformations
• Dictionary generation with functions

Example: {x: len(x) for x in ['a', 'ab', 'abc']} returns {'a': 1, 'ab': 2, 'abc': 3} because it creates a dictionary mapping each string to its length.
`
  }),
  (_i: number) => ({ 
    q: `What is {x for x in 'hello'}?`, 
    o: ["{'h', 'e', 'l', 'o'}", "{'hello'}", "Error", "None"], 
    c: 0, 
    e: "Set comprehension removes duplicates.",
    de: `Set comprehensions automatically remove duplicate values because sets only contain unique elements. {x for x in 'hello'} creates {'h', 'e', 'l', 'o'} because it iterates over the string 'hello' character by character, but the set only contains unique characters. The string 'hello' has two 'l's, but the set contains only one 'l'. This is a key feature of sets.

Set comprehension removes duplicates:
• {x for x in 'hello'} = {'h', 'e', 'l', 'o'}
• String 'hello' has characters: 'h', 'e', 'l', 'l', 'o'
• Set contains unique characters only
• Duplicate 'l' is removed

How it works:
• for x in 'hello' iterates: x = 'h', 'e', 'l', 'l', 'o'
• Creates set with each character
• Sets only contain unique elements
• Duplicate 'l' appears only once: {'h', 'e', 'l', 'o'}

Example:
{x for x in 'hello'}     # {'h', 'e', 'l', 'o'} (duplicates removed)
{x for x in 'hello'}     # {'h', 'e', 'l', 'o'} (not {'h', 'e', 'l', 'l', 'o'})

Common uses:
• Removing duplicates: unique = {x for x in items}
• Finding unique values
• Deduplication
• Set generation with automatic deduplication

Example: {x for x in 'hello'} returns {'h', 'e', 'l', 'o'} because sets automatically remove duplicate values, so the two 'l's in 'hello' become one 'l' in the set.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: x*2 for x in range(3) if x > 0}?`, 
    o: ["{1: 2, 2: 4}", "{0: 0, 1: 2, 2: 4}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with filter.",
    de: `Dictionary comprehensions can combine filters with transformations. {x: x*2 for x in range(3) if x > 0} creates {1: 2, 2: 4} because it iterates over range(3) (0, 1, 2), filters to include only x > 0 (1, 2), and creates key-value pairs where the key is x and the value is x*2. The if clause filters elements before creating pairs.

Dictionary comprehension with filter:
• {x: x*2 for x in range(3) if x > 0} = {1: 2, 2: 4}
• Condition: x > 0 (positive numbers)
• Iterates: x = 0, 1, 2
• Filters: includes only 1, 2 (x > 0)
• Creates pairs: 1: 2, 2: 4

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• if x > 0 filters: keeps 1, 2 (excludes 0)
• For each remaining x, creates pair: x: x*2
• 1: 2, 2: 4
• Results collected: {1: 2, 2: 4}

Example:
{x: x*2 for x in range(3) if x > 0}   # {1: 2, 2: 4}
{x: x**2 for x in range(5) if x % 2 == 0}  # {0: 0, 2: 4, 4: 16}

Common uses:
• Filtered dictionaries: positive_doubled = {x: x*2 for x in numbers if x > 0}
• Conditional dictionary creation
• Filtered transformations
• Dictionary generation with filters

Example: {x: x*2 for x in range(3) if x > 0} returns {1: 2, 2: 4} because it filters range(3) to include only positive numbers, then creates pairs with doubled values.
`
  }),
  (_i: number) => ({ 
    q: `What is {x if x % 2 == 0 else x*2 for x in range(3)}?`, 
    o: ["{0, 2, 4}", "{0, 1, 2}", "Error", "None"], 
    c: 0, 
    e: "Set comprehension with conditional.",
    de: `Set comprehensions can use conditional expressions (ternary operators) in the expression part. {x if x % 2 == 0 else x*2 for x in range(3)} creates {0, 2, 4} because it iterates over range(3) (0, 1, 2) and uses conditional logic: if x is even (x % 2 == 0), use x, otherwise use x*2. The results are collected into a set. This demonstrates set comprehensions with conditional transformations.

Set comprehension with conditional:
• {x if x % 2 == 0 else x*2 for x in range(3)} = {0, 2, 4}
• Conditional: x if x % 2 == 0 else x*2
• Iterates: x = 0, 1, 2
• Applies conditional to each
• Results collected into set: {0, 2, 4}

How it works:
• for x in range(3) iterates: x = 0, 1, 2
• Conditional evaluated for each:
  - x=0: 0 % 2 == 0 → True → x = 0
  - x=1: 1 % 2 == 0 → False → x*2 = 2
  - x=2: 2 % 2 == 0 → True → x = 2
• Results collected into set: {0, 2, 4}

Example:
{x if x % 2 == 0 else x*2 for x in range(3)}  # {0, 2, 4}
{x*2 if x > 0 else x for x in range(3)}       # {0, 2, 4}

Common uses:
• Conditional sets: transformed = {x if condition else transform(x) for x in items}
• Element modification based on conditions
• Value selection
• Conditional set creation

Example: {x if x % 2 == 0 else x*2 for x in range(3)} returns {0, 2, 4} because it applies conditional logic to each element before adding to the set.
`
  }),
  
  // 81-90: Generator Expressions
  (_i: number) => ({ 
    q: `What is (x for x in range(3))?`, 
    o: ["generator object", "[0, 1, 2]", "Error", "None"], 
    c: 0, 
    e: "Generator expression syntax.",
    de: `Generator expressions create generator objects, similar to list comprehensions but using parentheses instead of square brackets. (x for x in range(3)) creates a generator object because it uses parentheses, not square brackets. Generator expressions are lazy - they don't create all values immediately, saving memory. They're useful for large sequences.

Generator expression syntax:
• (x for x in range(3)) = generator object
• Syntax: (expression for item in iterable)
• Uses parentheses (not square brackets)
• Creates generator object (not list)

How it works:
• (x for x in range(3)) creates generator
• Generator is lazy - doesn't compute values yet
• Values computed on-demand when iterated
• More memory-efficient than lists

Example:
gen = (x for x in range(3))
list(gen)  # [0, 1, 2] (consumes generator)

Common uses:
• Memory efficiency: gen = (x**2 for x in range(1000))
• Large sequences
• On-demand computation
• Lazy evaluation

Example: (x for x in range(3)) returns a generator object because it uses parentheses, creating a lazy iterator rather than a list.
`
  }),
  (_i: number) => ({ 
    q: `What is list((x for x in range(3)))?`, 
    o: ["[0, 1, 2]", "(0, 1, 2)", "Error", "None"], 
    c: 0, 
    e: "Generator expression converted to list.",
    de: `You can convert generator expressions to lists using list(). list((x for x in range(3))) creates [0, 1, 2] because it takes the generator expression (x for x in range(3)), which would generate 0, 1, 2, and converts it to a list by consuming all values from the generator. This is useful when you need an actual list instead of a generator.

Generator to list conversion:
• list((x for x in range(3))) = [0, 1, 2]
• Generator expression: (x for x in range(3))
• list() consumes generator
• Creates list with all values: [0, 1, 2]

How it works:
• (x for x in range(3)) creates generator
• list() iterates through generator
• Values generated: 0, 1, 2
• Results collected into list: [0, 1, 2]

Example:
list((x for x in range(3)))    # [0, 1, 2]
list((x**2 for x in range(3))) # [0, 1, 4]

Common uses:
• Converting generators to lists: numbers = list((x for x in range(n)))
• Materializing lazy sequences
• Getting all values from generator
• List creation from generators

Example: list((x for x in range(3))) returns [0, 1, 2] because list() consumes the generator expression and collects all values into a list.
`
  }),
  (_i: number) => ({ 
    q: `What is tuple((x for x in range(3)))?`, 
    o: ["(0, 1, 2)", "[0, 1, 2]", "Error", "None"], 
    c: 0, 
    e: "Generator expression converted to tuple.",
    de: `You can convert generator expressions to tuples using tuple(). tuple((x for x in range(3))) creates (0, 1, 2) because it takes the generator expression (x for x in range(3)), which would generate 0, 1, 2, and converts it to a tuple by consuming all values from the generator. This is useful when you need an immutable sequence instead of a list.

Generator to tuple conversion:
• tuple((x for x in range(3))) = (0, 1, 2)
• Generator expression: (x for x in range(3))
• tuple() consumes generator
• Creates tuple with all values: (0, 1, 2)

How it works:
• (x for x in range(3)) creates generator
• tuple() iterates through generator
• Values generated: 0, 1, 2
• Results collected into tuple: (0, 1, 2)

Example:
tuple((x for x in range(3)))    # (0, 1, 2)
tuple((x**2 for x in range(3))) # (0, 1, 4)

Common uses:
• Converting generators to tuples: numbers = tuple((x for x in range(n)))
• Materializing lazy sequences into tuples
• Creating immutable sequences
• Tuple creation from generators

Example: tuple((x for x in range(3))) returns (0, 1, 2) because tuple() consumes the generator expression and collects all values into a tuple.
`
  }),
  (_i: number) => ({ 
    q: `What is sum(x for x in range(3))?`, 
    o: ["3", "0", "Error", "None"], 
    c: 0, 
    e: "sum() with generator expression.",
    de: `The sum() function works with generator expressions directly, without converting to a list first. sum(x for x in range(3)) returns 3 because it iterates over the generator expression (x for x in range(3)), which generates 0, 1, 2, and sums them: 0 + 1 + 2 = 3. This is memory-efficient because it doesn't create an intermediate list.

sum() with generator:
• sum(x for x in range(3)) = 3
• Generator expression: (x for x in range(3))
• Generates values: 0, 1, 2
• Sum: 0 + 1 + 2 = 3
• No intermediate list created

How it works:
• (x for x in range(3)) creates generator
• sum() iterates through generator
• Values generated: 0, 1, 2
• Sum calculated: 0 + 1 + 2 = 3
• Returns 3

Example:
sum(x for x in range(3))      # 3 (0+1+2)
sum(x**2 for x in range(3))   # 5 (0+1+4)

Common uses:
• Summing sequences: total = sum(x for x in numbers)
• Memory-efficient summation
• Large sequence operations
• Direct generator consumption

Example: sum(x for x in range(3)) returns 3 because it sums the values generated by the generator expression (0 + 1 + 2 = 3).
`
  }),
  (_i: number) => ({ 
    q: `What is max(x for x in range(3))?`, 
    o: ["2", "3", "0", "Error"], 
    c: 0, 
    e: "max() with generator expression.",
    de: `The max() function works with generator expressions directly, without converting to a list first. max(x for x in range(3)) returns 2 because it iterates over the generator expression (x for x in range(3)), which generates 0, 1, 2, and finds the maximum: 2. This is memory-efficient because it doesn't create an intermediate list.

max() with generator:
• max(x for x in range(3)) = 2
• Generator expression: (x for x in range(3))
• Generates values: 0, 1, 2
• Maximum: 2
• No intermediate list created

How it works:
• (x for x in range(3)) creates generator
• max() iterates through generator
• Values generated: 0, 1, 2
• Maximum found: 2
• Returns 2

Example:
max(x for x in range(3))      # 2 (maximum)
max(x**2 for x in range(3))   # 4 (maximum square)

Common uses:
• Finding maximum: largest = max(x for x in numbers)
• Memory-efficient maximum finding
• Large sequence operations
• Direct generator consumption

Example: max(x for x in range(3)) returns 2 because it finds the maximum value generated by the generator expression (0, 1, 2).
`
  }),
  (_i: number) => ({ 
    q: `What is min(x for x in range(3))?`, 
    o: ["0", "1", "2", "Error"], 
    c: 0, 
    e: "min() with generator expression.",
    de: `The min() function works with generator expressions directly, without converting to a list first. min(x for x in range(3)) returns 0 because it iterates over the generator expression (x for x in range(3)), which generates 0, 1, 2, and finds the minimum: 0. This is memory-efficient because it doesn't create an intermediate list.

min() with generator:
• min(x for x in range(3)) = 0
• Generator expression: (x for x in range(3))
• Generates values: 0, 1, 2
• Minimum: 0
• No intermediate list created

How it works:
• (x for x in range(3)) creates generator
• min() iterates through generator
• Values generated: 0, 1, 2
• Minimum found: 0
• Returns 0

Example:
min(x for x in range(3))      # 0 (minimum)
min(x**2 for x in range(1, 4)) # 1 (minimum square)

Common uses:
• Finding minimum: smallest = min(x for x in numbers)
• Memory-efficient minimum finding
• Large sequence operations
• Direct generator consumption

Example: min(x for x in range(3)) returns 0 because it finds the minimum value generated by the generator expression (0, 1, 2).
`
  }),
  (_i: number) => ({ 
    q: `What is all(x > 0 for x in range(1, 3))?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "all() with generator expression.",
    de: `The all() function works with generator expressions and returns True only if all elements in the generator are truthy. all(x > 0 for x in range(1, 3)) returns True because it iterates over the generator expression (x > 0 for x in range(1, 3)), which generates True, True (since 1 > 0 and 2 > 0), and all() returns True when all values are truthy. This is memory-efficient.

all() with generator:
• all(x > 0 for x in range(1, 3)) = True
• Generator expression: (x > 0 for x in range(1, 3))
• Generates values: True, True (1>0, 2>0)
• all() checks if all are truthy: True
• Returns True

How it works:
• (x > 0 for x in range(1, 3)) creates generator
• Generates boolean values: True, True
• all() checks if all are truthy
• All are True, returns True
• Returns True

Example:
all(x > 0 for x in range(1, 3))  # True (all > 0)
all(x > 0 for x in range(0, 3))  # False (0 is not > 0)

Common uses:
• Validation: if all(x > 0 for x in numbers):
• Checking conditions
• Memory-efficient validation
• Large sequence validation

Example: all(x > 0 for x in range(1, 3)) returns True because all values in range(1, 3) (1, 2) are greater than 0.
`
  }),
  (_i: number) => ({ 
    q: `What is any(x > 2 for x in range(3))?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "any() with generator expression.",
    de: `The any() function works with generator expressions and returns True if any element in the generator is truthy. any(x > 2 for x in range(3)) returns False because it iterates over the generator expression (x > 2 for x in range(3)), which generates False, False, False (since 0 > 2, 1 > 2, and 2 > 2 are all False), and any() returns False when no values are truthy. This is memory-efficient.

any() with generator:
• any(x > 2 for x in range(3)) = False
• Generator expression: (x > 2 for x in range(3))
• Generates values: False, False, False (0>2, 1>2, 2>2)
• any() checks if any is truthy: False
• Returns False

How it works:
• (x > 2 for x in range(3)) creates generator
• Generates boolean values: False, False, False
• any() checks if any is truthy
• None are True, returns False
• Returns False

Example:
any(x > 2 for x in range(3))  # False (none > 2)
any(x > 1 for x in range(3))  # True (2 > 1)

Common uses:
• Checking existence: if any(x > 10 for x in numbers):
• Finding matches
• Memory-efficient checking
• Large sequence checking

Example: any(x > 2 for x in range(3)) returns False because none of the values in range(3) (0, 1, 2) are greater than 2.
`
  }),
  (_i: number) => ({ 
    q: `What is (x*2 for x in range(3))?`, 
    o: ["generator object", "[0, 2, 4]", "Error", "None"], 
    c: 0, 
    e: "Generator expression with transformation.",
    de: `Generator expressions can transform elements using expressions. (x*2 for x in range(3)) creates a generator object because it uses parentheses. When iterated, it generates 0, 2, 4 because it multiplies each element from range(3) (0, 1, 2) by 2. The transformation is applied lazily - values are computed on-demand, saving memory.

Generator expression with transformation:
• (x*2 for x in range(3)) = generator object
• Expression: x*2 (doubles each element)
• Iterates: x = 0, 1, 2
• Generates: 0, 2, 4 (on-demand)
• Creates generator (not list)

How it works:
• (x*2 for x in range(3)) creates generator
• Generator is lazy - doesn't compute values yet
• When iterated, generates: 0, 2, 4
• Transformation applied on-demand
• More memory-efficient than list

Example:
gen = (x*2 for x in range(3))
list(gen)  # [0, 2, 4] (consumes generator)

Common uses:
• Memory-efficient transformations: gen = (x*2 for x in large_sequence)
• Large sequence transformations
• On-demand computation
• Lazy evaluation

Example: (x*2 for x in range(3)) returns a generator object that, when iterated, generates 0, 2, 4 because it doubles each element from range(3).
`
  }),
  (_i: number) => ({ 
    q: `What is list((x*2 for x in range(3)))?`, 
    o: ["[0, 2, 4]", "(0, 2, 4)", "Error", "None"], 
    c: 0, 
    e: "Generator expression with transformation converted to list.",
    de: `You can convert generator expressions with transformations to lists. list((x*2 for x in range(3))) creates [0, 2, 4] because it takes the generator expression (x*2 for x in range(3)), which generates doubled values (0, 2, 4), and converts it to a list by consuming all values from the generator. This materializes the lazy generator into a concrete list.

Generator to list with transformation:
• list((x*2 for x in range(3))) = [0, 2, 4]
• Generator expression: (x*2 for x in range(3))
• Generates transformed values: 0, 2, 4
• list() consumes generator
• Creates list: [0, 2, 4]

How it works:
• (x*2 for x in range(3)) creates generator
• Generator transforms: 0→0, 1→2, 2→4
• list() iterates through generator
• Values collected: [0, 2, 4]
• Returns list

Example:
list((x*2 for x in range(3)))    # [0, 2, 4]
list((x**2 for x in range(3)))   # [0, 1, 4]

Common uses:
• Materializing generators: doubled = list((x*2 for x in numbers))
• Converting lazy sequences to lists
• Getting all transformed values
• List creation from generators

Example: list((x*2 for x in range(3))) returns [0, 2, 4] because list() consumes the generator expression and collects all doubled values into a list.
`
  }),
  
  // 91-100: Advanced Iteration
  (_i: number) => ({ 
    q: `What is list(map(lambda x: x*2, range(3)))?`, 
    o: ["[0, 2, 4]", "[0, 1, 2]", "Error", "None"], 
    c: 0, 
    e: "map() applies function to iterable.",
    de: `The map() function applies a function to every element of an iterable. list(map(lambda x: x*2, range(3))) creates [0, 2, 4] because map() applies the lambda function lambda x: x*2 (which doubles each value) to each element of range(3) (0, 1, 2). map() returns a map object, which list() converts to a list. This is equivalent to a list comprehension but using functional programming style.

map() function:
• list(map(lambda x: x*2, range(3))) = [0, 2, 4]
• map() applies function to each element
• Lambda: lambda x: x*2 (doubles each value)
• Iterates over range(3): 0, 1, 2
• Transforms: 0→0, 1→2, 2→4

How it works:
• map(lambda x: x*2, range(3)) creates map object
• Applies lambda to each element: 0*2=0, 1*2=2, 2*2=4
• Returns map object
• list() converts map to list: [0, 2, 4]

Example:
list(map(lambda x: x*2, range(3)))     # [0, 2, 4]
list(map(lambda x: x**2, range(3)))    # [0, 1, 4]
list(map(str, range(3)))               # ['0', '1', '2']

Common uses:
• Applying functions: doubled = list(map(lambda x: x*2, numbers))
• Function-based transformations
• Functional programming style
• Iterable transformations

Example: list(map(lambda x: x*2, range(3))) returns [0, 2, 4] because map() applies the lambda function (doubling) to each element of range(3).
`
  }),
  (_i: number) => ({ 
    q: `What is list(filter(lambda x: x % 2 == 0, range(5)))?`, 
    o: ["[0, 2, 4]", "[1, 3]", "[0, 1, 2, 3, 4]", "Error"], 
    c: 0, 
    e: "filter() keeps elements matching condition.",
    de: `The filter() function keeps only elements from an iterable that satisfy a condition. list(filter(lambda x: x % 2 == 0, range(5))) creates [0, 2, 4] because filter() applies the lambda function lambda x: x % 2 == 0 (which checks if a number is even) to each element of range(5) (0, 1, 2, 3, 4) and keeps only those where the condition is True. filter() returns a filter object, which list() converts to a list.

filter() function:
• list(filter(lambda x: x % 2 == 0, range(5))) = [0, 2, 4]
• filter() keeps elements where condition is True
• Lambda: lambda x: x % 2 == 0 (even check)
• Iterates over range(5): 0, 1, 2, 3, 4
• Filters: keeps 0, 2, 4 (even)

How it works:
• filter(lambda x: x % 2 == 0, range(5)) creates filter object
• Checks each element: 0%2==0→True, 1%2==0→False, 2%2==0→True, 3%2==0→False, 4%2==0→True
• Keeps only True cases: 0, 2, 4
• list() converts filter to list: [0, 2, 4]

Example:
list(filter(lambda x: x % 2 == 0, range(5)))  # [0, 2, 4] (even)
list(filter(lambda x: x > 2, range(5)))        # [3, 4] (greater than 2)

Common uses:
• Filtering elements: evens = list(filter(lambda x: x % 2 == 0, numbers))
• Conditional filtering
• Functional programming style
• Iterable filtering

Example: list(filter(lambda x: x % 2 == 0, range(5))) returns [0, 2, 4] because filter() keeps only elements from range(5) where x % 2 == 0 (even numbers).
`
  }),
  (_i: number) => ({ 
    q: `What is list(map(str, range(3)))?`, 
    o: ["['0', '1', '2']", "[0, 1, 2]", "Error", "None"], 
    c: 0, 
    e: "map() with type conversion.",
    de: `The map() function can use built-in functions like str() to convert types. list(map(str, range(3))) creates ['0', '1', '2'] because map() applies the str() function (which converts values to strings) to each element of range(3) (0, 1, 2). This converts each integer to its string representation. map() returns a map object, which list() converts to a list.

map() with type conversion:
• list(map(str, range(3))) = ['0', '1', '2']
• map() applies str() to each element
• str() converts integers to strings
• Iterates over range(3): 0, 1, 2
• Converts: 0→'0', 1→'1', 2→'2'

How it works:
• map(str, range(3)) creates map object
• Applies str() to each element: str(0)='0', str(1)='1', str(2)='2'
• Returns map object
• list() converts map to list: ['0', '1', '2']

Example:
list(map(str, range(3)))        # ['0', '1', '2']
list(map(int, ['1', '2', '3'])) # [1, 2, 3]

Common uses:
• Type conversion: strings = list(map(str, numbers))
• Converting types
• Functional programming style
• Iterable type conversion

Example: list(map(str, range(3))) returns ['0', '1', '2'] because map() applies str() to each element of range(3), converting integers to strings.
`
  }),
  (_i: number) => ({ 
    q: `What is list(filter(None, [0, 1, 2, '', 'a']))?`, 
    o: ["[1, 2, 'a']", "[0, 1, 2, '', 'a']", "Error", "None"], 
    c: 0, 
    e: "filter(None) removes Falsy values.",
    de: `When filter() is called with None as the first argument, it removes all falsy values from the iterable. list(filter(None, [0, 1, 2, '', 'a'])) creates [1, 2, 'a'] because filter(None, ...) removes falsy values (0, '', etc.) and keeps only truthy values (1, 2, 'a'). This is a common pattern for removing falsy values without writing a lambda.

filter(None) behavior:
• list(filter(None, [0, 1, 2, '', 'a'])) = [1, 2, 'a']
• filter(None, ...) removes falsy values
• Falsy values: 0, '' (empty string)
• Truthy values: 1, 2, 'a'
• Keeps only truthy values

How it works:
• filter(None, [0, 1, 2, '', 'a']) creates filter object
• Checks each element: 0→False, 1→True, 2→True, ''→False, 'a'→True
• Keeps only truthy: 1, 2, 'a'
• list() converts filter to list: [1, 2, 'a']

Example:
list(filter(None, [0, 1, 2, '', 'a']))  # [1, 2, 'a'] (falsy removed)
list(filter(None, [0, None, '', 'a']))   # ['a'] (falsy removed)

Common uses:
• Removing falsy values: truthy = list(filter(None, items))
• Cleaning data
• Removing None/empty values
• Quick falsy filtering

Example: list(filter(None, [0, 1, 2, '', 'a'])) returns [1, 2, 'a'] because filter(None, ...) removes falsy values (0, '') and keeps only truthy values (1, 2, 'a').
`
  }),
  (_i: number) => ({ 
    q: `What is next(iter(range(3)))?`, 
    o: ["0", "1", "Error", "None"], 
    c: 0, 
    e: "next() gets next value from iterator.",
    de: `The next() function retrieves the next value from an iterator. next(iter(range(3))) returns 0 because iter(range(3)) creates an iterator from range(3), and next() retrieves the first value from that iterator (0). Each call to next() advances the iterator to the next value. This is useful for manual iteration and consuming values one at a time.

next() function:
• next(iter(range(3))) = 0
• iter(range(3)) creates iterator from range(3)
• next() retrieves first value from iterator
• Returns 0 (first value)
• Iterator advances to next value

How it works:
• iter(range(3)) creates iterator
• Iterator points to first value: 0
• next() retrieves current value: 0
• Iterator advances to next value: 1
• Returns 0

Example:
it = iter(range(3))
next(it)  # 0 (first value)
next(it)  # 1 (second value)
next(it)  # 2 (third value)

Common uses:
• Manual iteration: value = next(iterator)
• Consuming values one at a time
• Iterator control
• Step-by-step iteration

Example: next(iter(range(3))) returns 0 because next() retrieves the first value from the iterator created from range(3).
`
  }),
  (_i: number) => ({ 
    q: `What is iter([1, 2, 3])?`, 
    o: ["list_iterator object", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "iter() creates iterator from iterable.",
    de: `The iter() function creates an iterator from an iterable. iter([1, 2, 3]) returns a list_iterator object because it takes the list [1, 2, 3] and creates an iterator object that can be used to iterate over the list one element at a time. Iterators allow manual control over iteration and are used by for loops internally. The iterator remembers its position and can be advanced with next().

iter() function:
• iter([1, 2, 3]) = list_iterator object
• Creates iterator from iterable [1, 2, 3]
• Returns iterator object (not list)
• Iterator can be used with next() or for loop

How it works:
• iter([1, 2, 3]) takes list
• Creates iterator object
• Iterator points to first element: 1
• Iterator remembers position
• Can be advanced with next()

Example:
it = iter([1, 2, 3])
type(it)  # <class 'list_iterator'>
next(it)  # 1 (first element)
next(it)  # 2 (second element)

Common uses:
• Creating iterators: it = iter(collection)
• Manual iteration control
• Iterator objects
• Step-by-step iteration

Example: iter([1, 2, 3]) returns a list_iterator object because it creates an iterator from the list [1, 2, 3] that can be used for manual iteration.
`
  }),
  (_i: number) => ({ 
    q: `What is list(iter([1, 2, 3]))?`, 
    o: ["[1, 2, 3]", "list_iterator object", "Error", "None"], 
    c: 0, 
    e: "list() consumes iterator.",
    de: `The list() function can consume an iterator, creating a list with all remaining values from the iterator. list(iter([1, 2, 3])) creates [1, 2, 3] because it takes the iterator created from [1, 2, 3], iterates through it completely, and collects all values into a list. This exhausts the iterator (consumes all values), which is useful for converting iterators back to lists.

list() with iterator:
• list(iter([1, 2, 3])) = [1, 2, 3]
• iter([1, 2, 3]) creates iterator
• list() iterates through iterator
• Collects all values: 1, 2, 3
• Creates list: [1, 2, 3]

How it works:
• iter([1, 2, 3]) creates iterator
• list() iterates through iterator completely
• Values retrieved: 1, 2, 3
• Results collected into list: [1, 2, 3]
• Iterator is exhausted

Example:
it = iter([1, 2, 3])
list(it)  # [1, 2, 3] (consumes iterator)
list(it)  # [] (iterator exhausted)

Common uses:
• Converting iterators to lists: items = list(iter(collection))
• Materializing iterators
• Getting all values from iterator
• Iterator consumption

Example: list(iter([1, 2, 3])) returns [1, 2, 3] because list() consumes the iterator and collects all values into a list.
`
  }),
  (_i: number) => ({ 
    q: `What is sum([1, 2, 3])?`, 
    o: ["6", "0", "Error", "None"], 
    c: 0, 
    e: "sum() adds all elements in iterable.",
    de: `The sum() function adds all elements in an iterable (list, tuple, range, etc.) and returns the total. sum([1, 2, 3]) returns 6 because it iterates over the list [1, 2, 3] and adds all values: 1 + 2 + 3 = 6. sum() works with any iterable containing numbers and is commonly used for calculating totals.

sum() function:
• sum([1, 2, 3]) = 6
• Iterates over list [1, 2, 3]
• Adds all values: 1 + 2 + 3 = 6
• Returns total: 6

How it works:
• sum([1, 2, 3]) takes list
• Iterates through elements: 1, 2, 3
• Adds values: 1 + 2 + 3
• Returns total: 6

Example:
sum([1, 2, 3])       # 6 (1+2+3)
sum(range(5))        # 10 (0+1+2+3+4)
sum([1.5, 2.5, 3.5]) # 7.5 (floats work)

Common uses:
• Summing numbers: total = sum(numbers)
• Calculating totals
• Aggregating values
• Number operations

Example: sum([1, 2, 3]) returns 6 because it adds all elements in the list (1 + 2 + 3 = 6).
`
  }),
  (_i: number) => ({ 
    q: `What is all([True, True, False])?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "all() returns True only if all elements are Truthy.",
    de: `The all() function returns True only if all elements in an iterable are truthy. all([True, True, False]) returns False because it checks each element: True (truthy), True (truthy), False (falsy). Since not all elements are truthy (False is falsy), all() returns False. If all elements were truthy, it would return True.

all() function:
• all([True, True, False]) = False
• Checks each element: True, True, False
• All must be truthy for True result
• False is falsy, so returns False
• Returns False

How it works:
• all([True, True, False]) takes list
• Checks each element: True (truthy), True (truthy), False (falsy)
• Short-circuits at first falsy value
• Returns False (not all truthy)

Example:
all([True, True, False])  # False (not all truthy)
all([True, True, True])   # True (all truthy)
all([1, 2, 3])            # True (all numbers are truthy)

Common uses:
• Validation: if all(conditions): ...
• Checking if all elements satisfy condition
• Boolean logic
• Iterable validation

Example: all([True, True, False]) returns False because not all elements are truthy (False is falsy).
`
  }),
  (_i: number) => ({ 
    q: `What is any([False, False, True])?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "any() returns True if any element is Truthy.",
    de: `The any() function returns True if any element in an iterable is truthy. any([False, False, True]) returns True because it checks each element: False (falsy), False (falsy), True (truthy). Since at least one element is truthy (True is truthy), any() returns True. If all elements were falsy, it would return False.

any() function:
• any([False, False, True]) = True
• Checks each element: False, False, True
• At least one must be truthy for True result
• True is truthy, so returns True
• Returns True

How it works:
• any([False, False, True]) takes list
• Checks each element: False (falsy), False (falsy), True (truthy)
• Short-circuits at first truthy value
• Returns True (at least one truthy)

Example:
any([False, False, True])  # True (at least one truthy)
any([False, False, False]) # False (all falsy)
any([0, 0, 1])             # True (1 is truthy)

Common uses:
• Checking existence: if any(conditions): ...
• Finding if any element satisfies condition
• Boolean logic
• Iterable checking

Example: any([False, False, True]) returns True because at least one element is truthy (True is truthy).
`
  }),
];

// --- LEVEL 5: OCTOPUS (Lists, Arrays, Indexing) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level5Patterns = [
  // 1-10: List Creation and Basics
  (_i: number) => ({ 
    q: `What is [1, 2, 3]?`, 
    o: ["A list", "A tuple", "A dictionary", "A set"], 
    c: 0, 
    e: "Square brackets create a list.",
    de: `Square brackets [] create a list in Python. [1, 2, 3] is a list containing three integers: 1, 2, and 3. Lists are ordered, mutable sequences that can contain elements of any type, including mixed types. This is one of Python's most fundamental data structures.

List creation:
• [1, 2, 3] = list with elements 1, 2, 3
• Square brackets [] are the list literal syntax
• Lists are ordered (elements have a defined order)
• Lists are mutable (can be modified after creation)
• Lists can contain any type of element

How it works:
• Python recognizes [] as list literal syntax
• Elements inside are separated by commas
• Creates a list object in memory
• Elements are indexed starting from 0
• Returns a list type

Example:
[1, 2, 3]           # List of integers
['a', 'b', 'c']     # List of strings
[1, 'a', 3.14]      # Mixed types allowed
[]                  # Empty list

Common uses:
• Storing sequences: numbers = [1, 2, 3]
• Collecting data: names = ['Alice', 'Bob']
• Managing ordered collections
• Data structures and algorithms

Example: [1, 2, 3] creates a list object containing three integers, which is Python's primary ordered, mutable sequence type.
`
  }),
  (_i: number) => ({ 
    q: `What is list([1, 2, 3])?`, 
    o: ["[1, 2, 3]", "(1, 2, 3)", "{1, 2, 3}", "Error"], 
    c: 0, 
    e: "list() constructor creates a list.",
    de: `The list() constructor creates a list from an iterable. list([1, 2, 3]) creates a new list [1, 2, 3] from the existing list [1, 2, 3]. This is essentially creating a shallow copy - a new list object with the same elements. The list() constructor accepts any iterable (list, tuple, string, range, etc.) and converts it to a list.

list() constructor:
• list([1, 2, 3]) = [1, 2, 3] (new list)
• list() creates a list from an iterable
• Creates a shallow copy of the input
• Works with any iterable type
• Returns a list object

How it works:
• list() takes an iterable as argument
• Iterates through the iterable
• Creates new list with elements from iterable
• Returns new list object
• Original iterable unchanged (if immutable)

Example:
list([1, 2, 3])      # [1, 2, 3] (shallow copy)
list((1, 2, 3))      # [1, 2, 3] (from tuple)
list('abc')          # ['a', 'b', 'c'] (from string)
list(range(3))       # [0, 1, 2] (from range)

Common uses:
• Converting iterables: list(tuple_data)
• Creating copies: new_list = list(old_list)
• Converting generators to lists
• Type conversion

Example: list([1, 2, 3]) returns [1, 2, 3] because list() creates a new list object from the iterable [1, 2, 3], which in this case results in a shallow copy.
`
  }),
  (_i: number) => ({ 
    q: `What is []?`, 
    o: ["Empty list", "Error", "None", "Empty tuple"], 
    c: 0, 
    e: "Empty list literal.",
    de: `Empty square brackets [] create an empty list in Python. [] is a list literal that contains no elements. Empty lists are falsy in boolean contexts (they evaluate to False), but they are still valid list objects. Empty lists are useful as placeholders or starting points for building lists dynamically.

Empty list:
• [] = empty list (no elements)
• Square brackets with nothing inside
• Valid list object, just has zero length
• Falsy in boolean contexts: bool([]) = False
• Length is 0: len([]) = 0

How it works:
• Python recognizes [] as empty list literal
• Creates a list object with no elements
• Still a valid list type
• Can be used immediately for operations
• Returns empty list object

Example:
[]                   # Empty list
bool([])             # False (falsy)
len([])              # 0 (zero length)
[].append(1)         # [1] (can add elements)

Common uses:
• Initialization: result = []
• Placeholders: data = []
• Starting points for building lists
• Return values for empty results

Example: [] creates an empty list object, which is a valid list with zero elements and length 0.
`
  }),
  (_i: number) => ({ 
    q: `What is list()?`, 
    o: ["[]", "()", "{}", "Error"], 
    c: 0, 
    e: "list() with no arguments creates empty list.",
    de: `Calling list() with no arguments creates an empty list, equivalent to []. list() is the constructor function that creates lists, and when called without arguments, it creates an empty list object. This is functionally identical to using the empty list literal [].

list() with no arguments:
• list() = [] (empty list)
• Constructor function with no arguments
• Creates empty list object
• Equivalent to [] literal
• Returns empty list

How it works:
• list() called without arguments
• Creates new empty list object
• Returns empty list: []
• Same result as [] literal
• Ready for operations

Example:
list()               # [] (empty list)
list() == []         # True (equivalent)
len(list())          # 0 (zero length)
list().append(1)     # [1] (can add elements)

Common uses:
• Creating empty lists: items = list()
• Initialization: data = list()
• Alternative to [] literal
• Constructor syntax preference

Example: list() returns [] because calling the list constructor without arguments creates an empty list object, which is equivalent to the empty list literal [].
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][0]?`, 
    o: ["1", "2", "3", "Error"], 
    c: 0, 
    e: "List indexing starts at 0.",
    de: `List indexing in Python starts at 0, not 1. [1, 2, 3][0] returns 1 because index 0 refers to the first element in the list. Python uses zero-based indexing, meaning the first element is at index 0, the second at index 1, and so on. This is consistent across all sequence types in Python.

List indexing:
• [1, 2, 3][0] = 1 (first element)
• Index 0 is the first element
• Python uses zero-based indexing
• Access elements using square brackets after list
• Returns the element at that index

How it works:
• [1, 2, 3] is the list
• [0] is the index in square brackets
• Index 0 refers to first element
• Returns value at that position: 1
• Index must be valid (0 to len-1)

Example:
[1, 2, 3][0]         # 1 (first element)
[1, 2, 3][1]         # 2 (second element)
[1, 2, 3][2]         # 3 (third element)
[1, 2, 3][3]         # IndexError (out of bounds)

Common uses:
• Accessing elements: first = my_list[0]
• Reading values: value = items[index]
• Sequence access
• Array-like operations

Example: [1, 2, 3][0] returns 1 because index 0 refers to the first element in the list (Python uses zero-based indexing).
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][1]?`, 
    o: ["2", "1", "3", "Error"], 
    c: 0, 
    e: "Index 1 gets second element.",
    de: `Index 1 gets the second element in a list because Python uses zero-based indexing. [1, 2, 3][1] returns 2 because index 1 refers to the second element (the first element is at index 0). This is the standard indexing convention across all Python sequence types.

Index 1 (second element):
• [1, 2, 3][1] = 2 (second element)
• Index 0 = first element (1)
• Index 1 = second element (2)
• Index 2 = third element (3)
• Zero-based indexing system

How it works:
• [1, 2, 3] contains elements at indices 0, 1, 2
• [1] accesses element at index 1
• Index 1 refers to second element
• Returns value at that position: 2
• Valid index range: 0 to len-1

Example:
[1, 2, 3][1]         # 2 (second element)
['a', 'b', 'c'][1]   # 'b' (second element)
[10, 20, 30][1]      # 20 (second element)

Common uses:
• Accessing second element: second = items[1]
• Reading by position: value = data[1]
• Sequence indexing
• Array-like access

Example: [1, 2, 3][1] returns 2 because index 1 refers to the second element in the list (since indexing starts at 0).
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][-1]?`, 
    o: ["3", "1", "2", "Error"], 
    c: 0, 
    e: "Negative indexing starts from the end.",
    de: `Negative indexing in Python allows you to access elements from the end of a list. [1, 2, 3][-1] returns 3 because index -1 refers to the last element. Negative indices count backwards from the end: -1 is the last element, -2 is the second-to-last, and so on. This is a convenient way to access elements from the end without knowing the list length.

Negative indexing:
• [1, 2, 3][-1] = 3 (last element)
• -1 = last element
• -2 = second-to-last element
• -3 = third-to-last element
• Counts backwards from end

How it works:
• [1, 2, 3] has elements at indices 0, 1, 2
• [-1] accesses from the end
• -1 refers to last element (index 2)
• Returns value at that position: 3
• Negative indices: -1, -2, -3, etc.

Example:
[1, 2, 3][-1]        # 3 (last element)
[1, 2, 3][-2]        # 2 (second-to-last)
[1, 2, 3][-3]        # 1 (third-to-last)
['a', 'b', 'c'][-1]  # 'c' (last element)

Common uses:
• Accessing last element: last = items[-1]
• Getting end elements: second_last = data[-2]
• Convenient end access
• No need to know length

Example: [1, 2, 3][-1] returns 3 because negative index -1 refers to the last element in the list, counting backwards from the end.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][-2]?`, 
    o: ["2", "1", "3", "Error"], 
    c: 0, 
    e: "Negative index -2 gets second from end.",
    de: `Negative index -2 gets the second-to-last element in a list. [1, 2, 3][-2] returns 2 because index -2 refers to the second element from the end (the last element is at -1). Negative indexing counts backwards from the end of the list, making it convenient to access elements without knowing the exact length.

Negative index -2:
• [1, 2, 3][-2] = 2 (second-to-last)
• -1 = last element (3)
• -2 = second-to-last element (2)
• -3 = third-to-last element (1)
• Counts backwards from end

How it works:
• [1, 2, 3] has elements at indices 0, 1, 2
• [-2] accesses from the end
• -2 refers to second-to-last element (index 1)
• Returns value at that position: 2
• Negative indices count backwards

Example:
[1, 2, 3][-2]        # 2 (second-to-last)
[1, 2, 3, 4][-2]     # 3 (second-to-last)
['a', 'b', 'c'][-2]  # 'b' (second-to-last)

Common uses:
• Accessing second-to-last: penultimate = items[-2]
• Getting elements from end: value = data[-2]
• Convenient end access
• No need to calculate index

Example: [1, 2, 3][-2] returns 2 because negative index -2 refers to the second-to-last element in the list, counting backwards from the end.
`
  }),
  (_i: number) => ({ 
    q: `What is len([1, 2, 3])?`, 
    o: ["3", "2", "1", "Error"], 
    c: 0, 
    e: "len() returns the number of elements.",
    de: `The len() function returns the number of elements in a list (or any sequence/collection). len([1, 2, 3]) returns 3 because the list contains three elements. len() is a built-in function that works with all sequence types (lists, tuples, strings) and collection types (dictionaries, sets).

len() function:
• len([1, 2, 3]) = 3 (number of elements)
• Returns the length (size) of the sequence
• Works with lists, tuples, strings, dicts, sets
• Returns integer count of elements
• Empty sequences return 0

How it works:
• len() takes a sequence or collection as argument
• Counts the number of elements
• Returns integer value
• For [1, 2, 3]: counts 1, 2, 3 → 3
• Returns 3

Example:
len([1, 2, 3])       # 3 (three elements)
len([])              # 0 (empty list)
len(['a', 'b'])      # 2 (two elements)
len([1, 2, 3, 4, 5]) # 5 (five elements)

Common uses:
• Checking size: if len(items) > 0:
• Getting count: count = len(data)
• Size validation
• Iteration bounds

Example: len([1, 2, 3]) returns 3 because the list contains three elements, and len() counts and returns the number of elements in the sequence.
`
  }),
  (_i: number) => ({ 
    q: `What is len([])?`, 
    o: ["0", "1", "Error", "None"], 
    c: 0, 
    e: "Empty list has length 0.",
    de: `An empty list has a length of 0 because it contains no elements. len([]) returns 0 because the empty list [] has zero elements. len() counts the number of elements in a sequence, and an empty sequence naturally has zero elements. Empty lists are falsy in boolean contexts but are still valid list objects.

Empty list length:
• len([]) = 0 (zero elements)
• Empty list contains no elements
• Length is 0 by definition
• Valid list object, just empty
• Falsy but exists

How it works:
• len() takes empty list [] as argument
• Counts elements in the list
• Finds zero elements
• Returns 0
• Empty sequences always return 0

Example:
len([])              # 0 (empty list)
len(list())          # 0 (empty list)
bool([])             # False (falsy but exists)
[].append(1)         # [1] (can add elements)

Common uses:
• Checking if empty: if len(items) == 0:
• Validation: if len(data) > 0:
• Empty check
• Size verification

Example: len([]) returns 0 because the empty list contains zero elements, and len() counts and returns the number of elements (which is 0 for an empty list).
`
  }),
  
  // 11-20: List Slicing
  (_i: number) => ({ 
    q: `What is [1, 2, 3, 4][1:3]?`, 
    o: ["[2, 3]", "[1, 2]", "[2, 3, 4]", "Error"], 
    c: 0, 
    e: "Slicing [1:3] gets elements from index 1 to 2 (exclusive).",
    de: `List slicing uses the syntax [start:stop] to extract a portion of a list. [1, 2, 3, 4][1:3] returns [2, 3] because slicing is exclusive of the stop index - it includes elements from index 1 up to (but not including) index 3. The start index is inclusive, but the stop index is exclusive.

List slicing [start:stop]:
• [1, 2, 3, 4][1:3] = [2, 3]
• Start index 1 is inclusive (includes element at index 1)
• Stop index 3 is exclusive (excludes element at index 3)
• Returns elements at indices 1 and 2
• Creates new list with those elements

How it works:
• List [1, 2, 3, 4] has indices 0, 1, 2, 3
• [1:3] means start at index 1, stop before index 3
• Includes indices 1 and 2: [2, 3]
• Excludes index 3 (stop is exclusive)
• Returns new list: [2, 3]

Example:
[1, 2, 3, 4][1:3]   # [2, 3] (indices 1, 2)
[1, 2, 3, 4][0:2]   # [1, 2] (indices 0, 1)
[1, 2, 3, 4][2:4]   # [3, 4] (indices 2, 3)

Common uses:
• Extracting sublists: sub = items[1:3]
• Getting ranges: middle = data[start:end]
• Partial lists
• Sequence extraction

Example: [1, 2, 3, 4][1:3] returns [2, 3] because slicing includes elements from index 1 (inclusive) up to index 3 (exclusive), which are the elements at indices 1 and 2.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3, 4][:2]?`, 
    o: ["[1, 2]", "[2, 3]", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "Slicing [:2] gets first 2 elements.",
    de: `When the start index is omitted in slicing, it defaults to 0 (the beginning). [1, 2, 3, 4][:2] returns [1, 2] because [:2] means "from the start up to (but not including) index 2", which gives the first two elements. This is a common pattern for getting the first N elements of a list.

Slicing with omitted start:
• [1, 2, 3, 4][:2] = [1, 2]
• Omitted start defaults to 0 (beginning)
• Stop index 2 is exclusive
• Returns elements from start to index 1
• Gets first 2 elements

How it works:
• [:2] means start at 0 (default), stop before 2
• Includes indices 0 and 1: [1, 2]
• Excludes index 2 (stop is exclusive)
• Returns new list: [1, 2]
• Common pattern for "first N elements"

Example:
[1, 2, 3, 4][:2]    # [1, 2] (first 2)
[1, 2, 3, 4][:3]    # [1, 2, 3] (first 3)
[1, 2, 3, 4][:1]    # [1] (first 1)

Common uses:
• First N elements: first_two = items[:2]
• Getting prefix: prefix = data[:n]
• Initial elements
• Beginning of list

Example: [1, 2, 3, 4][:2] returns [1, 2] because omitting the start index defaults to 0, so it gets elements from the beginning up to (but not including) index 2, which are the first two elements.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3, 4][2:]?`, 
    o: ["[3, 4]", "[1, 2]", "[2, 3]", "Error"], 
    c: 0, 
    e: "Slicing [2:] gets from index 2 to end.",
    de: `When the stop index is omitted in slicing, it defaults to the end of the list. [1, 2, 3, 4][2:] returns [3, 4] because [2:] means "from index 2 to the end", which includes all elements from index 2 onwards. This is a common pattern for getting the last N elements or everything after a certain point.

Slicing with omitted stop:
• [1, 2, 3, 4][2:] = [3, 4]
• Start index 2 is inclusive
• Omitted stop defaults to end of list
• Returns elements from index 2 to end
• Gets remaining elements

How it works:
• [2:] means start at index 2, go to end
• Includes indices 2 and 3: [3, 4]
• No stop means include all to end
• Returns new list: [3, 4]
• Common pattern for "from index N to end"

Example:
[1, 2, 3, 4][2:]    # [3, 4] (from index 2)
[1, 2, 3, 4][1:]    # [2, 3, 4] (from index 1)
[1, 2, 3, 4][3:]    # [4] (from index 3)

Common uses:
• From index to end: rest = items[2:]
• Getting suffix: suffix = data[n:]
• Remaining elements
• End of list

Example: [1, 2, 3, 4][2:] returns [3, 4] because omitting the stop index defaults to the end of the list, so it gets all elements from index 2 (inclusive) to the end.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3, 4][::2]?`, 
    o: ["[1, 3]", "[2, 4]", "[1, 2]", "Error"], 
    c: 0, 
    e: "Slicing [::2] gets every 2nd element.",
    de: `Slicing with a step value uses the syntax [start:stop:step]. [1, 2, 3, 4][::2] returns [1, 3] because [::2] means "from start to end, taking every 2nd element". The step value determines the interval between selected elements. When start and stop are omitted, it uses the entire list.

Slicing with step:
• [1, 2, 3, 4][::2] = [1, 3]
• [::2] means start=0, stop=end, step=2
• Takes every 2nd element (skips one between)
• Returns elements at indices 0, 2: [1, 3]
• Step determines interval

How it works:
• [::2] means: start at 0, stop at end, step by 2
• Takes elements at indices 0, 2: [1, 3]
• Skips indices 1, 3 (every 2nd means skip one)
• Returns new list: [1, 3]
• Step of 2 means take every other element

Example:
[1, 2, 3, 4][::2]   # [1, 3] (every 2nd)
[1, 2, 3, 4][::1]    # [1, 2, 3, 4] (every element)
[1, 2, 3, 4, 5][::2] # [1, 3, 5] (every 2nd)

Common uses:
• Every Nth element: evens = items[::2]
• Skipping elements: sampled = data[::n]
• Interval selection
• Pattern extraction

Example: [1, 2, 3, 4][::2] returns [1, 3] because the step value of 2 means taking every 2nd element from the start to the end, which selects elements at indices 0 and 2.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3, 4][::-1]?`, 
    o: ["[4, 3, 2, 1]", "[1, 2, 3, 4]", "[1]", "Error"], 
    c: 0, 
    e: "Slicing [::-1] reverses the list.",
    de: `A negative step value in slicing reverses the order. [1, 2, 3, 4][::-1] returns [4, 3, 2, 1] because [::-1] means "from end to start, step by -1", which effectively reverses the list. When start and stop are omitted with a negative step, it defaults to the entire list in reverse order.

Reversing with negative step:
• [1, 2, 3, 4][::-1] = [4, 3, 2, 1]
• [::-1] means start=end, stop=start, step=-1
• Negative step reverses direction
• Returns elements in reverse order
• Common way to reverse a list

How it works:
• [::-1] means: start at end, stop at start, step by -1
• Goes backwards through the list
• Takes elements in reverse: 4, 3, 2, 1
• Returns new reversed list: [4, 3, 2, 1]
• Original list unchanged

Example:
[1, 2, 3, 4][::-1]   # [4, 3, 2, 1] (reversed)
[1, 2, 3][::-1]      # [3, 2, 1] (reversed)
['a', 'b'][::-1]     # ['b', 'a'] (reversed)

Common uses:
• Reversing list: reversed_list = items[::-1]
• Creating reverse copy: rev = data[::-1]
• Reverse iteration
• Backwards sequence

Example: [1, 2, 3, 4][::-1] returns [4, 3, 2, 1] because a negative step value of -1 reverses the direction, creating a new list with elements in reverse order.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3, 4][1:-1]?`, 
    o: ["[2, 3]", "[1, 2, 3]", "[2, 3, 4]", "Error"], 
    c: 0, 
    e: "Slicing [1:-1] excludes first and last.",
    de: `Slicing with negative indices combines positive start with negative stop. [1, 2, 3, 4][1:-1] returns [2, 3] because [1:-1] means "from index 1 to the second-to-last element (exclusive)". This effectively excludes both the first element (index 0) and the last element (index -1), giving you the middle elements.

Slicing with negative stop:
• [1, 2, 3, 4][1:-1] = [2, 3]
• Start index 1 is inclusive
• Stop index -1 is exclusive (excludes last element)
• Returns elements at indices 1 and 2
• Excludes first (index 0) and last (index -1)

How it works:
• [1:-1] means start at index 1, stop before index -1
• Index -1 is the last element (exclusive)
• Includes indices 1 and 2: [2, 3]
• Excludes index 0 (first) and index -1 (last)
• Returns middle elements: [2, 3]

Example:
[1, 2, 3, 4][1:-1]  # [2, 3] (excludes first and last)
[1, 2, 3, 4, 5][1:-1] # [2, 3, 4] (excludes first and last)
[1, 2][1:-1]         # [] (nothing left)

Common uses:
• Excluding ends: middle = items[1:-1]
• Getting inner elements: inner = data[1:-1]
• Removing first and last
• Middle portion

Example: [1, 2, 3, 4][1:-1] returns [2, 3] because it starts at index 1 (inclusive) and stops before index -1 (exclusive), which excludes both the first and last elements, leaving the middle elements.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][:]?`, 
    o: ["[1, 2, 3]", "[]", "[1]", "Error"], 
    c: 0, 
    e: "Slicing [:] creates a shallow copy.",
    de: `Slicing with both start and stop omitted [:] creates a shallow copy of the entire list. [1, 2, 3][:] returns [1, 2, 3] because [:] means "from start to end", which includes all elements. This creates a new list object with the same elements, but it's a shallow copy - nested objects are still shared.

Shallow copy with [:]:
• [1, 2, 3][:] = [1, 2, 3] (new list, same elements)
• [:] means start=0, stop=end (all elements)
• Creates new list object
• Copies all elements to new list
• Shallow copy (nested objects shared)

How it works:
• [:] means: start at 0, stop at end
• Includes all elements: 1, 2, 3
• Creates new list object
• Copies elements to new list: [1, 2, 3]
• New list, but shallow copy

Example:
[1, 2, 3][:]        # [1, 2, 3] (shallow copy)
a = [1, 2, 3]
b = a[:]            # b is new list, but shallow copy
a is b              # False (different objects)

Common uses:
• Creating copy: copy = items[:]
• Shallow copy: new_list = data[:]
• Duplicating list
• Independent list object

Example: [1, 2, 3][:] returns [1, 2, 3] because [:] creates a shallow copy of the entire list, resulting in a new list object with the same elements.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3, 4, 5][1:4:2]?`, 
    o: ["[2, 4]", "[1, 3]", "[2, 3, 4]", "Error"], 
    c: 0, 
    e: "Slicing [1:4:2] gets every 2nd from index 1 to 3.",
    de: `Slicing with start, stop, and step uses [start:stop:step]. [1, 2, 3, 4, 5][1:4:2] returns [2, 4] because it starts at index 1, stops before index 4, and takes every 2nd element. This combines a range with a step interval to select specific elements.

Slicing with start, stop, step:
• [1, 2, 3, 4, 5][1:4:2] = [2, 4]
• Start index 1 is inclusive
• Stop index 4 is exclusive
• Step 2 means every 2nd element
• Returns elements at indices 1, 3: [2, 4]

How it works:
• [1:4:2] means: start at 1, stop before 4, step by 2
• Indices in range [1, 4): 1, 2, 3
• Step by 2: takes indices 1, 3
• Elements at indices 1, 3: [2, 4]
• Returns new list: [2, 4]

Example:
[1, 2, 3, 4, 5][1:4:2]  # [2, 4] (indices 1, 3)
[1, 2, 3, 4, 5][0:5:2]  # [1, 3, 5] (indices 0, 2, 4)
[1, 2, 3, 4, 5][1:5:3]  # [2, 5] (indices 1, 4)

Common uses:
• Range with step: selected = items[1:4:2]
• Interval in range: sampled = data[start:end:step]
• Pattern extraction
• Selective extraction

Example: [1, 2, 3, 4, 5][1:4:2] returns [2, 4] because it starts at index 1 (inclusive), stops before index 4 (exclusive), and takes every 2nd element, which selects elements at indices 1 and 3.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][0:0]?`, 
    o: ["[]", "[1]", "[1, 2]", "Error"], 
    c: 0, 
    e: "Slicing [0:0] gets empty list (same start and stop).",
    de: `When the start and stop indices are the same in slicing, the result is an empty list. [1, 2, 3][0:0] returns [] because [0:0] means "from index 0 to index 0 (exclusive)", which includes no elements since the stop is exclusive. This is true for any equal start and stop indices.

Equal start and stop:
• [1, 2, 3][0:0] = [] (empty list)
• Start index 0, stop index 0 (exclusive)
• No elements in range [0, 0)
• Returns empty list
• Stop is exclusive, so nothing included

How it works:
• [0:0] means: start at 0, stop before 0
• Range [0, 0) includes no indices
• Stop is exclusive, so index 0 not included
• No elements to include
• Returns empty list: []

Example:
[1, 2, 3][0:0]       # [] (no elements)
[1, 2, 3][1:1]       # [] (no elements)
[1, 2, 3][2:2]       # [] (no elements)
[1, 2, 3][3:3]       # [] (no elements)

Common uses:
• Empty slice: empty = items[i:i]
• Insertion point: items[i:i] = [x] (inserts at i)
• Empty range
• No-op slice

Example: [1, 2, 3][0:0] returns [] because when start and stop are equal, the range is empty (stop is exclusive), so no elements are included in the slice.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][5:10]?`, 
    o: ["[]", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "Slicing beyond list bounds returns empty list.",
    de: `Slicing with indices beyond the list bounds returns an empty list rather than raising an error. [1, 2, 3][5:10] returns [] because the start index 5 is beyond the list length (which is 3), so there are no elements in that range. Python's slicing is forgiving - it doesn't raise errors for out-of-bounds indices, it just returns an empty list.

Slicing beyond bounds:
• [1, 2, 3][5:10] = [] (empty list)
• List has indices 0, 1, 2 (length 3)
• Start index 5 is beyond list bounds
• No elements in range [5, 10)
• Returns empty list (no error)

How it works:
• List [1, 2, 3] has indices 0, 1, 2
• [5:10] means: start at 5, stop before 10
• Index 5 doesn't exist (beyond bounds)
• Range [5, 10) has no valid indices
• Returns empty list: []

Example:
[1, 2, 3][5:10]     # [] (beyond bounds)
[1, 2, 3][10:20]    # [] (beyond bounds)
[1, 2, 3][3:5]      # [] (start at end, nothing after)

Common uses:
• Safe slicing: result = items[start:end] (safe even if out of bounds)
• No error handling needed
• Graceful empty result
• Bounds checking not required

Example: [1, 2, 3][5:10] returns [] because the start index 5 is beyond the list's bounds (list has indices 0-2), so there are no elements in that range, and Python returns an empty list instead of raising an error.
`
  }),
  
  // 21-30: List Operations
  (_i: number) => ({ 
    q: `What is [1, 2] + [3, 4]?`, 
    o: ["[1, 2, 3, 4]", "[1, 2]", "[3, 4]", "Error"], 
    c: 0, 
    e: "+ concatenates lists.",
    de: `The + operator concatenates lists, combining them into a new list. [1, 2] + [3, 4] returns [1, 2, 3, 4] because + joins the elements of both lists in order. This creates a new list object - the original lists are not modified. The + operator for lists only works with other lists, not with other types directly.

List concatenation with +:
• [1, 2] + [3, 4] = [1, 2, 3, 4]
• + joins elements from both lists
• Creates new list object
• Original lists unchanged
• Elements in order: first list, then second list

How it works:
• [1, 2] is first list
• + is concatenation operator
• [3, 4] is second list
• Combines: 1, 2, then 3, 4
• Returns new list: [1, 2, 3, 4]

Example:
[1, 2] + [3, 4]     # [1, 2, 3, 4]
['a'] + ['b', 'c']  # ['a', 'b', 'c']
[] + [1, 2]         # [1, 2]

Common uses:
• Combining lists: combined = list1 + list2
• Joining sequences: result = items + more_items
• Merging lists
• Creating new combined list

Example: [1, 2] + [3, 4] returns [1, 2, 3, 4] because + concatenates the two lists, creating a new list with elements from both lists in order.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] * 3?`, 
    o: ["[1, 2, 1, 2, 1, 2]", "[3, 6]", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "* repeats list elements.",
    de: `The * operator repeats a list a specified number of times. [1, 2] * 3 returns [1, 2, 1, 2, 1, 2] because * repeats the entire list 3 times, concatenating the repetitions. This creates a new list object with the elements repeated. The multiplier must be an integer, and multiplying by 0 results in an empty list.

List repetition with *:
• [1, 2] * 3 = [1, 2, 1, 2, 1, 2]
• * repeats entire list N times
• Creates new list object
• Original list unchanged
• Elements repeated in sequence

How it works:
• [1, 2] is the list
• * 3 means repeat 3 times
• Repeats: [1, 2], [1, 2], [1, 2]
• Concatenates repetitions
• Returns new list: [1, 2, 1, 2, 1, 2]

Example:
[1, 2] * 3          # [1, 2, 1, 2, 1, 2]
['a'] * 4           # ['a', 'a', 'a', 'a']
[1, 2] * 0          # [] (empty list)

Common uses:
• Repeating patterns: pattern = [1, 2] * 3
• Creating duplicates: repeated = items * n
• List multiplication
• Pattern generation

Example: [1, 2] * 3 returns [1, 2, 1, 2, 1, 2] because * repeats the entire list 3 times, creating a new list with the elements repeated.
`
  }),
  (_i: number) => ({ 
    q: `What is [1] * 0?`, 
    o: ["[]", "[1]", "[0]", "Error"], 
    c: 0, 
    e: "Multiplying list by 0 gives empty list.",
    de: `Multiplying a list by 0 results in an empty list. [1] * 0 returns [] because repeating a list zero times means creating a list with no elements. This is consistent with mathematical multiplication where any number times 0 equals 0, and here it represents zero repetitions of the list elements.

List multiplication by 0:
• [1] * 0 = [] (empty list)
• Repeating list 0 times
• Results in empty list
• Zero repetitions = no elements
• Always returns []

How it works:
• [1] is the list
• * 0 means repeat 0 times
• Zero repetitions means no elements
• Returns empty list: []
• Consistent with multiplication concept

Example:
[1] * 0             # [] (empty list)
[1, 2] * 0          # [] (empty list)
['a', 'b'] * 0      # [] (empty list)
[] * 0              # [] (empty list)

Common uses:
• Conditional empty: result = items * 0 if condition else items
• Zero repetitions: empty = pattern * 0
• Empty list creation
• Conditional clearing

Example: [1] * 0 returns [] because multiplying a list by 0 means repeating it zero times, which results in an empty list with no elements.
`
  }),
  (_i: number) => ({ 
    q: `What is 2 in [1, 2, 3]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in checks membership.",
    de: `The in operator checks if a value is a member of a list. 2 in [1, 2, 3] returns True because 2 is present in the list. The in operator searches through the list elements and returns True if it finds the value, False otherwise. This is a membership test that works with all sequence types.

Membership test with in:
• 2 in [1, 2, 3] = True
• in checks if value exists in list
• Returns True if found
• Returns False if not found
• Searches through elements

How it works:
• 2 is the value to search for
• in is membership operator
• [1, 2, 3] is the list to search
• Checks if 2 is in the list
• Finds 2 at index 1, returns True

Example:
2 in [1, 2, 3]      # True (2 is in list)
5 in [1, 2, 3]      # False (5 is not in list)
'a' in ['a', 'b']   # True ('a' is in list)

Common uses:
• Checking membership: if item in items:
• Validation: if value in valid_values:
• Presence check
• Membership verification

Example: 2 in [1, 2, 3] returns True because the in operator checks if 2 is present in the list, and it finds 2 at index 1, so it returns True.
`
  }),
  (_i: number) => ({ 
    q: `What is 5 in [1, 2, 3]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in checks membership - not found.",
    de: `The in operator returns False when a value is not found in a list. 5 in [1, 2, 3] returns False because 5 is not present in the list [1, 2, 3]. The in operator searches through all elements and returns False if the value is not found after checking all elements.

Membership test - not found:
• 5 in [1, 2, 3] = False
• in checks if value exists in list
• Searches through all elements
• Value 5 not found
• Returns False (not found)

How it works:
• 5 is the value to search for
• in is membership operator
• [1, 2, 3] is the list to search
• Checks each element: 1, 2, 3
• None match 5, returns False

Example:
5 in [1, 2, 3]      # False (5 not in list)
10 in [1, 2, 3]     # False (10 not in list)
'z' in ['a', 'b']   # False ('z' not in list)

Common uses:
• Checking absence: if item not in items:
• Validation: if value not in invalid_values:
• Non-membership check
• Absence verification

Example: 5 in [1, 2, 3] returns False because the in operator checks if 5 is present in the list, searches through all elements (1, 2, 3), doesn't find 5, and returns False.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] == [1, 2]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "== compares list contents.",
    de: `The == operator compares the contents of two lists. [1, 2] == [1, 2] returns True because both lists have the same elements in the same order. == checks for value equality - it compares element by element, and both lists must have the same length and same elements in the same positions for them to be equal.

List equality with ==:
• [1, 2] == [1, 2] = True
• == compares list contents (values)
• Checks if elements match
• Checks if order matches
• Both must be equal for True

How it works:
• [1, 2] is first list
• == is equality operator
• [1, 2] is second list
• Compares element by element: 1 == 1, 2 == 2
• Same elements, same order, returns True

Example:
[1, 2] == [1, 2]    # True (same content)
[1, 2] == [2, 1]    # False (different order)
[1, 2] == [1, 2, 3] # False (different length)

Common uses:
• Comparing lists: if list1 == list2:
• Value equality: if items == expected:
• Content comparison
• Equality check

Example: [1, 2] == [1, 2] returns True because == compares the contents of both lists element by element, and they have the same elements in the same order.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] == [2, 1]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "== checks order - lists are different.",
    de: `The == operator checks both the elements and their order. [1, 2] == [2, 1] returns False because even though both lists contain the same elements (1 and 2), they are in different orders. Lists are ordered sequences, so == requires not only the same elements but also the same positions for the comparison to return True.

List equality - order matters:
• [1, 2] == [2, 1] = False
• == compares both elements and order
• Same elements but different order
• Order must match for equality
• Returns False (order different)

How it works:
• [1, 2] is first list
• == is equality operator
• [2, 1] is second list
• Compares element by element: 1 != 2, 2 != 1
• Elements match but order different, returns False

Example:
[1, 2] == [2, 1]    # False (different order)
[1, 2, 3] == [3, 2, 1] # False (different order)
['a', 'b'] == ['b', 'a'] # False (different order)

Common uses:
• Order-sensitive comparison: if list1 == list2:
• Sequence equality check
• Position-aware comparison
• Ordered sequence verification

Example: [1, 2] == [2, 1] returns False because == compares lists element by element in order, and while both lists contain 1 and 2, they are in different positions, so the comparison returns False.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] is [1, 2]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Different list objects, even with same content.",
    de: `The is operator checks object identity (whether two variables reference the same object in memory), not value equality. [1, 2] is [1, 2] returns False because each list literal creates a new list object in memory. Even though they have the same contents, they are different objects with different memory addresses.

Object identity with is:
• [1, 2] is [1, 2] = False
• is checks object identity (same object)
• Each literal creates new object
• Different objects in memory
• Returns False (different objects)

How it works:
• [1, 2] creates first list object
• is is identity operator
• [1, 2] creates second list object
• Checks if same object in memory
• Different objects, returns False

Example:
[1, 2] is [1, 2]    # False (different objects)
a = [1, 2]
b = [1, 2]
a is b              # False (different objects)
a = [1, 2]
b = a
a is b              # True (same object)

Common uses:
• Object identity check: if obj1 is obj2:
• Same reference check
• Object comparison
• Memory address check

Example: [1, 2] is [1, 2] returns False because each list literal creates a new list object in memory, so even though they have the same contents, they are different objects, and is checks for object identity, not value equality.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] < [1, 3]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Lists are compared lexicographically.",
    de: `Lists are compared lexicographically (element by element, like dictionary order). [1, 2] < [1, 3] returns True because Python compares the lists element by element: first compares 1 == 1 (equal), then compares 2 < 3 (less than), so the first list is less than the second. This is the standard comparison algorithm for sequences.

Lexicographic comparison:
• [1, 2] < [1, 3] = True
• Compares element by element
• 1 == 1 (equal, continue)
• 2 < 3 (less than, first list < second)
• Returns True (first list is less)

How it works:
• [1, 2] is first list
• < is less-than operator
• [1, 3] is second list
• Compares element by element:
  - Index 0: 1 == 1 (equal, continue)
  - Index 1: 2 < 3 (less than, returns True)
• Returns True

Example:
[1, 2] < [1, 3]     # True (2 < 3)
[1, 2] < [2, 1]     # True (1 < 2)
[1, 2] < [1, 2]     # False (equal)

Common uses:
• Sorting comparison: sorted(lists)
• Ordering check: if list1 < list2:
• Lexicographic ordering
• Sequence comparison

Example: [1, 2] < [1, 3] returns True because lists are compared lexicographically - Python compares element by element, finds 1 == 1 (equal), then finds 2 < 3 (less than), so the first list is less than the second.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] < [1, 2, 3]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Shorter list is less than longer if prefix matches.",
    de: `When comparing lists of different lengths, Python compares element by element until it finds a difference. [1, 2] < [1, 2, 3] returns True because the first list is a prefix of the second - all elements of the first list match the corresponding elements of the second list, and a shorter list is considered less than a longer list when it's a prefix. This is consistent with lexicographic ordering.

Comparison with different lengths:
• [1, 2] < [1, 2, 3] = True
• Shorter list is prefix of longer
• All elements match: 1 == 1, 2 == 2
• Shorter list < longer list when prefix
• Returns True (prefix is less)

How it works:
• [1, 2] is first list (length 2)
• < is less-than operator
• [1, 2, 3] is second list (length 3)
• Compares element by element:
  - Index 0: 1 == 1 (equal, continue)
  - Index 1: 2 == 2 (equal, continue)
  - First list ends, shorter is less
• Returns True

Example:
[1, 2] < [1, 2, 3]  # True (prefix is less)
[1, 2] < [1, 2]     # False (equal)
[1, 2, 3] < [1, 2]  # False (longer not less)

Common uses:
• Prefix comparison: if prefix < full_list:
• Ordering with different lengths
• Lexicographic comparison
• Sequence ordering

Example: [1, 2] < [1, 2, 3] returns True because the first list is a prefix of the second (all its elements match), and in lexicographic ordering, a shorter list that is a prefix of a longer list is considered less than the longer list.
`
  }),
  
  // 31-40: List Methods - Adding Elements
  (_i: number) => ({ 
    q: `What is [1, 2].append(3)?`, 
    o: ["None", "[1, 2, 3]", "3", "Error"], 
    c: 0, 
    e: "append() returns None, modifies list in place.",
    de: `The append() method adds a single element to the end of a list and returns None. [1, 2].append(3) returns None because append() modifies the list in place and doesn't return anything. After calling append(3), the list [1, 2] becomes [1, 2, 3], but the method itself returns None. This is an important distinction - append() modifies the list, it doesn't create a new list.

append() method:
• [1, 2].append(3) = None (returns None)
• append() adds element to end
• Modifies list in place
• Returns None (doesn't return new list)
• Original list changed: [1, 2] → [1, 2, 3]

How it works:
• append(3) called on [1, 2]
• Adds element 3 to end of list
• Modifies original list: [1, 2, 3]
• Returns None (no return value)
• Method modifies in place

Example:
a = [1, 2]
a.append(3)         # None (returns None)
a                   # [1, 2, 3] (list modified)
[1, 2].append(3)    # None (returns None)

Common uses:
• Adding elements: items.append(value)
• Building lists: result.append(item)
• Appending to end
• In-place modification

Example: [1, 2].append(3) returns None because append() modifies the list in place (changing [1, 2] to [1, 2, 3]), and the method itself returns None rather than returning the modified list.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2].extend([3, 4])?`, 
    o: ["None", "[1, 2, 3, 4]", "[1, 2]", "Error"], 
    c: 0, 
    e: "extend() returns None, adds all elements.",
    de: `The extend() method adds all elements from an iterable to the end of a list and returns None. [1, 2].extend([3, 4]) returns None because extend() modifies the list in place. After calling extend([3, 4]), the list [1, 2] becomes [1, 2, 3, 4], adding each element from the iterable individually. extend() is different from append() - it adds elements from the iterable, not the iterable itself.

extend() method:
• [1, 2].extend([3, 4]) = None (returns None)
• extend() adds elements from iterable
• Modifies list in place
• Returns None (doesn't return new list)
• Original list changed: [1, 2] → [1, 2, 3, 4]

How it works:
• extend([3, 4]) called on [1, 2]
• Iterates through [3, 4]
• Adds each element to end: 3, then 4
• Modifies original list: [1, 2, 3, 4]
• Returns None (no return value)

Example:
a = [1, 2]
a.extend([3, 4])    # None (returns None)
a                   # [1, 2, 3, 4] (list modified)
[1, 2].extend([3, 4]) # None (returns None)

Common uses:
• Adding multiple elements: items.extend(more_items)
• Combining lists: list1.extend(list2)
• Extending lists
• In-place modification

Example: [1, 2].extend([3, 4]) returns None because extend() modifies the list in place (changing [1, 2] to [1, 2, 3, 4] by adding each element from [3, 4]), and the method itself returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2].insert(1, 5)?`, 
    o: ["None", "[1, 5, 2]", "[1, 2, 5]", "Error"], 
    c: 0, 
    e: "insert() adds element at index, returns None.",
    de: `The insert() method inserts an element at a specific index and returns None. [1, 2].insert(1, 5) returns None because insert() modifies the list in place. The first argument is the index where to insert, and the second argument is the element to insert. After calling insert(1, 5), the list [1, 2] becomes [1, 5, 2] - the element at index 1 (which was 2) is shifted to index 2, and 5 is inserted at index 1.

insert() method:
• [1, 2].insert(1, 5) = None (returns None)
• insert(index, element) inserts at position
• Modifies list in place
• Returns None (doesn't return new list)
• Original list changed: [1, 2] → [1, 5, 2]

How it works:
• insert(1, 5) called on [1, 2]
• Inserts element 5 at index 1
• Elements at/after index 1 shift right
• [1] stays at index 0, [5] inserted at index 1, [2] moves to index 2
• Returns None (no return value)

Example:
a = [1, 2]
a.insert(1, 5)      # None (returns None)
a                   # [1, 5, 2] (list modified)
[1, 2, 3].insert(0, 0) # [0, 1, 2, 3] (insert at start)

Common uses:
• Inserting elements: items.insert(index, value)
• Adding at position: list.insert(pos, item)
• Positional insertion
• In-place modification

Example: [1, 2].insert(1, 5) returns None because insert() modifies the list in place, inserting 5 at index 1 (changing [1, 2] to [1, 5, 2]), and the method itself returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2].insert(0, 0)?`, 
    o: ["None", "[0, 1, 2]", "[1, 2, 0]", "Error"], 
    c: 0, 
    e: "insert(0, x) adds at beginning.",
    de: `The insert() method with index 0 inserts an element at the beginning of the list. [1, 2].insert(0, 0) returns None because insert() modifies the list in place. After calling insert(0, 0), the list [1, 2] becomes [0, 1, 2] - the element 0 is inserted at index 0 (the beginning), and all existing elements are shifted to the right by one position.

insert(0, element):
• [1, 2].insert(0, 0) = None (returns None)
• insert(0, x) inserts at beginning
• Modifies list in place
• Returns None (doesn't return new list)
• Original list changed: [1, 2] → [0, 1, 2]

How it works:
• insert(0, 0) called on [1, 2]
• Inserts element 0 at index 0 (beginning)
• All existing elements shift right
• [0] inserted at index 0, [1] moves to index 1, [2] moves to index 2
• Returns None (no return value)

Example:
a = [1, 2]
a.insert(0, 0)      # None (returns None)
a                   # [0, 1, 2] (list modified)
[1, 2].insert(0, 0) # None (returns None)

Common uses:
• Adding to beginning: items.insert(0, value)
• Prepending elements: list.insert(0, item)
• Beginning insertion
• In-place modification

Example: [1, 2].insert(0, 0) returns None because insert() modifies the list in place, inserting 0 at index 0 (the beginning), changing [1, 2] to [0, 1, 2], and the method itself returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2].insert(10, 5)?`, 
    o: ["None", "[1, 2, 5]", "[1, 2]", "Error"], 
    c: 0, 
    e: "insert() with out-of-bounds index appends to end.",
    de: `The insert() method with an out-of-bounds index doesn't raise an error - it appends the element to the end of the list. [1, 2].insert(10, 5) returns None because insert() modifies the list in place. Since index 10 is beyond the list bounds (list has indices 0-1), insert() appends the element to the end instead. After calling insert(10, 5), the list [1, 2] becomes [1, 2, 5].

insert() with out-of-bounds index:
• [1, 2].insert(10, 5) = None (returns None)
• Index 10 is beyond list bounds
• insert() appends to end instead of error
• Modifies list in place
• Original list changed: [1, 2] → [1, 2, 5]

How it works:
• insert(10, 5) called on [1, 2]
• Index 10 is beyond bounds (list has indices 0-1)
• insert() doesn't raise error
• Appends element 5 to end instead
• Returns None (no return value)

Example:
a = [1, 2]
a.insert(10, 5)     # None (returns None)
a                   # [1, 2, 5] (appended to end)
[1, 2].insert(100, 5) # [1, 2, 5] (appends to end)

Common uses:
• Safe insertion: items.insert(index, value) (won't error)
• Append alternative: list.insert(len(list), item)
• Out-of-bounds handling
• Graceful behavior

Example: [1, 2].insert(10, 5) returns None because insert() doesn't raise an error for out-of-bounds indices - instead, it appends the element to the end, changing [1, 2] to [1, 2, 5], and the method itself returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between append() and extend()?`, 
    o: ["append adds one item, extend adds multiple", "No difference", "extend is faster", "append is deprecated"], 
    c: 0, 
    e: "append() adds single element, extend() adds all from iterable.",
    de: `The key difference between append() and extend() is what they add to the list. append() adds a single element (the entire object), while extend() adds all elements from an iterable (unpacking the iterable). For example, [1, 2].append([3, 4]) results in [1, 2, [3, 4]] (the list is added as one element), while [1, 2].extend([3, 4]) results in [1, 2, 3, 4] (the elements 3 and 4 are added individually).

append() vs extend():
• append(item) adds the entire item as one element
• extend(iterable) adds all elements from iterable individually
• append() creates nested structure if item is list
• extend() flattens and adds elements
• Both return None, modify in place

How it works:
• append([3, 4]): adds [3, 4] as single element → [1, 2, [3, 4]]
• extend([3, 4]): iterates [3, 4], adds 3 then 4 → [1, 2, 3, 4]
• append() doesn't iterate
• extend() iterates through iterable
• Both modify original list

Example:
a = [1, 2]
a.append([3, 4])    # [1, 2, [3, 4]] (list added)
a = [1, 2]
a.extend([3, 4])    # [1, 2, 3, 4] (elements added)

Common uses:
• append(): single element: items.append(item)
• extend(): multiple elements: items.extend(iterable)
• Choose based on what you want to add
• Important distinction for lists

Example: The difference is append() adds the entire object as one element (so [1, 2].append([3, 4]) creates [1, 2, [3, 4]]), while extend() adds all elements from the iterable individually (so [1, 2].extend([3, 4]) creates [1, 2, 3, 4]).
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] + [3] vs [1, 2].extend([3])?`, 
    o: ["+ creates new list, extend modifies", "No difference", "extend creates new list", "+ modifies"], 
    c: 0, 
    e: "+ creates new list, extend() modifies in place.",
    de: `The + operator creates a new list, while extend() modifies the existing list in place. [1, 2] + [3] returns a new list [1, 2, 3] without modifying the original lists, while [1, 2].extend([3]) modifies [1, 2] in place to become [1, 2, 3] and returns None. This is a crucial difference - + creates a new object, while extend() modifies the existing object.

+ vs extend():
• [1, 2] + [3] creates new list [1, 2, 3]
• [1, 2].extend([3]) modifies [1, 2] to [1, 2, 3]
• + returns new list object
• extend() returns None, modifies original
• + doesn't change original lists

How it works:
• [1, 2] + [3]: creates new list, returns [1, 2, 3]
• Original [1, 2] unchanged, [3] unchanged
• a = [1, 2]; a.extend([3]): modifies a to [1, 2, 3], returns None
• Original a changed in place
• extend() modifies, + creates new

Example:
a = [1, 2]
b = a + [3]         # b = [1, 2, 3], a unchanged
a = [1, 2]
a.extend([3])       # a = [1, 2, 3], modifies a

Common uses:
• +: creating new list: result = list1 + list2
• extend(): modifying existing: list.extend(items)
• Choose based on whether you need new or modified
• Important for variable behavior

Example: [1, 2] + [3] creates a new list [1, 2, 3] without modifying the originals, while [1, 2].extend([3]) modifies [1, 2] in place to become [1, 2, 3] and returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2].append([3])?`, 
    o: ["None, list becomes [1, 2, [3]]", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "append() adds the entire list as one element.",
    de: `The append() method adds the entire object as a single element, even if it's a list. [1, 2].append([3]) returns None because append() modifies the list in place. After calling append([3]), the list [1, 2] becomes [1, 2, [3]] - the entire list [3] is added as one element (creating a nested list), not the individual element 3. This is different from extend(), which would add the elements from the iterable.

append() with list:
• [1, 2].append([3]) = None (returns None)
• append() adds entire object as one element
• List [3] added as single element
• Creates nested list structure
• Original list changed: [1, 2] → [1, 2, [3]]

How it works:
• append([3]) called on [1, 2]
• Adds entire list [3] as single element
• Doesn't iterate or unpack [3]
• Creates nested structure: [1, 2, [3]]
• Returns None (no return value)

Example:
a = [1, 2]
a.append([3])       # None (returns None)
a                   # [1, 2, [3]] (nested list)
[1, 2].append([3, 4]) # [1, 2, [3, 4]] (nested)

Common uses:
• Adding lists as elements: items.append([x, y])
• Creating nested structures: list.append([items])
• Nested lists
• In-place modification

Example: [1, 2].append([3]) returns None because append() adds the entire list [3] as one element, creating a nested list [1, 2, [3]], and the method itself returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2].extend([3])?`, 
    o: ["None, list becomes [1, 2, 3]", "[1, 2, [3]]", "Error", "None"], 
    c: 0, 
    e: "extend() adds elements from iterable.",
    de: `The extend() method iterates through the iterable and adds each element individually. [1, 2].extend([3]) returns None because extend() modifies the list in place. After calling extend([3]), the list [1, 2] becomes [1, 2, 3] - it iterates through [3] and adds the element 3 individually, not the list [3] itself. This is different from append(), which would add the entire list as one element.

extend() with list:
• [1, 2].extend([3]) = None (returns None)
• extend() iterates through iterable
• Adds each element individually
• Element 3 added, not list [3]
• Original list changed: [1, 2] → [1, 2, 3]

How it works:
• extend([3]) called on [1, 2]
• Iterates through [3]
• Adds each element (just 3) individually
• Creates flat list: [1, 2, 3]
• Returns None (no return value)

Example:
a = [1, 2]
a.extend([3])       # None (returns None)
a                   # [1, 2, 3] (element added)
[1, 2].extend([3, 4]) # [1, 2, 3, 4] (elements added)

Common uses:
• Adding multiple elements: items.extend([x, y])
• Combining lists: list1.extend(list2)
• Flat list extension
• In-place modification

Example: [1, 2].extend([3]) returns None because extend() iterates through [3] and adds the element 3 individually, creating a flat list [1, 2, 3], and the method itself returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2].extend('ab')?`, 
    o: ["None, list becomes [1, 2, 'a', 'b']", "[1, 2, 'ab']", "Error", "None"], 
    c: 0, 
    e: "extend() iterates over string, adds each character.",
    de: `The extend() method works with any iterable, including strings. [1, 2].extend('ab') returns None because extend() modifies the list in place. Since strings are iterable, extend() iterates through the string character by character and adds each character individually. After calling extend('ab'), the list [1, 2] becomes [1, 2, 'a', 'b'] - it adds 'a' and 'b' as separate elements, not the string 'ab' as one element.

extend() with string:
• [1, 2].extend('ab') = None (returns None)
• extend() iterates through string 'ab'
• Adds each character individually
• Characters 'a' and 'b' added separately
• Original list changed: [1, 2] → [1, 2, 'a', 'b']

How it works:
• extend('ab') called on [1, 2]
• String 'ab' is iterable
• Iterates through characters: 'a', 'b'
• Adds each character individually: 'a', then 'b'
• Returns None (no return value)

Example:
a = [1, 2]
a.extend('ab')      # None (returns None)
a                   # [1, 2, 'a', 'b'] (characters added)
[1, 2].extend('xyz') # [1, 2, 'x', 'y', 'z'] (characters added)

Common uses:
• Adding characters: items.extend('abc')
• String iteration: list.extend(string)
• Character-by-character addition
• In-place modification

Example: [1, 2].extend('ab') returns None because extend() iterates through the string 'ab' character by character, adding 'a' and 'b' individually, creating [1, 2, 'a', 'b'], and the method itself returns None.
`
  }),
  
  // 41-50: List Methods - Removing Elements
  (_i: number) => ({ 
    q: `What is [1, 2, 3].pop()?`, 
    o: ["3", "[1, 2]", "None", "Error"], 
    c: 0, 
    e: "pop() returns and removes last element.",
    de: `The pop() method removes and returns the last element from a list when called without arguments. [1, 2, 3].pop() returns 3 because pop() removes the last element (index -1) and returns it. After calling pop(), the list [1, 2, 3] becomes [1, 2] - the element 3 is removed and returned. This is useful for implementing stack-like behavior (LIFO - Last In First Out).

pop() method:
• [1, 2, 3].pop() = 3 (returns last element)
• pop() removes and returns last element
• Modifies list in place
• Returns the removed element
• List changed: [1, 2, 3] → [1, 2]

How it works:
• pop() called on [1, 2, 3]
• Removes last element (index -1, which is 3)
• Returns removed element: 3
• Modifies original list: [1, 2]
• Raises IndexError if list empty

Example:
a = [1, 2, 3]
a.pop()             # 3 (returns last)
a                   # [1, 2] (list modified)
[1, 2, 3].pop()     # 3 (returns last)

Common uses:
• Removing last element: last = items.pop()
• Stack operations: top = stack.pop()
• Getting and removing
• LIFO operations

Example: [1, 2, 3].pop() returns 3 because pop() removes the last element (index -1, which is 3) from the list and returns it, leaving the list as [1, 2].
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].pop(0)?`, 
    o: ["1", "[2, 3]", "None", "Error"], 
    c: 0, 
    e: "pop(0) returns and removes first element.",
    de: `The pop() method with an index argument removes and returns the element at that index. [1, 2, 3].pop(0) returns 1 because pop(0) removes the element at index 0 (the first element) and returns it. After calling pop(0), the list [1, 2, 3] becomes [2, 3] - the element 1 is removed and returned. This is useful for implementing queue-like behavior (FIFO - First In First Out).

pop(index) method:
• [1, 2, 3].pop(0) = 1 (returns element at index 0)
• pop(index) removes and returns element at index
• Modifies list in place
• Returns the removed element
• List changed: [1, 2, 3] → [2, 3]

How it works:
• pop(0) called on [1, 2, 3]
• Removes element at index 0 (which is 1)
• Returns removed element: 1
• Modifies original list: [2, 3]
• Raises IndexError if index out of bounds

Example:
a = [1, 2, 3]
a.pop(0)            # 1 (returns first)
a                   # [2, 3] (list modified)
[1, 2, 3].pop(1)    # 2 (returns element at index 1)

Common uses:
• Removing first element: first = items.pop(0)
• Queue operations: front = queue.pop(0)
• Removing by index
• FIFO operations

Example: [1, 2, 3].pop(0) returns 1 because pop(0) removes the element at index 0 (the first element, which is 1) from the list and returns it, leaving the list as [2, 3].
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].remove(2)?`, 
    o: ["None", "2", "[1, 3]", "Error"], 
    c: 0, 
    e: "remove() removes first occurrence, returns None.",
    de: `The remove() method removes the first occurrence of a value from a list and returns None. [1, 2, 3].remove(2) returns None because remove() modifies the list in place and doesn't return the removed element. After calling remove(2), the list [1, 2, 3] becomes [1, 3] - the first occurrence of the value 2 is removed. Unlike pop(), remove() takes a value, not an index, and only removes the first occurrence if there are duplicates.

remove() method:
• [1, 2, 3].remove(2) = None (returns None)
• remove(value) removes first occurrence of value
• Modifies list in place
• Returns None (doesn't return removed element)
• List changed: [1, 2, 3] → [1, 3]

How it works:
• remove(2) called on [1, 2, 3]
• Searches for first occurrence of value 2
• Finds 2 at index 1, removes it
• Modifies original list: [1, 3]
• Returns None (no return value)

Example:
a = [1, 2, 3]
a.remove(2)         # None (returns None)
a                   # [1, 3] (list modified)
[1, 2, 2, 3].remove(2) # [1, 2, 3] (removes first 2)

Common uses:
• Removing by value: items.remove(value)
• Removing first occurrence: list.remove(item)
• Value-based removal
• In-place modification

Example: [1, 2, 3].remove(2) returns None because remove() removes the first occurrence of the value 2 from the list (changing [1, 2, 3] to [1, 3]), and the method itself returns None rather than returning the removed element.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 2, 3].remove(2)?`, 
    o: ["None, list becomes [1, 2, 3]", "[1, 3]", "Error", "None"], 
    c: 0, 
    e: "remove() removes only first occurrence.",
    de: `The remove() method only removes the first occurrence of a value, not all occurrences. [1, 2, 2, 3].remove(2) returns None because remove() modifies the list in place. After calling remove(2), the list [1, 2, 2, 3] becomes [1, 2, 3] - only the first occurrence of 2 is removed, leaving the second 2 in place. To remove all occurrences, you would need to call remove() multiple times or use a different approach like list comprehension.

remove() - first occurrence only:
• [1, 2, 2, 3].remove(2) = None (returns None)
• remove(value) removes only first occurrence
• Subsequent occurrences remain
• Modifies list in place
• List changed: [1, 2, 2, 3] → [1, 2, 3]

How it works:
• remove(2) called on [1, 2, 2, 3]
• Searches for first occurrence of value 2
• Finds first 2 at index 1, removes it
• Second 2 at index 2 remains (now at index 1)
• Returns None (no return value)

Example:
a = [1, 2, 2, 3]
a.remove(2)         # None (returns None)
a                   # [1, 2, 3] (first 2 removed)
[1, 2, 2, 2, 3].remove(2) # [1, 2, 2, 3] (removes first only)

Common uses:
• Removing first occurrence: items.remove(value)
• Single removal: list.remove(item)
• First match removal
• In-place modification

Example: [1, 2, 2, 3].remove(2) returns None because remove() removes only the first occurrence of 2 (changing [1, 2, 2, 3] to [1, 2, 3]), leaving the second occurrence of 2 in place.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].clear()?`, 
    o: ["None", "[]", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "clear() removes all elements, returns None.",
    de: `The clear() method removes all elements from a list and returns None. [1, 2, 3].clear() returns None because clear() modifies the list in place, removing all elements and leaving an empty list. After calling clear(), the list [1, 2, 3] becomes [] - all elements are removed, but the list object itself still exists. This is different from reassigning to an empty list - clear() modifies the existing object.

clear() method:
• [1, 2, 3].clear() = None (returns None)
• clear() removes all elements from list
• Modifies list in place
• Returns None (doesn't return new list)
• List changed: [1, 2, 3] → []

How it works:
• clear() called on [1, 2, 3]
• Removes all elements from list
• List becomes empty: []
• Original list object still exists
• Returns None (no return value)

Example:
a = [1, 2, 3]
a.clear()           # None (returns None)
a                   # [] (list is now empty)
[1, 2, 3].clear()   # None (returns None)

Common uses:
• Clearing list: items.clear()
• Removing all elements: list.clear()
• Resetting list
• In-place modification

Example: [1, 2, 3].clear() returns None because clear() removes all elements from the list (changing [1, 2, 3] to []), and the method itself returns None rather than returning the empty list.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between pop() and remove()?`, 
    o: ["pop uses index, remove uses value", "No difference", "pop is faster", "remove is deprecated"], 
    c: 0, 
    e: "pop() uses index, remove() uses value.",
    de: `The key difference between pop() and remove() is how they identify which element to remove. pop() uses an index (position) to remove an element, while remove() uses a value to remove an element. pop(index) removes the element at the specified index and returns it, while remove(value) removes the first occurrence of the specified value and returns None. Additionally, pop() returns the removed element, while remove() returns None.

pop() vs remove():
• pop(index): removes by index, returns removed element
• remove(value): removes by value, returns None
• pop() can remove any element by position
• remove() removes first matching value only
• pop() raises IndexError if index invalid
• remove() raises ValueError if value not found

How it works:
• pop(1): removes element at index 1, returns that element
• remove(2): searches for value 2, removes first occurrence, returns None
• pop() needs to know position
• remove() needs to know value
• Both modify list in place

Example:
a = [1, 2, 3]
a.pop(1)            # 2 (returns element at index 1)
a                   # [1, 3] (element removed)
b = [1, 2, 3]
b.remove(2)         # None (returns None)
b                   # [1, 3] (value 2 removed)

Common uses:
• pop(): removing by position: item = list.pop(index)
• remove(): removing by value: list.remove(value)
• Choose based on whether you know position or value
• Important distinction for removal operations

Example: The difference is pop() uses an index to remove an element and returns it (e.g., [1, 2, 3].pop(1) returns 2), while remove() uses a value to remove an element and returns None (e.g., [1, 2, 3].remove(2) returns None).
`
  }),
  (_i: number) => ({ 
    q: `What happens if pop() is called on empty list?`, 
    o: ["IndexError", "Returns None", "Returns []", "Error"], 
    c: 0, 
    e: "pop() on empty list raises IndexError.",
    de: `Calling pop() on an empty list raises an IndexError because there are no elements to remove. If you try to pop from an empty list like [].pop(), Python raises an IndexError with a message indicating that you're trying to pop from an empty list. This is different from some other methods that might return None or an empty list - pop() always requires at least one element to exist.

pop() on empty list:
• [].pop() raises IndexError
• Empty list has no elements to remove
• IndexError indicates invalid index operation
• Must check if list is not empty before popping
• Error message: "pop from empty list"

How it works:
• pop() called on empty list []
• Searches for element to remove
• Finds no elements (list is empty)
• Raises IndexError
• No element to return

Example:
[].pop()            # IndexError: pop from empty list
a = []
a.pop()             # IndexError: pop from empty list
if a:               # Check first
    a.pop()         # Safe to pop

Common uses:
• Error handling: try/except for IndexError
• Checking first: if items: items.pop()
• Validating list not empty
• Safe popping with validation

Example: Calling pop() on an empty list raises an IndexError because there are no elements to remove from the list, and Python raises this error to indicate that the operation cannot be performed on an empty list.
`
  }),
  (_i: number) => ({ 
    q: `What happens if remove() is called with non-existent value?`, 
    o: ["ValueError", "Returns None", "No error", "Error"], 
    c: 0, 
    e: "remove() with non-existent value raises ValueError.",
    de: `Calling remove() with a value that doesn't exist in the list raises a ValueError because the value cannot be found to remove. If you try to remove a non-existent value like [1, 2, 3].remove(5), Python raises a ValueError with a message indicating that the value is not in the list. This is different from pop(), which raises IndexError for invalid indices - remove() raises ValueError for non-existent values.

remove() with non-existent value:
• [1, 2, 3].remove(5) raises ValueError
• Value 5 not found in list
• ValueError indicates value not found
• Must check if value exists before removing
• Error message: "list.remove(x): x not in list"

How it works:
• remove(5) called on [1, 2, 3]
• Searches for value 5 in list
• Finds no match (value doesn't exist)
• Raises ValueError
• Cannot remove non-existent value

Example:
[1, 2, 3].remove(5) # ValueError: list.remove(x): x not in list
a = [1, 2, 3]
a.remove(10)        # ValueError: list.remove(x): x not in list
if 5 in a:          # Check first
    a.remove(5)     # Safe to remove

Common uses:
• Error handling: try/except for ValueError
• Checking first: if value in items: items.remove(value)
• Validating value exists
• Safe removal with validation

Example: Calling remove() with a non-existent value raises a ValueError because Python cannot find the value to remove from the list, and this error indicates that the operation cannot be performed because the value is not present.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].pop(-1)?`, 
    o: ["3", "1", "[1, 2]", "Error"], 
    c: 0, 
    e: "pop(-1) is same as pop() - removes last element.",
    de: `The pop() method accepts negative indices, and pop(-1) is equivalent to pop() without arguments - both remove and return the last element. [1, 2, 3].pop(-1) returns 3 because pop(-1) removes the element at index -1 (which is the last element, 3) and returns it. After calling pop(-1), the list [1, 2, 3] becomes [1, 2]. This is consistent with Python's negative indexing system where -1 refers to the last element.

pop(-1):
• [1, 2, 3].pop(-1) = 3 (returns last element)
• pop(-1) removes element at index -1 (last)
• Equivalent to pop() without arguments
• Modifies list in place
• List changed: [1, 2, 3] → [1, 2]

How it works:
• pop(-1) called on [1, 2, 3]
• Index -1 refers to last element (3)
• Removes element at index -1
• Returns removed element: 3
• Modifies original list: [1, 2]

Example:
a = [1, 2, 3]
a.pop(-1)           # 3 (returns last)
a                   # [1, 2] (list modified)
[1, 2, 3].pop(-1)   # 3 (same as pop())
[1, 2, 3].pop(-2)   # 2 (removes second-to-last)

Common uses:
• Removing last element: last = items.pop(-1)
• Explicit negative indexing: list.pop(-1)
• Last element removal
• Consistent with negative indexing

Example: [1, 2, 3].pop(-1) returns 3 because pop(-1) removes the element at index -1 (the last element, which is 3) from the list and returns it, leaving the list as [1, 2]. This is equivalent to calling pop() without arguments.
`
  }),
  (_i: number) => ({ 
    q: `What is del [1, 2, 3][1]?`, 
    o: ["None, list becomes [1, 3]", "[1, 2]", "Error", "None"], 
    c: 0, 
    e: "del removes element by index, modifies list.",
    de: `The del statement removes an element from a list by index and modifies the list in place. del [1, 2, 3][1] doesn't work because [1, 2, 3] is a literal - you need to use a variable. However, conceptually, del list[index] removes the element at that index. For example, if a = [1, 2, 3], then del a[1] removes the element at index 1, changing [1, 2, 3] to [1, 3]. The del statement doesn't return anything (it's a statement, not an expression).

del statement:
• del list[index] removes element at index
• Modifies list in place
• Doesn't return value (statement, not expression)
• Similar to pop() but doesn't return removed element
• Must use with variable, not literal

How it works:
• del statement with list[index]
• Removes element at specified index
• Modifies original list
• Elements after index shift left
• No return value (statement)

Example:
a = [1, 2, 3]
del a[1]            # None (statement, no return)
a                   # [1, 3] (element at index 1 removed)
b = [1, 2, 3]
del b[0]            # [2, 3] (first element removed)

Common uses:
• Removing by index: del items[index]
• Deleting elements: del list[i]
• Index-based deletion
• In-place modification

Example: The del statement removes an element from a list by index (e.g., if a = [1, 2, 3], then del a[1] removes the element at index 1, changing the list to [1, 3]). It doesn't return a value because it's a statement, not an expression.
`
  }),
  
  // 51-60: List Methods - Searching and Counting
  (_i: number) => ({ 
    q: `What is [1, 2, 3].index(2)?`, 
    o: ["1", "2", "0", "Error"], 
    c: 0, 
    e: "index() returns first index of value.",
    de: `The index() method returns the index of the first occurrence of a value in a list. [1, 2, 3].index(2) returns 1 because index() searches through the list and finds the value 2 at index 1 (the second element). The index() method raises a ValueError if the value is not found in the list. This is useful for finding the position of an element when you know its value.

index() method:
• [1, 2, 3].index(2) = 1 (returns index of value 2)
• index(value) returns first index where value found
• Searches from beginning of list
• Returns integer index
• Raises ValueError if value not found

How it works:
• index(2) called on [1, 2, 3]
• Searches for value 2 in list
• Finds 2 at index 1 (second element)
• Returns index: 1
• Raises ValueError if not found

Example:
[1, 2, 3].index(2)  # 1 (index of 2)
[1, 2, 3].index(1)  # 0 (index of 1)
[1, 2, 3].index(5)  # ValueError (5 not found)

Common uses:
• Finding position: pos = items.index(value)
• Getting index: idx = list.index(item)
• Position lookup
• Value-to-index conversion

Example: [1, 2, 3].index(2) returns 1 because index() searches through the list and finds the value 2 at index 1 (the second element, since indexing starts at 0).
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 2, 3].index(2)?`, 
    o: ["1", "2", "0", "Error"], 
    c: 0, 
    e: "index() returns first occurrence index.",
    de: `The index() method returns the index of the first occurrence of a value, even if the value appears multiple times. [1, 2, 2, 3].index(2) returns 1 because index() searches from the beginning and finds the first occurrence of 2 at index 1. Even though 2 appears again at index 2, index() only returns the position of the first occurrence. This is consistent behavior - index() always returns the first match.

index() - first occurrence:
• [1, 2, 2, 3].index(2) = 1 (returns first index)
• index(value) returns first occurrence only
• Searches from beginning
• Stops at first match
• Subsequent occurrences ignored

How it works:
• index(2) called on [1, 2, 2, 3]
• Searches for value 2 from beginning
• Finds first 2 at index 1
• Returns index: 1 (first occurrence)
• Doesn't continue to find second occurrence

Example:
[1, 2, 2, 3].index(2) # 1 (first occurrence)
[1, 2, 2, 2, 3].index(2) # 1 (first occurrence)
[2, 2, 2].index(2)    # 0 (first occurrence)

Common uses:
• Finding first position: pos = items.index(value)
• Getting first index: idx = list.index(item)
• First match lookup
• Value-to-index conversion

Example: [1, 2, 2, 3].index(2) returns 1 because index() searches from the beginning and returns the index of the first occurrence of 2 (at index 1), even though 2 appears again at index 2.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].count(2)?`, 
    o: ["1", "2", "0", "Error"], 
    c: 0, 
    e: "count() returns number of occurrences.",
    de: `The count() method returns the number of times a value appears in a list. [1, 2, 3].count(2) returns 1 because count() counts how many times the value 2 appears in the list, and it appears once. The count() method searches through the entire list and counts all occurrences of the value. If the value doesn't appear, count() returns 0 (it never raises an error).

count() method:
• [1, 2, 3].count(2) = 1 (returns count)
• count(value) returns number of occurrences
• Searches entire list
• Counts all occurrences
• Returns 0 if value not found (no error)

How it works:
• count(2) called on [1, 2, 3]
• Searches for value 2 in entire list
• Finds one occurrence at index 1
• Counts occurrences: 1
• Returns count: 1

Example:
[1, 2, 3].count(2)  # 1 (one occurrence)
[1, 2, 2, 3].count(2) # 2 (two occurrences)
[1, 2, 3].count(5)  # 0 (zero occurrences)

Common uses:
• Counting occurrences: count = items.count(value)
• Getting frequency: freq = list.count(item)
• Frequency counting
• Occurrence counting

Example: [1, 2, 3].count(2) returns 1 because count() searches through the entire list and counts how many times the value 2 appears, and it appears once at index 1.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 2, 3].count(2)?`, 
    o: ["2", "1", "0", "Error"], 
    c: 0, 
    e: "count() counts all occurrences.",
    de: `The count() method counts all occurrences of a value in a list, not just the first one. [1, 2, 2, 3].count(2) returns 2 because count() searches through the entire list and counts how many times the value 2 appears - it appears twice, at index 1 and index 2. Unlike index(), which returns the first occurrence only, count() counts all occurrences throughout the list.

count() - all occurrences:
• [1, 2, 2, 3].count(2) = 2 (returns total count)
• count(value) counts all occurrences
• Searches entire list
• Counts every occurrence
• Returns total count

How it works:
• count(2) called on [1, 2, 2, 3]
• Searches for value 2 in entire list
• Finds occurrences at index 1 and index 2
• Counts all occurrences: 2
• Returns total count: 2

Example:
[1, 2, 2, 3].count(2) # 2 (two occurrences)
[1, 2, 2, 2, 3].count(2) # 3 (three occurrences)
[2, 2, 2].count(2)    # 3 (three occurrences)

Common uses:
• Counting all occurrences: count = items.count(value)
• Getting total frequency: freq = list.count(item)
• Total frequency counting
• All occurrence counting

Example: [1, 2, 2, 3].count(2) returns 2 because count() searches through the entire list and counts all occurrences of 2, finding it at index 1 and index 2, for a total count of 2.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].count(5)?`, 
    o: ["0", "1", "Error", "None"], 
    c: 0, 
    e: "count() returns 0 if value not found.",
    de: `The count() method returns 0 when a value is not found in the list, rather than raising an error. [1, 2, 3].count(5) returns 0 because count() searches through the entire list and finds no occurrences of the value 5. Unlike index(), which raises a ValueError when a value is not found, count() always returns a non-negative integer (0 or greater) and never raises an error.

count() - value not found:
• [1, 2, 3].count(5) = 0 (returns 0)
• count(value) returns 0 if value not found
• No error raised
• Safe to call with any value
• Returns 0 for non-existent values

How it works:
• count(5) called on [1, 2, 3]
• Searches for value 5 in entire list
• Finds no occurrences
• Counts occurrences: 0
• Returns 0 (no error)

Example:
[1, 2, 3].count(5)  # 0 (not found)
[1, 2, 3].count(10) # 0 (not found)
[].count(5)         # 0 (empty list)

Common uses:
• Safe counting: count = items.count(value) (won't error)
• Checking presence: if items.count(value) > 0:
• Non-existence checking
• Safe occurrence checking

Example: [1, 2, 3].count(5) returns 0 because count() searches through the entire list and finds no occurrences of 5, and count() returns 0 for non-existent values rather than raising an error.
`
  }),
  (_i: number) => ({ 
    q: `What happens if index() is called with non-existent value?`, 
    o: ["ValueError", "Returns -1", "Returns None", "Error"], 
    c: 0, 
    e: "index() with non-existent value raises ValueError.",
    de: `Calling index() with a value that doesn't exist in the list raises a ValueError because the value cannot be found. If you try to find the index of a non-existent value like [1, 2, 3].index(5), Python raises a ValueError with a message indicating that the value is not in the list. This is different from count(), which returns 0 for non-existent values - index() must find the value to return its index.

index() with non-existent value:
• [1, 2, 3].index(5) raises ValueError
• Value 5 not found in list
• ValueError indicates value not found
• Must check if value exists before calling index()
• Error message: "list.index(x): x not in list"

How it works:
• index(5) called on [1, 2, 3]
• Searches for value 5 in list
• Finds no match (value doesn't exist)
• Raises ValueError
• Cannot return index for non-existent value

Example:
[1, 2, 3].index(5)  # ValueError: list.index(x): x not in list
a = [1, 2, 3]
a.index(10)        # ValueError: list.index(x): x not in list
if 5 in a:         # Check first
    a.index(5)     # Safe to call

Common uses:
• Error handling: try/except for ValueError
• Checking first: if value in items: items.index(value)
• Validating value exists
• Safe index lookup with validation

Example: Calling index() with a non-existent value raises a ValueError because Python cannot find the value in the list to return its index, and this error indicates that the operation cannot be performed because the value is not present.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].index(2, 1)?`, 
    o: ["1", "2", "0", "Error"], 
    c: 0, 
    e: "index(value, start) searches from start index.",
    de: `The index() method can take a second argument (start) to specify where to begin searching. [1, 2, 3].index(2, 1) returns 1 because index(2, 1) searches for the value 2 starting from index 1. The search begins at the start index (inclusive) and continues to the end of the list. If the value is found at or after the start index, index() returns its position.

index() with start parameter:
• [1, 2, 3].index(2, 1) = 1 (returns index)
• index(value, start) searches from start index
• Start index is inclusive (searched)
• Search continues to end of list
• Returns first occurrence from start

How it works:
• index(2, 1) called on [1, 2, 3]
• Starts searching from index 1 (inclusive)
• Searches indices 1, 2
• Finds 2 at index 1
• Returns index: 1

Example:
[1, 2, 3].index(2, 1)  # 1 (found at index 1)
[1, 2, 3].index(2, 0)  # 1 (searches from index 0)
[1, 2, 2, 3].index(2, 2) # 2 (finds second occurrence)

Common uses:
• Searching from position: idx = items.index(value, start)
• Finding after position: pos = list.index(item, from_index)
• Position-limited search
• Range-based search

Example: [1, 2, 3].index(2, 1) returns 1 because index() searches for 2 starting from index 1 (inclusive), finds 2 at index 1, and returns that index.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 2, 3].index(2, 2)?`, 
    o: ["2", "1", "0", "Error"], 
    c: 0, 
    e: "index(value, start) finds first occurrence from start.",
    de: `The index() method with a start parameter finds the first occurrence of a value starting from the specified index. [1, 2, 2, 3].index(2, 2) returns 2 because index(2, 2) searches for the value 2 starting from index 2, and finds the second occurrence of 2 at index 2. This is useful for finding occurrences after a certain position, effectively allowing you to skip the first occurrence(s) if you know where to start searching.

index() - finding occurrence from start:
• [1, 2, 2, 3].index(2, 2) = 2 (returns index)
• index(value, start) finds first from start
• Start index is inclusive
• Skips elements before start index
• Returns first occurrence from start position

How it works:
• index(2, 2) called on [1, 2, 2, 3]
• Starts searching from index 2 (inclusive)
• Skips index 0 and 1 (ignores first occurrence)
• Searches indices 2, 3
• Finds 2 at index 2 (second occurrence)
• Returns index: 2

Example:
[1, 2, 2, 3].index(2, 2) # 2 (finds second occurrence)
[1, 2, 2, 3].index(2, 0) # 1 (finds first occurrence)
[1, 2, 2, 2, 3].index(2, 2) # 2 (finds from index 2)

Common uses:
• Finding next occurrence: idx = items.index(value, from_index)
• Skipping first match: pos = list.index(item, after_pos)
• Subsequent occurrence search
• Position-based search

Example: [1, 2, 2, 3].index(2, 2) returns 2 because index() searches for 2 starting from index 2 (inclusive), skips the first occurrence at index 1, and finds the second occurrence at index 2.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].index(2, 1, 3)?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "index(value, start, stop) searches in range.",
    de: `The index() method can take a third argument (stop) to specify where to stop searching. [1, 2, 3].index(2, 1, 3) returns 1 because index(2, 1, 3) searches for the value 2 starting from index 1 (inclusive) up to (but not including) index 3. The stop index is exclusive, similar to slicing. This allows you to search within a specific range of the list.

index() with start and stop:
• [1, 2, 3].index(2, 1, 3) = 1 (returns index)
• index(value, start, stop) searches in range [start, stop)
• Start index is inclusive (searched)
• Stop index is exclusive (not searched)
• Returns first occurrence in range

How it works:
• index(2, 1, 3) called on [1, 2, 3]
• Searches in range [1, 3) (indices 1, 2)
• Start index 1 is inclusive
• Stop index 3 is exclusive
• Finds 2 at index 1
• Returns index: 1

Example:
[1, 2, 3].index(2, 1, 3)  # 1 (found in range)
[1, 2, 3].index(2, 0, 2)  # 1 (found in range)
[1, 2, 3].index(2, 2, 3)  # ValueError (not in range)

Common uses:
• Searching in range: idx = items.index(value, start, stop)
• Bounded search: pos = list.index(item, from_index, to_index)
• Range-limited search
• Sub-list search

Example: [1, 2, 3].index(2, 1, 3) returns 1 because index() searches for 2 in the range [1, 3) (indices 1 and 2, since stop is exclusive), and finds 2 at index 1.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3].index(2, 0, 1)?`, 
    o: ["ValueError", "1", "0", "Error"], 
    c: 0, 
    e: "index() raises ValueError if not found in range.",
    de: `The index() method raises a ValueError if the value is not found within the specified range. [1, 2, 3].index(2, 0, 1) raises a ValueError because index(2, 0, 1) searches for the value 2 in the range [0, 1) (which includes only index 0, since stop is exclusive), but the value 2 is at index 1, which is outside the search range. The stop index is exclusive, so even though 2 exists in the list, it's not in the specified range.

index() - value not in range:
• [1, 2, 3].index(2, 0, 1) raises ValueError
• Searches in range [0, 1) (index 0 only)
• Value 2 is at index 1 (outside range)
• Stop index 1 is exclusive (not searched)
• Raises ValueError (value not in range)

How it works:
• index(2, 0, 1) called on [1, 2, 3]
• Searches in range [0, 1) (index 0 only)
• Stop index 1 is exclusive
• Finds 1 at index 0, not 2
• Value 2 is at index 1 (outside range)
• Raises ValueError

Example:
[1, 2, 3].index(2, 0, 1)  # ValueError (2 not in range [0, 1))
[1, 2, 3].index(2, 0, 2)  # 1 (found in range [0, 2))
[1, 2, 3].index(3, 0, 2)  # ValueError (3 not in range [0, 2))

Common uses:
• Error handling: try/except for ValueError
• Range validation: check if value in range first
• Bounded search with validation
• Range-limited search

Example: [1, 2, 3].index(2, 0, 1) raises a ValueError because index() searches for 2 in the range [0, 1) (index 0 only, since stop is exclusive), but 2 is at index 1, which is outside the search range.
`
  }),
  
  // 61-70: List Methods - Sorting and Reversing
  (_i: number) => ({ q: `What is sorted([3, 1, 2])?`, o: ["[1, 2, 3]", "[3, 1, 2]", "None", "Error"], c: 0, e: "sorted() returns new sorted list." }),
  (_i: number) => ({ q: `What is sorted([3, 1, 2], reverse=True)?`, o: ["[3, 2, 1]", "[1, 2, 3]", "None", "Error"], c: 0, e: "reverse=True sorts descending." }),
  (_i: number) => ({ q: `What is [3, 1, 2].sort()?`, o: ["None", "[1, 2, 3]", "[3, 1, 2]", "Error"], c: 0, e: "sort() modifies list in place, returns None." }),
  (_i: number) => ({ q: `What is [3, 1, 2].reverse()?`, o: ["None", "[2, 1, 3]", "[1, 2, 3]", "Error"], c: 0, e: "reverse() modifies list in place, returns None." }),
  (_i: number) => ({ q: `What is the difference between sort() and sorted()?`, o: ["sort() modifies in place, sorted() returns new list", "No difference", "sorted() is faster", "sort() is deprecated"], c: 0, e: "sort() modifies in place, sorted() returns new list." }),
  (_i: number) => ({ 
    q: `What is reversed([1, 2, 3])?`, 
    o: ["list_reverseiterator object", "[3, 2, 1]", "None", "Error"], 
    c: 0, 
    e: "reversed() returns iterator, not list.",
    de: `The reversed() function returns a reverse iterator, not a list. reversed([1, 2, 3]) returns a list_reverseiterator object because reversed() creates an iterator that yields elements in reverse order, but doesn't create a new list immediately. The iterator is lazy - it computes elements on-demand as you iterate through it. This is memory-efficient for large sequences, but the result is not a list - it's an iterator object.

reversed() function:
• reversed([1, 2, 3]) = list_reverseiterator object
• reversed() returns reverse iterator
• Doesn't create new list immediately
• Iterator computes elements on-demand
• Memory-efficient for large sequences

How it works:
• reversed() called with [1, 2, 3]
• Creates reverse iterator object
• Iterator remembers list and position
• Yields elements in reverse when iterated
• Returns iterator object, not list

Example:
reversed([1, 2, 3])  # <list_reverseiterator object>
list(reversed([1, 2, 3])) # [3, 2, 1] (converts to list)
for x in reversed([1, 2, 3]):  # Iterates: 3, 2, 1
    print(x)

Common uses:
• Reverse iteration: for item in reversed(items):
• Creating reverse iterator: rev_iter = reversed(list)
• Memory-efficient reversal
• Lazy reverse iteration

Example: reversed([1, 2, 3]) returns a list_reverseiterator object because reversed() creates an iterator that yields elements in reverse order, but doesn't create a new list - the iterator computes elements on-demand as you iterate through it.
`
  }),
  (_i: number) => ({ 
    q: `What is list(reversed([1, 2, 3]))?`, 
    o: ["[3, 2, 1]", "[1, 2, 3]", "None", "Error"], 
    c: 0, 
    e: "list(reversed()) converts iterator to list.",
    de: `The list() function can convert a reverse iterator to a list. list(reversed([1, 2, 3])) returns [3, 2, 1] because list() consumes the iterator created by reversed([1, 2, 3]) and collects all elements into a new list. The reversed() function returns an iterator, and list() iterates through that iterator, collecting the reversed elements into a list. This is how you get an actual reversed list from reversed().

list(reversed()):
• list(reversed([1, 2, 3])) = [3, 2, 1]
• reversed() returns iterator
• list() consumes iterator
• Collects elements into new list
• Creates reversed list

How it works:
• reversed([1, 2, 3]) creates reverse iterator
• list() iterates through iterator
• Iterator yields: 3, 2, 1 (in reverse)
• list() collects: [3, 2, 1]
• Returns new reversed list

Example:
list(reversed([1, 2, 3]))  # [3, 2, 1] (reversed list)
list(reversed([1, 2]))      # [2, 1] (reversed list)
list(reversed([]))          # [] (empty list)

Common uses:
• Getting reversed list: reversed_list = list(reversed(items))
• Creating reverse copy: rev = list(reversed(data))
• Converting iterator to list
• Reverse list creation

Example: list(reversed([1, 2, 3])) returns [3, 2, 1] because list() consumes the iterator created by reversed() and collects all elements in reverse order into a new list.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][::-1] vs reversed([1, 2, 3])?`, 
    o: ["[::-1] returns list, reversed() returns iterator", "No difference", "reversed() returns list", "[::-1] returns iterator"], 
    c: 0, 
    e: "[::-1] creates new list, reversed() returns iterator.",
    de: `The key difference between [::-1] and reversed() is what they return. [1, 2, 3][::-1] returns a new list [3, 2, 1] because slicing with a negative step creates a new list object immediately. reversed([1, 2, 3]) returns a list_reverseiterator object because reversed() creates an iterator that yields elements on-demand. Both produce reversed elements, but [::-1] creates a list immediately (more memory but faster access), while reversed() creates an iterator (less memory but requires iteration to access).

[::-1] vs reversed():
• [::-1] returns new list immediately
• reversed() returns iterator object
• [::-1] creates list object in memory
• reversed() creates lazy iterator
• Both produce reversed elements

How it works:
• [1, 2, 3][::-1]: creates new list [3, 2, 1] immediately
• reversed([1, 2, 3]): creates iterator that yields 3, 2, 1 on-demand
• [::-1] uses more memory (stores list)
• reversed() uses less memory (computes on-demand)
• Both produce same reversed order

Example:
[1, 2, 3][::-1]      # [3, 2, 1] (new list)
reversed([1, 2, 3])  # <list_reverseiterator> (iterator)
list(reversed([1, 2, 3])) # [3, 2, 1] (must convert)

Common uses:
• [::-1]: immediate reversed list: rev = items[::-1]
• reversed(): memory-efficient iteration: for x in reversed(items):
• Choose based on memory vs access needs
• Both useful for different scenarios

Example: [1, 2, 3][::-1] returns a new list [3, 2, 1] immediately, while reversed([1, 2, 3]) returns an iterator that yields reversed elements on-demand - both produce the same reversed order, but [::-1] creates a list object while reversed() creates an iterator.
`
  }),
  (_i: number) => ({ 
    q: `What is sorted(['c', 'a', 'b'])?`, 
    o: ["['a', 'b', 'c']", "['c', 'a', 'b']", "None", "Error"], 
    c: 0, 
    e: "sorted() works with strings, sorts alphabetically.",
    de: `The sorted() function works with any iterable, including lists of strings. sorted(['c', 'a', 'b']) returns ['a', 'b', 'c'] because sorted() sorts strings alphabetically using their Unicode/ASCII values. Strings are compared character by character using their code points, so 'a' comes before 'b', and 'b' comes before 'c'. sorted() creates a new list and doesn't modify the original.

sorted() with strings:
• sorted(['c', 'a', 'b']) = ['a', 'b', 'c']
• sorted() works with string lists
• Sorts alphabetically (Unicode order)
• Creates new sorted list
• Original list unchanged

How it works:
• sorted() called with ['c', 'a', 'b']
• Compares strings using Unicode values
• 'a' < 'b' < 'c' (alphabetical order)
• Sorts: ['a', 'b', 'c']
• Returns new list: ['a', 'b', 'c']

Example:
sorted(['c', 'a', 'b'])  # ['a', 'b', 'c']
sorted(['z', 'a', 'm'])  # ['a', 'm', 'z']
sorted(['A', 'a', 'B'])  # ['A', 'B', 'a'] (case-sensitive)

Common uses:
• Sorting strings: sorted_list = sorted(strings)
• Alphabetical order: result = sorted(items)
• String sorting
• Text ordering

Example: sorted(['c', 'a', 'b']) returns ['a', 'b', 'c'] because sorted() sorts strings alphabetically using their Unicode values, creating a new list with elements in alphabetical order.
`
  }),
  (_i: number) => ({ 
    q: `What is sorted([3, 1, 2], key=lambda x: -x)?`, 
    o: ["[3, 2, 1]", "[1, 2, 3]", "None", "Error"], 
    c: 0, 
    e: "key parameter customizes sorting.",
    de: `The sorted() function can take a key parameter to customize sorting. sorted([3, 1, 2], key=lambda x: -x) returns [3, 2, 1] because the key function transforms each element before comparison. Here, key=lambda x: -x negates each element, so comparisons use -3, -1, -2, which sorts as -3 < -1 < -2 (descending), resulting in [3, 2, 1] in descending order. The key function doesn't change the elements in the result - it only affects the comparison order.

sorted() with key:
• sorted([3, 1, 2], key=lambda x: -x) = [3, 2, 1]
• key parameter transforms elements for comparison
• lambda x: -x negates each element
• Sorts using negated values: -3 < -1 < -2
• Result: [3, 2, 1] (descending order)

How it works:
• sorted() called with [3, 1, 2], key=lambda x: -x
• Applies key function: -3, -1, -2 (negated)
• Compares using negated values: -3 < -1 < -2
• Sorts in descending order (because negated)
• Returns new list: [3, 2, 1]

Example:
sorted([3, 1, 2], key=lambda x: -x)  # [3, 2, 1] (descending)
sorted([1, 2, 3], key=lambda x: x**2) # [1, 2, 3] (squares: 1 < 4 < 9)
sorted(['abc', 'a', 'ab'], key=len)  # ['a', 'ab', 'abc'] (by length)

Common uses:
• Custom sorting: sorted(items, key=func)
• Descending sort: sorted(items, key=lambda x: -x)
• Transform-based sorting
• Flexible sorting criteria

Example: sorted([3, 1, 2], key=lambda x: -x) returns [3, 2, 1] because the key function negates each element for comparison, causing the list to be sorted in descending order (largest to smallest).
`
  }),
  
  // 71-80: List Copying
  (_i: number) => ({ 
    q: `What is [1, 2, 3].copy()?`, 
    o: ["[1, 2, 3]", "[1, 2]", "None", "Error"], 
    c: 0, 
    e: "copy() creates shallow copy.",
    de: `The copy() method creates a shallow copy of a list and returns it. [1, 2, 3].copy() returns [1, 2, 3] because copy() creates a new list object with the same elements. A shallow copy means the outer list is copied, but if the list contains nested objects (like other lists), those nested objects are not copied - they are shared between the original and the copy. For flat lists (no nesting), shallow copy creates a completely independent list.

copy() method:
• [1, 2, 3].copy() = [1, 2, 3] (new list)
• copy() creates shallow copy
• Creates new list object
• Elements are copied (not shared)
• Returns new list

How it works:
• copy() called on [1, 2, 3]
• Creates new list object
• Copies elements to new list: [1, 2, 3]
• New list is independent of original
• Returns new list: [1, 2, 3]

Example:
a = [1, 2, 3]
b = a.copy()        # [1, 2, 3] (new list)
b.append(4)         # b = [1, 2, 3, 4]
a                   # [1, 2, 3] (unchanged)

Common uses:
• Creating copies: new_list = items.copy()
• Independent lists: copy = list.copy()
• Shallow copying
• Copy creation

Example: [1, 2, 3].copy() returns [1, 2, 3] because copy() creates a new list object with the same elements, resulting in a shallow copy of the original list.
`
  }),
  (_i: number) => ({ 
    q: `What is list([1, 2, 3])?`, 
    o: ["[1, 2, 3]", "(1, 2, 3)", "None", "Error"], 
    c: 0, 
    e: "list() constructor creates shallow copy.",
    de: `The list() constructor creates a shallow copy when called with a list as an argument. list([1, 2, 3]) returns [1, 2, 3] because list() takes the list [1, 2, 3] and creates a new list object with the same elements. This is essentially the same as using copy() - it creates a shallow copy where the outer list is new, but nested objects (if any) are shared. For flat lists, this creates a completely independent list.

list() constructor:
• list([1, 2, 3]) = [1, 2, 3] (new list)
• list() creates shallow copy
• Creates new list object
• Elements are copied (not shared)
• Returns new list

How it works:
• list() called with [1, 2, 3]
• Creates new list object
• Copies elements to new list: [1, 2, 3]
• New list is independent of original
• Returns new list: [1, 2, 3]

Example:
a = [1, 2, 3]
b = list(a)         # [1, 2, 3] (new list)
b.append(4)         # b = [1, 2, 3, 4]
a                   # [1, 2, 3] (unchanged)

Common uses:
• Creating copies: new_list = list(old_list)
• Shallow copying: copy = list(original)
• List construction
• Copy creation

Example: list([1, 2, 3]) returns [1, 2, 3] because list() creates a new list object with the same elements, resulting in a shallow copy of the original list.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3][:]?`, 
    o: ["[1, 2, 3]", "[1, 2]", "None", "Error"], 
    c: 0, 
    e: "Slicing [:] creates shallow copy.",
    de: `Slicing with [:] creates a shallow copy of a list. [1, 2, 3][:] returns [1, 2, 3] because [:] means "from start to end", which includes all elements, and slicing creates a new list object. This is one of the common ways to create a shallow copy - along with copy() and list(). A shallow copy means the outer list is copied, but nested objects (if any) are shared between the original and the copy.

Slicing [:] for copying:
• [1, 2, 3][:] = [1, 2, 3] (new list)
• [:] creates shallow copy
• Includes all elements from start to end
• Creates new list object
• Returns new list

How it works:
• [:] called on [1, 2, 3]
• Creates new list object
• Copies all elements to new list: [1, 2, 3]
• New list is independent of original
• Returns new list: [1, 2, 3]

Example:
a = [1, 2, 3]
b = a[:]            # [1, 2, 3] (new list)
b.append(4)         # b = [1, 2, 3, 4]
a                   # [1, 2, 3] (unchanged)

Common uses:
• Creating copies: new_list = items[:]
• Shallow copying: copy = list[:]
• Copy creation
• List duplication

Example: [1, 2, 3][:] returns [1, 2, 3] because [:] creates a shallow copy of the entire list, resulting in a new list object with the same elements.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between shallow and deep copy?`, 
    o: ["Shallow copies outer, deep copies nested", "No difference", "Deep is faster", "Shallow is deprecated"], 
    c: 0, 
    e: "Shallow copy copies outer structure, deep copy copies nested objects.",
    de: `The difference between shallow copy and deep copy is how they handle nested objects. A shallow copy creates a new outer object but shares nested objects - if you modify a nested object in the copy, it affects the original. A deep copy creates new objects for both the outer structure and all nested objects - modifications to nested objects in the copy don't affect the original. For flat lists (no nesting), shallow and deep copies behave the same.

Shallow vs deep copy:
• Shallow copy: copies outer list, shares nested objects
• Deep copy: copies outer list and all nested objects
• Shallow: changes to nested objects affect original
• Deep: changes to nested objects don't affect original
• For flat lists: both behave the same

How it works:
• Shallow: [[1], [2]].copy() → new outer list, but inner lists shared
• Deep: copy.deepcopy([[1], [2]]) → new outer list and new inner lists
• Shallow: modify copy[0].append(3) affects original
• Deep: modify copy[0].append(3) doesn't affect original

Example:
# Shallow copy
a = [[1], [2]]
b = a.copy()
b[0].append(3)      # a = [[1, 3], [2]] (affected!)
# Deep copy
a = [[1], [2]]
b = copy.deepcopy(a)
b[0].append(3)      # a = [[1], [2]] (unchanged)

Common uses:
• Shallow: flat lists: copy = items.copy()
• Deep: nested structures: copy = copy.deepcopy(nested)
• Choose based on nesting
• Important distinction for nested data

Example: The difference is that shallow copy copies only the outer structure and shares nested objects (so modifying nested objects in the copy affects the original), while deep copy copies both the outer structure and all nested objects (so modifications to nested objects in the copy don't affect the original).
`
  }),
  (_i: number) => ({ 
    q: `What is import copy; copy.copy([1, 2, 3])?`, 
    o: ["[1, 2, 3] (shallow copy)", "[1, 2, 3] (deep copy)", "Error", "None"], 
    c: 0, 
    e: "copy.copy() creates shallow copy.",
    de: `The copy.copy() function from the copy module creates a shallow copy of an object. copy.copy([1, 2, 3]) returns [1, 2, 3] because copy.copy() creates a new list object with the same elements. This is a shallow copy - the outer list is copied, but if the list contains nested objects (like other lists), those nested objects are shared between the original and the copy. For flat lists, copy.copy() creates a completely independent list.

copy.copy() function:
• copy.copy([1, 2, 3]) = [1, 2, 3] (shallow copy)
• copy.copy() creates shallow copy
• Creates new list object
• Elements are copied (not shared)
• Returns new list

How it works:
• copy.copy() called with [1, 2, 3]
• Creates new list object
• Copies elements to new list: [1, 2, 3]
• New list is independent of original
• Returns new list: [1, 2, 3]

Example:
import copy
a = [1, 2, 3]
b = copy.copy(a)    # [1, 2, 3] (shallow copy)
b.append(4)         # b = [1, 2, 3, 4]
a                   # [1, 2, 3] (unchanged)

Common uses:
• Creating copies: new_list = copy.copy(items)
• Shallow copying: copy = copy.copy(original)
• General copying
• Copy creation

Example: copy.copy([1, 2, 3]) returns [1, 2, 3] because copy.copy() creates a shallow copy of the list, resulting in a new list object with the same elements.
`
  }),
  (_i: number) => ({ 
    q: `What is import copy; copy.deepcopy([1, 2, 3])?`, 
    o: ["[1, 2, 3] (deep copy)", "[1, 2, 3] (shallow copy)", "Error", "None"], 
    c: 0, 
    e: "copy.deepcopy() creates deep copy.",
    de: `The copy.deepcopy() function from the copy module creates a deep copy of an object. copy.deepcopy([1, 2, 3]) returns [1, 2, 3] because copy.deepcopy() creates a new list object with the same elements. For flat lists (no nesting), deep copy behaves the same as shallow copy - both create independent lists. However, for nested structures, deep copy creates independent copies of all nested objects, while shallow copy shares them.

copy.deepcopy() function:
• copy.deepcopy([1, 2, 3]) = [1, 2, 3] (deep copy)
• copy.deepcopy() creates deep copy
• Creates new list object
• Elements are copied (not shared)
• For flat lists: same as shallow copy
• For nested: also copies nested objects

How it works:
• copy.deepcopy() called with [1, 2, 3]
• Creates new list object
• Copies elements to new list: [1, 2, 3]
• For flat lists: same result as shallow copy
• Returns new list: [1, 2, 3]

Example:
import copy
a = [1, 2, 3]
b = copy.deepcopy(a) # [1, 2, 3] (deep copy)
b.append(4)          # b = [1, 2, 3, 4]
a                    # [1, 2, 3] (unchanged)

Common uses:
• Creating deep copies: new_list = copy.deepcopy(items)
• Nested structures: copy = copy.deepcopy(nested)
• Independent copying
• Complete copying

Example: copy.deepcopy([1, 2, 3]) returns [1, 2, 3] because copy.deepcopy() creates a deep copy of the list, resulting in a new list object with the same elements. For flat lists, this is the same as shallow copy, but for nested structures, deep copy also copies nested objects independently.
`
  }),
  (_i: number) => ({ 
    q: `What is a = [1, 2]; b = a; b.append(3); a?`, 
    o: ["[1, 2, 3]", "[1, 2]", "Error", "None"], 
    c: 0, 
    e: "Assignment creates reference, not copy.",
    de: `Assignment in Python creates a reference to the same object, not a copy. If a = [1, 2] and b = a, then b.append(3) modifies a as well because both a and b reference the same list object in memory. When you assign a list to another variable, you're not creating a copy - you're creating another name (reference) that points to the same list object. Modifying the list through either variable affects the same object.

Assignment creates reference:
• a = [1, 2]; b = a creates reference
• b.append(3) modifies same object
• a becomes [1, 2, 3] because a and b reference same list
• No copy created
• Both variables point to same object

How it works:
• a = [1, 2] creates list object
• b = a assigns reference to same object
• a and b both point to same list
• b.append(3) modifies the shared list
• a sees the change: [1, 2, 3]

Example:
a = [1, 2]
b = a               # b references same list as a
b.append(3)         # modifies shared list
a                   # [1, 2, 3] (a also changed!)
b                   # [1, 2, 3] (same object)

Common uses:
• Understanding references: b = a (same object)
• Avoiding accidental sharing: b = a.copy() (different object)
• Reference vs copy
• Object sharing

Example: If a = [1, 2] and b = a, then b.append(3) changes a to [1, 2, 3] because assignment creates a reference to the same object, not a copy - both a and b point to the same list in memory.
`
  }),
  (_i: number) => ({ 
    q: `What is a = [1, 2]; b = a.copy(); b.append(3); a?`, 
    o: ["[1, 2]", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "copy() creates independent list.",
    de: `The copy() method creates an independent copy of a list. If a = [1, 2] and b = a.copy(), then b.append(3) doesn't modify a because b is a new, independent list object. When you use copy(), Python creates a new list object with the same elements, so modifications to the copy don't affect the original. This is different from assignment (b = a), which creates a reference to the same object.

copy() creates independent list:
• a = [1, 2]; b = a.copy() creates new list
• b.append(3) modifies only b
• a remains [1, 2] because a and b are different objects
• Copy created
• Variables point to different objects

How it works:
• a = [1, 2] creates list object
• b = a.copy() creates new list object with same elements
• a and b point to different lists
• b.append(3) modifies only b's list
• a remains unchanged: [1, 2]

Example:
a = [1, 2]
b = a.copy()        # b is new list (copy)
b.append(3)         # modifies only b's list
a                   # [1, 2] (a unchanged!)
b                   # [1, 2, 3] (b modified)

Common uses:
• Creating independent copies: b = a.copy()
• Avoiding shared modifications: copy = original.copy()
• Independent lists
• Copy creation

Example: If a = [1, 2] and b = a.copy(), then b.append(3) doesn't change a - a remains [1, 2] because copy() creates an independent list object, so modifications to b don't affect a.
`
  }),
  (_i: number) => ({ 
    q: `What is a = [[1], [2]]; b = a.copy(); b[0].append(3); a?`, 
    o: ["[[1, 3], [2]]", "[[1], [2]]", "Error", "None"], 
    c: 0, 
    e: "Shallow copy shares nested objects.",
    de: `A shallow copy shares nested objects with the original. If a = [[1], [2]] and b = a.copy(), then b[0].append(3) modifies a as well because copy() creates a new outer list but shares the inner lists (nested objects). The outer list is copied, but the nested lists are not - they are shared between a and b. Modifying a nested object through either variable affects both because they reference the same nested objects.

Shallow copy shares nested objects:
• a = [[1], [2]]; b = a.copy() creates shallow copy
• b[0].append(3) modifies shared inner list
• a becomes [[1, 3], [2]] because inner lists are shared
• Outer list copied, nested lists shared
• Modifications to nested objects affect original

How it works:
• a = [[1], [2]] creates list with nested lists
• b = a.copy() creates new outer list but shares inner lists
• a and b point to different outer lists
• But a[0] and b[0] point to same inner list
• b[0].append(3) modifies shared inner list
• a sees the change: [[1, 3], [2]]

Example:
a = [[1], [2]]
b = a.copy()        # b is shallow copy (outer list copied, inner lists shared)
b[0].append(3)      # modifies shared inner list
a                   # [[1, 3], [2]] (a also changed!)
b                   # [[1, 3], [2]] (same nested objects)

Common uses:
• Understanding shallow copy: nested objects shared
• Avoiding nested sharing: b = copy.deepcopy(a)
• Shallow copy behavior
• Nested object sharing

Example: If a = [[1], [2]] and b = a.copy(), then b[0].append(3) changes a to [[1, 3], [2]] because shallow copy creates a new outer list but shares the nested inner lists, so modifications to nested objects through either variable affect both.
`
  }),
  (_i: number) => ({ 
    q: `What is a = [[1], [2]]; b = copy.deepcopy(a); b[0].append(3); a?`, 
    o: ["[[1], [2]]", "[[1, 3], [2]]", "Error", "None"], 
    c: 0, 
    e: "Deep copy creates independent nested objects.",
    de: `A deep copy creates independent copies of both the outer structure and all nested objects. If a = [[1], [2]] and b = copy.deepcopy(a), then b[0].append(3) doesn't modify a because deepcopy() creates new objects for both the outer list and all nested lists. The outer list is copied, and each nested list is also copied independently, so modifications to nested objects in the copy don't affect the original.

Deep copy creates independent nested objects:
• a = [[1], [2]]; b = copy.deepcopy(a) creates deep copy
• b[0].append(3) modifies only b's inner list
• a remains [[1], [2]] because inner lists are independent
• Outer list copied, nested lists also copied
• Modifications to nested objects don't affect original

How it works:
• a = [[1], [2]] creates list with nested lists
• b = copy.deepcopy(a) creates new outer list and new inner lists
• a and b point to different outer lists
• And a[0] and b[0] point to different inner lists
• b[0].append(3) modifies only b's inner list
• a remains unchanged: [[1], [2]]

Example:
import copy
a = [[1], [2]]
b = copy.deepcopy(a) # b is deep copy (everything copied)
b[0].append(3)       # modifies only b's inner list
a                    # [[1], [2]] (a unchanged!)
b                    # [[1, 3], [2]] (b modified)

Common uses:
• Creating independent nested copies: b = copy.deepcopy(a)
• Avoiding nested sharing: deep_copy = copy.deepcopy(nested)
• Deep copy behavior
• Complete independence

Example: If a = [[1], [2]] and b = copy.deepcopy(a), then b[0].append(3) doesn't change a - a remains [[1], [2]] because deep copy creates independent copies of both the outer list and all nested lists, so modifications to nested objects in the copy don't affect the original.
`
  }),
  
  // 81-90: List Unpacking and Advanced Operations
  (_i: number) => ({ 
    q: `What is a, b, c = [1, 2, 3]?`, 
    o: ["a=1, b=2, c=3", "Error", "a=[1,2,3], b=None, c=None", "None"], 
    c: 0, 
    e: "List unpacking assigns elements to variables.",
    de: `List unpacking assigns elements from a list to variables in a single statement. a, b, c = [1, 2, 3] assigns 1 to a, 2 to b, and 3 to c because Python unpacks the list elements and assigns them to the variables in order. The number of variables must match the number of elements in the list (or you can use * to collect extra elements). Unpacking works with any sequence type (lists, tuples, strings).

List unpacking:
• a, b, c = [1, 2, 3] assigns: a=1, b=2, c=3
• Unpacks list elements to variables
• Variables assigned in order
• Number of variables must match elements (or use *)
• Works with any sequence

How it works:
• [1, 2, 3] is the list
• a, b, c are variables
• Python unpacks elements: 1, 2, 3
• Assigns in order: a=1, b=2, c=3
• All three variables assigned

Example:
a, b, c = [1, 2, 3]    # a=1, b=2, c=3
x, y = ['a', 'b']      # x='a', y='b'
a, b, c = (1, 2, 3)    # a=1, b=2, c=3 (tuples work too)

Common uses:
• Multiple assignment: a, b, c = items
• Unpacking sequences: x, y = point
• Clean variable assignment
• Sequence unpacking

Example: a, b, c = [1, 2, 3] assigns 1 to a, 2 to b, and 3 to c because Python unpacks the list elements and assigns them to the variables in order.
`
  }),
  (_i: number) => ({ 
    q: `What is a, *b = [1, 2, 3, 4]?`, 
    o: ["a=1, b=[2,3,4]", "Error", "a=[1,2,3,4], b=[]", "None"], 
    c: 0, 
    e: "* unpacks remaining elements into list.",
    de: `The * operator in unpacking collects remaining elements into a list. a, *b = [1, 2, 3, 4] assigns 1 to a and [2, 3, 4] to b because *b collects all remaining elements (2, 3, 4) into a list and assigns them to b. The * operator must appear on exactly one variable and collects all extra elements. If there are no remaining elements, * collects an empty list.

Unpacking with *:
• a, *b = [1, 2, 3, 4] assigns: a=1, b=[2, 3, 4]
• *b collects remaining elements into list
• First element goes to a
• Remaining elements go to b as list
• * must appear on exactly one variable

How it works:
• [1, 2, 3, 4] is the list
• a, *b are variables
• Python unpacks: 1 to a, remaining [2, 3, 4] to b
• * collects extra elements: [2, 3, 4]
• Assigns: a=1, b=[2, 3, 4]

Example:
a, *b = [1, 2, 3, 4]  # a=1, b=[2, 3, 4]
a, *b = [1, 2]        # a=1, b=[2]
a, *b = [1]           # a=1, b=[]

Common uses:
• Collecting rest: first, *rest = items
• Variable-length unpacking: head, *tail = data
• Flexible unpacking
• Remaining elements

Example: a, *b = [1, 2, 3, 4] assigns 1 to a and [2, 3, 4] to b because *b collects all remaining elements into a list.
`
  }),
  (_i: number) => ({ 
    q: `What is *a, b = [1, 2, 3, 4]?`, 
    o: ["a=[1,2,3], b=4", "Error", "a=[], b=[1,2,3,4]", "None"], 
    c: 0, 
    e: "* at start unpacks all but last.",
    de: `The * operator at the beginning collects all elements except the last into a list. *a, b = [1, 2, 3, 4] assigns [1, 2, 3] to a and 4 to b because *a collects all elements except the last (1, 2, 3) into a list, and b gets the last element (4). This is useful for separating all but the last element from the rest.

* at start unpacks all but last:
• *a, b = [1, 2, 3, 4] assigns: a=[1, 2, 3], b=4
• *a collects all except last into list
• b gets last element
• Useful for "all but last" patterns
• * must appear on exactly one variable

How it works:
• [1, 2, 3, 4] is the list
• *a, b are variables
• Python unpacks: all but last [1, 2, 3] to a, last 4 to b
• * collects initial elements: [1, 2, 3]
• Assigns: a=[1, 2, 3], b=4

Example:
*a, b = [1, 2, 3, 4]  # a=[1, 2, 3], b=4
*a, b = [1, 2]        # a=[1], b=2
*a, b = [1]           # a=[], b=1

Common uses:
• All but last: *rest, last = items
• Separating last: *prefix, suffix = data
• Flexible unpacking
• Last element separation

Example: *a, b = [1, 2, 3, 4] assigns [1, 2, 3] to a and 4 to b because *a collects all elements except the last into a list, and b gets the last element.
`
  }),
  (_i: number) => ({ 
    q: `What is a, b, *c = [1, 2]?`, 
    o: ["a=1, b=2, c=[]", "Error", "a=1, b=2, c=None", "None"], 
    c: 0, 
    e: "* gets empty list if no remaining elements.",
    de: `The * operator gets an empty list if there are no remaining elements to collect. a, b, *c = [1, 2] assigns 1 to a, 2 to b, and [] to c because there are no remaining elements after assigning to a and b, so *c collects an empty list. This is consistent behavior - * always creates a list, even if it's empty, rather than assigning None.

* gets empty list if no remaining:
• a, b, *c = [1, 2] assigns: a=1, b=2, c=[]
• All elements assigned to a and b
• No remaining elements for *c
• *c collects empty list (not None)
• * always creates list type

How it works:
• [1, 2] is the list
• a, b, *c are variables
• Python unpacks: 1 to a, 2 to b
• No remaining elements
• *c collects empty list: []

Example:
a, b, *c = [1, 2]     # a=1, b=2, c=[]
a, *b = [1]           # a=1, b=[]
*a, b, c = [1, 2]     # a=[], b=1, c=2

Common uses:
• Safe unpacking: first, second, *rest = items (rest might be empty)
• Variable unpacking: *prefix, suffix = data
• Flexible unpacking
• Optional remaining elements

Example: a, b, *c = [1, 2] assigns 1 to a, 2 to b, and [] to c because all elements are assigned to a and b, so *c collects an empty list (not None).
`
  }),
  (_i: number) => ({ 
    q: `What is [*[1, 2], *[3, 4]]?`, 
    o: ["[1, 2, 3, 4]", "[[1, 2], [3, 4]]", "Error", "None"], 
    c: 0, 
    e: "Unpacking in list literal combines lists.",
    de: `Unpacking in a list literal uses the * operator to expand iterables and combine them into a single list. [*[1, 2], *[3, 4]] returns [1, 2, 3, 4] because *[1, 2] unpacks elements 1 and 2, and *[3, 4] unpacks elements 3 and 4, and they're combined into a single list. This is equivalent to [1, 2] + [3, 4], but uses unpacking syntax.

Unpacking in list literal:
• [*[1, 2], *[3, 4]] = [1, 2, 3, 4]
• * unpacks iterable into individual elements
• Elements combined into single list
• Equivalent to concatenation
• Works with any iterable

How it works:
• [*[1, 2], *[3, 4]] unpacks both lists
• *[1, 2] expands to 1, 2
• *[3, 4] expands to 3, 4
• Combined into list: [1, 2, 3, 4]
• Returns new list: [1, 2, 3, 4]

Example:
[*[1, 2], *[3, 4]]    # [1, 2, 3, 4]
[*[1, 2], 5]          # [1, 2, 5]
[*range(3), *range(3)] # [0, 1, 2, 0, 1, 2]

Common uses:
• Combining lists: combined = [*list1, *list2]
• Merging iterables: result = [*items1, *items2]
• List combination
• Iterable merging

Example: [*[1, 2], *[3, 4]] returns [1, 2, 3, 4] because the * operator unpacks both lists into individual elements, which are then combined into a single list.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] + [3] vs [*[1, 2], 3]?`, 
    o: ["Both create [1, 2, 3]", "Different results", "Error", "None"], 
    c: 0, 
    e: "Both create same list, different syntax.",
    de: `Both [1, 2] + [3] and [*[1, 2], 3] create the same list [1, 2, 3], but use different syntax. [1, 2] + [3] uses the + operator to concatenate lists, while [*[1, 2], 3] uses unpacking in a list literal to expand [1, 2] into elements and combine them with 3. Both produce the same result - a new list containing [1, 2, 3]. The choice between them is a matter of style or context.

+ vs unpacking:
• [1, 2] + [3] = [1, 2, 3] (concatenation)
• [*[1, 2], 3] = [1, 2, 3] (unpacking)
• Both create same list
• Different syntax, same result
• Both create new list

How it works:
• [1, 2] + [3]: + operator concatenates lists → [1, 2, 3]
• [*[1, 2], 3]: * unpacks [1, 2] to 1, 2, combines with 3 → [1, 2, 3]
• Both produce same result: [1, 2, 3]
• Both create new list object
• Different syntax approaches

Example:
[1, 2] + [3]          # [1, 2, 3] (concatenation)
[*[1, 2], 3]          # [1, 2, 3] (unpacking)
[1, 2] + [3] == [*[1, 2], 3] # True (same result)

Common uses:
• Combining lists: result = list1 + list2 or [*list1, *list2]
• Creating lists: combined = [*items, new_item]
• List creation
• Flexible syntax

Example: Both [1, 2] + [3] and [*[1, 2], 3] create [1, 2, 3] because + concatenates lists while unpacking expands iterables - both produce the same result with different syntax.
`
  }),
  (_i: number) => ({ 
    q: `What is max([1, 2, 3])?`, 
    o: ["3", "1", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "max() finds maximum element.",
    de: `The max() function finds and returns the maximum element from an iterable. max([1, 2, 3]) returns 3 because max() compares all elements in the list and returns the largest value. max() works with any iterable containing comparable elements (numbers, strings, etc.) and returns the element with the maximum value according to Python's comparison rules.

max() function:
• max([1, 2, 3]) = 3 (returns maximum)
• max() finds largest element
• Compares all elements
• Returns the maximum value
• Works with any iterable

How it works:
• max() called with [1, 2, 3]
• Compares elements: 1, 2, 3
• Finds maximum: 3
• Returns maximum: 3
• Raises ValueError if iterable empty

Example:
max([1, 2, 3])        # 3 (maximum)
max([5, 1, 9])        # 9 (maximum)
max(['a', 'b', 'c'])  # 'c' (lexicographically largest)
max([])               # ValueError (empty)

Common uses:
• Finding maximum: largest = max(items)
• Getting max value: max_val = max(data)
• Maximum finding
• Comparison operations

Example: max([1, 2, 3]) returns 3 because max() compares all elements in the list (1, 2, 3) and returns the largest value, which is 3.
`
  }),
  (_i: number) => ({ 
    q: `What is min([1, 2, 3])?`, 
    o: ["1", "3", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "min() finds minimum element.",
    de: `The min() function finds and returns the minimum element from an iterable. min([1, 2, 3]) returns 1 because min() compares all elements in the list and returns the smallest value. min() works with any iterable containing comparable elements (numbers, strings, etc.) and returns the element with the minimum value according to Python's comparison rules.

min() function:
• min([1, 2, 3]) = 1 (returns minimum)
• min() finds smallest element
• Compares all elements
• Returns the minimum value
• Works with any iterable

How it works:
• min() called with [1, 2, 3]
• Compares elements: 1, 2, 3
• Finds minimum: 1
• Returns minimum: 1
• Raises ValueError if iterable empty

Example:
min([1, 2, 3])        # 1 (minimum)
min([5, 1, 9])        # 1 (minimum)
min(['a', 'b', 'c'])  # 'a' (lexicographically smallest)
min([])               # ValueError (empty)

Common uses:
• Finding minimum: smallest = min(items)
• Getting min value: min_val = min(data)
• Minimum finding
• Comparison operations

Example: min([1, 2, 3]) returns 1 because min() compares all elements in the list (1, 2, 3) and returns the smallest value, which is 1.
`
  }),
  (_i: number) => ({ 
    q: `What is sum([1, 2, 3])?`, 
    o: ["6", "0", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "sum() adds all elements.",
    de: `The sum() function adds all elements in an iterable and returns the total. sum([1, 2, 3]) returns 6 because sum() iterates through the list and adds all values: 1 + 2 + 3 = 6. sum() works with iterables containing numbers (integers, floats) and returns the sum of all elements. If the iterable is empty, sum() returns 0 (the additive identity).

sum() function:
• sum([1, 2, 3]) = 6 (returns sum)
• sum() adds all elements
• Iterates through iterable
• Returns total sum
• Returns 0 if iterable empty

How it works:
• sum() called with [1, 2, 3]
• Iterates through elements: 1, 2, 3
• Adds values: 1 + 2 + 3
• Returns total: 6
• Works with any numeric iterable

Example:
sum([1, 2, 3])        # 6 (1+2+3)
sum([10, 20, 30])     # 60 (10+20+30)
sum([])               # 0 (empty, additive identity)
sum([1.5, 2.5, 3.5])  # 7.5 (floats work)

Common uses:
• Adding elements: total = sum(items)
• Calculating sum: result = sum(data)
• Summation
• Aggregation operations

Example: sum([1, 2, 3]) returns 6 because sum() iterates through the list and adds all values (1 + 2 + 3 = 6).
`
  }),
  (_i: number) => ({ 
    q: `What is all([True, True, False])?`, 
    o: ["False", "True", "[True, True, False]", "Error"], 
    c: 0, 
    e: "all() returns True only if all elements are Truthy.",
    de: `The all() function returns True only if all elements in an iterable are truthy. all([True, True, False]) returns False because all() checks each element: True (truthy), True (truthy), False (falsy). Since not all elements are truthy (False is falsy), all() returns False. If all elements were truthy, it would return True. all() is useful for checking if all conditions are met.

all() function:
• all([True, True, False]) = False
• all() returns True only if all elements truthy
• Checks each element
• Returns False if any element falsy
• Returns True if all elements truthy

How it works:
• all() called with [True, True, False]
• Checks each element: True (truthy), True (truthy), False (falsy)
• Finds False (falsy element)
• Returns False (not all truthy)
• Short-circuits at first falsy

Example:
all([True, True, False]) # False (not all truthy)
all([True, True, True]) # True (all truthy)
all([1, 2, 3])          # True (all numbers truthy)
all([1, 0, 3])          # False (0 is falsy)

Common uses:
• Checking all conditions: if all(conditions):
• Validating all values: if all(items):
• All-check validation
• Condition verification

Example: all([True, True, False]) returns False because all() checks each element and finds that not all elements are truthy (False is falsy), so it returns False.
`
  }),
  
  // 91-100: List Advanced Features
  (_i: number) => ({ 
    q: `What is any([False, False, True])?`, 
    o: ["True", "False", "[False, False, True]", "Error"], 
    c: 0, 
    e: "any() returns True if any element is Truthy.",
    de: `The any() function returns True if any element in an iterable is truthy. any([False, False, True]) returns True because any() checks each element: False (falsy), False (falsy), True (truthy). Since at least one element is truthy (True is truthy), any() returns True. If all elements were falsy, it would return False. any() is useful for checking if any condition is met.

any() function:
• any([False, False, True]) = True
• any() returns True if any element truthy
• Checks each element
• Returns True if at least one element truthy
• Returns False if all elements falsy

How it works:
• any() called with [False, False, True]
• Checks each element: False (falsy), False (falsy), True (truthy)
• Finds True (truthy element)
• Returns True (at least one truthy)
• Short-circuits at first truthy

Example:
any([False, False, True])  # True (at least one truthy)
any([False, False, False]) # False (all falsy)
any([0, 0, 1])             # True (1 is truthy)
any([])                    # False (empty iterable)

Common uses:
• Checking any condition: if any(conditions):
• Finding if any value truthy: if any(items):
• Any-check validation
• Condition verification

Example: any([False, False, True]) returns True because any() checks each element and finds that at least one element is truthy (True is truthy), so it returns True.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3] * 2?`, 
    o: ["[1, 2, 3, 1, 2, 3]", "[2, 4, 6]", "[1, 2, 3, 2]", "Error"], 
    c: 0, 
    e: "* repeats entire list.",
    de: `The * operator repeats a list a specified number of times. [1, 2, 3] * 2 returns [1, 2, 3, 1, 2, 3] because * repeats the entire list 2 times, concatenating the repetitions. This creates a new list object with the elements repeated. The multiplier must be an integer, and multiplying by 0 results in an empty list.

List repetition with *:
• [1, 2, 3] * 2 = [1, 2, 3, 1, 2, 3]
• * repeats entire list N times
• Creates new list object
• Original list unchanged
• Elements repeated in sequence

How it works:
• [1, 2, 3] is the list
• * 2 means repeat 2 times
• Repeats: [1, 2, 3], [1, 2, 3]
• Concatenates repetitions
• Returns new list: [1, 2, 3, 1, 2, 3]

Example:
[1, 2, 3] * 2          # [1, 2, 3, 1, 2, 3]
[1, 2] * 3              # [1, 2, 1, 2, 1, 2]
[1, 2, 3] * 0           # [] (empty list)

Common uses:
• Repeating patterns: pattern = items * n
• Creating duplicates: repeated = list * count
• List multiplication
• Pattern generation

Example: [1, 2, 3] * 2 returns [1, 2, 3, 1, 2, 3] because * repeats the entire list 2 times, creating a new list with the elements repeated.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] == [1.0, 2.0]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "== compares values, 1 == 1.0 is True.",
    de: `The == operator compares list contents by value, not by type. [1, 2] == [1.0, 2.0] returns True because == compares the values of elements: 1 == 1.0 (True) and 2 == 2.0 (True). Even though 1 is an integer and 1.0 is a float, they represent the same numeric value, so == returns True. This is consistent with Python's equality comparison, where values are compared, not types.

== compares values:
• [1, 2] == [1.0, 2.0] = True
• == compares element values
• 1 == 1.0 (same value)
• 2 == 2.0 (same value)
• Type doesn't matter, value does

How it works:
• [1, 2] is first list
• == is equality operator
• [1.0, 2.0] is second list
• Compares element by element:
  - 1 == 1.0 (same value, True)
  - 2 == 2.0 (same value, True)
• All elements equal, returns True

Example:
[1, 2] == [1.0, 2.0]  # True (same values)
[1, 2] == [1, 2.0]    # True (same values)
[1, 2] == [1.1, 2.0]  # False (1 != 1.1)

Common uses:
• Comparing lists: if list1 == list2:
• Value equality: if items == expected:
• Content comparison
• Value-based equality

Example: [1, 2] == [1.0, 2.0] returns True because == compares element values (1 == 1.0 and 2 == 2.0), and even though one list contains integers and the other contains floats, they represent the same numeric values.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] == [1, 2, 3]?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Lists must have same length and elements.",
    de: `The == operator requires lists to have the same length and same elements in the same order for them to be equal. [1, 2] == [1, 2, 3] returns False because the lists have different lengths - the first list has 2 elements while the second has 3 elements. Even though both lists start with [1, 2], they are not equal because they have different lengths. == checks both the number of elements and each element's value.

== requires same length:
• [1, 2] == [1, 2, 3] = False
• == checks length first
• Different lengths: 2 vs 3
• Elements match for first 2 positions
• But different lengths, returns False

How it works:
• [1, 2] is first list (length 2)
• == is equality operator
• [1, 2, 3] is second list (length 3)
• Compares lengths: 2 != 3
• Different lengths, returns False immediately

Example:
[1, 2] == [1, 2, 3]   # False (different lengths)
[1, 2] == [1, 2]      # True (same length and elements)
[1, 2, 3] == [1, 2]   # False (different lengths)

Common uses:
• Comparing lists: if list1 == list2: (must match exactly)
• Validating equality: if items == expected:
• Exact comparison
• Length and content check

Example: [1, 2] == [1, 2, 3] returns False because the lists have different lengths (2 vs 3), and == requires both the same length and same elements for equality.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] != [1, 3]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "!= checks if lists are different.",
    de: `The != operator checks if two lists are different (not equal). [1, 2] != [1, 3] returns True because != checks if the lists are not equal. The lists have the same length (2) and the first element is the same (1), but the second element is different (2 vs 3), so they are not equal. != returns True when lists differ in any way - length, elements, or order.

!= checks if different:
• [1, 2] != [1, 3] = True
• != checks if lists not equal
• Same length: 2 == 2
• Different elements: 2 != 3
• Returns True (lists are different)

How it works:
• [1, 2] is first list
• != is not-equal operator
• [1, 3] is second list
• Compares element by element:
  - 1 == 1 (same, continue)
  - 2 != 3 (different, returns True)
• Returns True (lists are different)

Example:
[1, 2] != [1, 3]     # True (different elements)
[1, 2] != [1, 2]     # False (same lists)
[1, 2] != [2, 1]     # True (different order)

Common uses:
• Checking difference: if list1 != list2:
• Validating inequality: if items != expected:
• Difference check
• Inequality validation

Example: [1, 2] != [1, 3] returns True because != checks if the lists are different, and they differ at the second element (2 vs 3), so they are not equal.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] < [1, 2, 3]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Shorter list is less if it's a prefix.",
    de: `When comparing lists of different lengths, Python compares element by element until it finds a difference. [1, 2] < [1, 2, 3] returns True because the first list is a prefix of the second - all elements of the first list match the corresponding elements of the second list (1 == 1, 2 == 2), and a shorter list is considered less than a longer list when it's a prefix. This is consistent with lexicographic ordering.

Comparison with different lengths:
• [1, 2] < [1, 2, 3] = True
• Shorter list is prefix of longer
• All elements match: 1 == 1, 2 == 2
• Shorter list < longer list when prefix
• Returns True (prefix is less)

How it works:
• [1, 2] is first list (length 2)
• < is less-than operator
• [1, 2, 3] is second list (length 3)
• Compares element by element:
  - Index 0: 1 == 1 (equal, continue)
  - Index 1: 2 == 2 (equal, continue)
  - First list ends, shorter is less
• Returns True

Example:
[1, 2] < [1, 2, 3]   # True (prefix is less)
[1, 2] < [1, 2]      # False (equal)
[1, 2, 3] < [1, 2]   # False (longer not less)

Common uses:
• Comparing lists: if list1 < list2: (lexicographic)
• Ordering lists: sorted(lists)
• Lexicographic comparison
• Sequence ordering

Example: [1, 2] < [1, 2, 3] returns True because the first list is a prefix of the second (all its elements match), and in lexicographic ordering, a shorter list that is a prefix of a longer list is considered less than the longer list.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2, 3] > [1, 2]?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Longer list is greater if shorter is prefix.",
    de: `When comparing lists of different lengths, Python compares element by element until it finds a difference. [1, 2, 3] > [1, 2] returns True because the second list is a prefix of the first - all elements of the shorter list match the corresponding elements of the longer list (1 == 1, 2 == 2), and a longer list is considered greater than a shorter list when the shorter is a prefix. This is consistent with lexicographic ordering.

Comparison - longer vs shorter:
• [1, 2, 3] > [1, 2] = True
• Longer list contains shorter as prefix
• All elements match: 1 == 1, 2 == 2
• Longer list > shorter list when shorter is prefix
• Returns True (longer is greater)

How it works:
• [1, 2, 3] is first list (length 3)
• > is greater-than operator
• [1, 2] is second list (length 2)
• Compares element by element:
  - Index 0: 1 == 1 (equal, continue)
  - Index 1: 2 == 2 (equal, continue)
  - Second list ends, longer is greater
• Returns True

Example:
[1, 2, 3] > [1, 2]   # True (longer is greater)
[1, 2, 3] > [1, 2, 3] # False (equal)
[1, 2] > [1, 2, 3]   # False (shorter not greater)

Common uses:
• Comparing lists: if list1 > list2: (lexicographic)
• Ordering lists: sorted(lists)
• Lexicographic comparison
• Sequence ordering

Example: [1, 2, 3] > [1, 2] returns True because the second list is a prefix of the first (all its elements match), and in lexicographic ordering, a longer list is considered greater than a shorter list when the shorter is a prefix.
`
  }),
  (_i: number) => ({ 
    q: `What is [1, 2] + [3] * 2?`, 
    o: ["[1, 2, 3, 3]", "[1, 2, 6]", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "Operator precedence: * before +.",
    de: `Operator precedence determines the order of operations. [1, 2] + [3] * 2 returns [1, 2, 3, 3] because * has higher precedence than +, so [3] * 2 is evaluated first, creating [3, 3], then [1, 2] + [3, 3] concatenates them to create [1, 2, 3, 3]. The * operator binds more tightly than +, so multiplication happens before addition.

Operator precedence:
• [1, 2] + [3] * 2 = [1, 2, 3, 3]
• * has higher precedence than +
• [3] * 2 evaluated first: [3, 3]
• Then [1, 2] + [3, 3]: [1, 2, 3, 3]
• Multiplication before addition

How it works:
• Expression: [1, 2] + [3] * 2
• Precedence: * before +
• Step 1: [3] * 2 = [3, 3] (multiplication first)
• Step 2: [1, 2] + [3, 3] = [1, 2, 3, 3] (addition second)
• Returns: [1, 2, 3, 3]

Example:
[1, 2] + [3] * 2     # [1, 2, 3, 3] (* first)
([1, 2] + [3]) * 2   # [1, 2, 3, 1, 2, 3] (parentheses change order)
[3] * 2 + [1, 2]     # [3, 3, 1, 2] (* first)

Common uses:
• Understanding precedence: result = items1 + items2 * n
• Operator order: combined = list1 + list2 * repeat
• Precedence awareness
• Expression evaluation

Example: [1, 2] + [3] * 2 returns [1, 2, 3, 3] because * has higher precedence than +, so [3] * 2 is evaluated first (creating [3, 3]), then [1, 2] + [3, 3] concatenates them.
`
  }),
  (_i: number) => ({ 
    q: `What is ([1, 2] + [3]) * 2?`, 
    o: ["[1, 2, 3, 1, 2, 3]", "[1, 2, 6]", "[1, 2, 3]", "Error"], 
    c: 0, 
    e: "Parentheses change order: concatenate first, then repeat.",
    de: `Parentheses override operator precedence, changing the order of operations. ([1, 2] + [3]) * 2 returns [1, 2, 3, 1, 2, 3] because parentheses force the + operation to happen first: ([1, 2] + [3]) creates [1, 2, 3], then * 2 repeats that list twice, creating [1, 2, 3, 1, 2, 3]. Without parentheses, * would happen first due to precedence.

Parentheses change order:
• ([1, 2] + [3]) * 2 = [1, 2, 3, 1, 2, 3]
• Parentheses override precedence
• [1, 2] + [3] evaluated first: [1, 2, 3]
• Then [1, 2, 3] * 2: [1, 2, 3, 1, 2, 3]
• Addition before multiplication

How it works:
• Expression: ([1, 2] + [3]) * 2
• Parentheses: force + first
• Step 1: ([1, 2] + [3]) = [1, 2, 3] (addition first)
• Step 2: [1, 2, 3] * 2 = [1, 2, 3, 1, 2, 3] (multiplication second)
• Returns: [1, 2, 3, 1, 2, 3]

Example:
([1, 2] + [3]) * 2   # [1, 2, 3, 1, 2, 3] (+ first)
[1, 2] + [3] * 2     # [1, 2, 3, 3] (* first, no parentheses)
([1, 2] + [3, 4]) * 2 # [1, 2, 3, 4, 1, 2, 3, 4]

Common uses:
• Controlling order: result = (list1 + list2) * n
• Explicit grouping: combined = (items1 + items2) * repeat
• Precedence control
• Expression grouping

Example: ([1, 2] + [3]) * 2 returns [1, 2, 3, 1, 2, 3] because parentheses force the + operation to happen first (creating [1, 2, 3]), then * 2 repeats that list twice.
`
  }),
  (_i: number) => ({ 
    q: `What is len([1, 2] + [3, 4])?`, 
    o: ["4", "2", "3", "Error"], 
    c: 0, 
    e: "Concatenated list has sum of lengths.",
    de: `The len() function returns the total number of elements in a list. len([1, 2] + [3, 4]) returns 4 because + concatenates the two lists into [1, 2, 3, 4], which has 4 elements. The length of a concatenated list is the sum of the lengths of the original lists. len() counts all elements in the resulting list, regardless of how the list was created.

len() of concatenated list:
• len([1, 2] + [3, 4]) = 4
• + concatenates: [1, 2] + [3, 4] = [1, 2, 3, 4]
• len() counts all elements: 4
• Length is sum of original lengths: 2 + 2 = 4
• Returns total count

How it works:
• Expression: [1, 2] + [3, 4]
• Concatenates: [1, 2, 3, 4]
• len() counts elements: 1, 2, 3, 4
• Total count: 4
• Returns: 4

Example:
len([1, 2] + [3, 4]) # 4 (2 + 2 = 4)
len([1] + [2, 3])    # 3 (1 + 2 = 3)
len([1, 2, 3] + [])  # 3 (3 + 0 = 3)

Common uses:
• Getting total length: total = len(list1 + list2)
• Calculating combined size: count = len(items1 + items2)
• Total count
• Combined length

Example: len([1, 2] + [3, 4]) returns 4 because + concatenates the lists into [1, 2, 3, 4], which has 4 elements, and len() counts all elements in the concatenated list.
`
  }),
];

// --- LEVEL 6: SEAL (Dictionaries, Key-Value, Hashing) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level6Patterns = [
  // 1-10: Dictionary Creation and Basics
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}?`, 
    o: ["A dictionary", "A list", "A tuple", "A set"], 
    c: 0, 
    e: "Curly braces with key:value pairs create a dictionary.",
    de: `Curly braces {} with key:value pairs create a dictionary in Python. {'a': 1, 'b': 2} is a dictionary containing two key-value pairs: 'a' maps to 1 and 'b' maps to 2. Dictionaries are unordered collections (in Python 3.7+ they maintain insertion order) that map keys to values. Keys must be immutable types (strings, numbers, tuples), and values can be any type. This is Python's primary mapping type.

Dictionary creation:
• {'a': 1, 'b': 2} = dictionary with two pairs
• Curly braces {} with key:value pairs
• Keys map to values: 'a' → 1, 'b' → 2
• Keys must be immutable
• Values can be any type

How it works:
• Python recognizes {} with key:value pairs as dictionary
• 'a': 1 creates mapping from 'a' to 1
• 'b': 2 creates mapping from 'b' to 2
• Creates dictionary object in memory
• Returns dictionary type

Example:
{'a': 1, 'b': 2}         # Dictionary of strings to integers
{1: 'a', 2: 'b'}         # Dictionary of integers to strings
{'name': 'Alice', 'age': 30}  # Mixed value types
{}                       # Empty dictionary

Common uses:
• Key-value storage: data = {'key': value}
• Mapping relationships: mapping = {k: v for k, v in pairs}
• Configuration: config = {'setting': value}
• Data structures

Example: {'a': 1, 'b': 2} creates a dictionary object containing two key-value pairs, where 'a' maps to 1 and 'b' maps to 2.
`
  }),
  (_i: number) => ({ 
    q: `What is {}?`, 
    o: ["Empty dictionary", "Empty set", "Error", "None"], 
    c: 0, 
    e: "Empty dictionary literal.",
    de: `Empty curly braces {} create an empty dictionary in Python. {} is a dictionary literal that contains no key-value pairs. Empty dictionaries are falsy in boolean contexts (they evaluate to False), but they are still valid dictionary objects. Empty dictionaries are useful as placeholders or starting points for building dictionaries dynamically. Note: {} creates an empty dictionary, not an empty set - sets require set() or at least one element.

Empty dictionary:
• {} = empty dictionary (no key-value pairs)
• Curly braces with nothing inside
• Valid dictionary object, just has zero length
• Falsy in boolean contexts: bool({}) = False
• Length is 0: len({}) = 0

How it works:
• Python recognizes {} as empty dictionary literal
• Creates a dictionary object with no pairs
• Still a valid dictionary type
• Can be used immediately for operations
• Returns empty dictionary object

Example:
{}                   # Empty dictionary
bool({})             # False (falsy)
len({})              # 0 (zero length)
{}['key'] = 'value'  # {'key': 'value'} (can add pairs)

Common uses:
• Initialization: result = {}
• Placeholders: data = {}
• Starting points for building dictionaries
• Return values for empty results

Example: {} creates an empty dictionary object, which is a valid dictionary with zero key-value pairs and length 0.
`
  }),
  (_i: number) => ({ 
    q: `What is dict()?`, 
    o: ["{}", "[]", "()", "Error"], 
    c: 0, 
    e: "dict() constructor creates empty dictionary.",
    de: `Calling dict() with no arguments creates an empty dictionary, equivalent to {}. dict() is the constructor function that creates dictionaries, and when called without arguments, it creates an empty dictionary object. This is functionally identical to using the empty dictionary literal {}. The dict() constructor can also be called with arguments to create dictionaries from other structures.

dict() with no arguments:
• dict() = {} (empty dictionary)
• Constructor function with no arguments
• Creates empty dictionary object
• Equivalent to {} literal
• Returns empty dictionary

How it works:
• dict() called without arguments
• Creates new empty dictionary object
• Returns empty dictionary: {}
• Same result as {} literal
• Ready for operations

Example:
dict()               # {} (empty dictionary)
dict() == {}         # True (equivalent)
len(dict())          # 0 (zero length)
dict()['key'] = 'value' # {'key': 'value'} (can add pairs)

Common uses:
• Creating empty dictionaries: items = dict()
• Initialization: data = dict()
• Alternative to {} literal
• Constructor syntax preference

Example: dict() returns {} because calling the dict constructor without arguments creates an empty dictionary object, which is equivalent to the empty dictionary literal {}.
`
  }),
  (_i: number) => ({ 
    q: `What is dict([('a', 1), ('b', 2)])?`, 
    o: ["{'a': 1, 'b': 2}", "[('a', 1), ('b', 2)]", "Error", "None"], 
    c: 0, 
    e: "dict() can be created from list of tuples.",
    de: `The dict() constructor can create a dictionary from a list of key-value pairs (tuples). dict([('a', 1), ('b', 2)]) returns {'a': 1, 'b': 2} because dict() iterates through the list of tuples, treating each tuple as a key-value pair where the first element is the key and the second element is the value. This is useful for converting structured data (like pairs from another source) into a dictionary.

dict() from list of tuples:
• dict([('a', 1), ('b', 2)]) = {'a': 1, 'b': 2}
• dict() creates dictionary from list of (key, value) tuples
• Each tuple becomes a key-value pair
• First element is key, second element is value
• Returns dictionary object

How it works:
• dict() called with [('a', 1), ('b', 2)]
• Iterates through list of tuples
• ('a', 1) becomes key 'a' → value 1
• ('b', 2) becomes key 'b' → value 2
• Returns dictionary: {'a': 1, 'b': 2}

Example:
dict([('a', 1), ('b', 2)])  # {'a': 1, 'b': 2}
dict([(1, 'a'), (2, 'b')])  # {1: 'a', 2: 'b'}
dict([('x', 10), ('y', 20)]) # {'x': 10, 'y': 20}

Common uses:
• Converting pairs: mapping = dict(pairs)
• Creating from tuples: data = dict(tuple_list)
• List-to-dict conversion
• Pair conversion

Example: dict([('a', 1), ('b', 2)]) returns {'a': 1, 'b': 2} because dict() creates a dictionary from the list of tuples, treating each tuple as a key-value pair.
`
  }),
  (_i: number) => ({ 
    q: `What is dict(a=1, b=2)?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "dict() can use keyword arguments.",
    de: `The dict() constructor can create a dictionary from keyword arguments. dict(a=1, b=2) returns {'a': 1, 'b': 2} because dict() treats each keyword argument as a key-value pair where the keyword name becomes the key (as a string) and the argument value becomes the value. This is a convenient way to create dictionaries when keys are valid Python identifiers (strings that can be variable names).

dict() with keyword arguments:
• dict(a=1, b=2) = {'a': 1, 'b': 2}
• dict() creates dictionary from keyword arguments
• Keyword names become keys (as strings)
• Argument values become values
• Keys must be valid identifiers

How it works:
• dict() called with keyword arguments a=1, b=2
• Keyword 'a' becomes key 'a' (string)
• Value 1 becomes value 1
• Keyword 'b' becomes key 'b' (string)
• Value 2 becomes value 2
• Returns dictionary: {'a': 1, 'b': 2}

Example:
dict(a=1, b=2)        # {'a': 1, 'b': 2}
dict(x=10, y=20)      # {'x': 10, 'y': 20}
dict(name='Alice', age=30) # {'name': 'Alice', 'age': 30}

Common uses:
• Creating dictionaries: data = dict(key=value)
• Convenient syntax: mapping = dict(a=1, b=2)
• Keyword-based creation
• Named parameter dictionaries

Example: dict(a=1, b=2) returns {'a': 1, 'b': 2} because dict() creates a dictionary from keyword arguments, where each keyword name becomes a string key and its value becomes the corresponding value.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}['a']?`, 
    o: ["1", "'a'", "2", "Error"], 
    c: 0, 
    e: "Dictionary access by key using square brackets.",
    de: `Dictionary access uses square brackets with the key to retrieve the corresponding value. {'a': 1, 'b': 2}['a'] returns 1 because ['a'] accesses the value associated with the key 'a'. The key is specified in square brackets after the dictionary, and Python returns the value mapped to that key. If the key doesn't exist, this raises a KeyError.

Dictionary access:
• {'a': 1, 'b': 2}['a'] = 1 (returns value for key)
• Square brackets [] with key
• Returns value associated with key
• Key must exist (or raises KeyError)
• Access by key, not index

How it works:
• {'a': 1, 'b': 2} is the dictionary
• ['a'] is the key in square brackets
• Python looks up key 'a' in dictionary
• Finds mapping: 'a' → 1
• Returns value: 1

Example:
{'a': 1, 'b': 2}['a']  # 1 (value for key 'a')
{'a': 1, 'b': 2}['b']  # 2 (value for key 'b')
{'a': 1, 'b': 2}['c']  # KeyError (key 'c' doesn't exist)

Common uses:
• Getting values: value = dict[key]
• Accessing data: data = items[key]
• Key-based access
• Dictionary lookup

Example: {'a': 1, 'b': 2}['a'] returns 1 because Python looks up the key 'a' in the dictionary and returns the corresponding value, which is 1.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}['b']?`, 
    o: ["2", "'b'", "1", "Error"], 
    c: 0, 
    e: "Access value using key in square brackets.",
    de: `Dictionary access retrieves the value associated with a specific key. {'a': 1, 'b': 2}['b'] returns 2 because ['b'] accesses the value associated with the key 'b'. Python looks up the key 'b' in the dictionary, finds the mapping 'b' → 2, and returns the value 2. Dictionary access is key-based, not index-based like lists - you use the key to find the value.

Dictionary access by key:
• {'a': 1, 'b': 2}['b'] = 2 (returns value for key)
• Square brackets [] with key 'b'
• Returns value associated with key 'b'
• Key-based lookup (not index-based)
• Returns value: 2

How it works:
• {'a': 1, 'b': 2} is the dictionary
• ['b'] is the key in square brackets
• Python looks up key 'b' in dictionary
• Finds mapping: 'b' → 2
• Returns value: 2

Example:
{'a': 1, 'b': 2}['b']  # 2 (value for key 'b')
{'x': 10, 'y': 20}['y'] # 20 (value for key 'y')
{'a': 1, 'b': 2}['c']  # KeyError (key doesn't exist)

Common uses:
• Getting values: value = dict[key]
• Accessing data: data = items[key]
• Key-based lookup
• Dictionary retrieval

Example: {'a': 1, 'b': 2}['b'] returns 2 because Python looks up the key 'b' in the dictionary and returns the corresponding value, which is 2.
`
  }),
  (_i: number) => ({ 
    q: `What happens if you access a non-existent key with []?`, 
    o: ["KeyError", "Returns None", "Returns empty dict", "Error"], 
    c: 0, 
    e: "Accessing non-existent key raises KeyError.",
    de: `Accessing a non-existent key in a dictionary using square brackets [] raises a KeyError. If you try to access a key that doesn't exist like {'a': 1, 'b': 2}['c'], Python raises a KeyError with a message indicating that the key was not found. This is different from using .get() method, which returns None (or a default value) for non-existent keys. KeyError indicates that the key doesn't exist in the dictionary.

Accessing non-existent key:
• {'a': 1, 'b': 2}['c'] raises KeyError
• Key 'c' doesn't exist in dictionary
• Square bracket access [] raises KeyError
• Must use .get() for safe access
• Error message: "KeyError: 'c'"

How it works:
• Accessing ['c'] on {'a': 1, 'b': 2}
• Python searches for key 'c' in dictionary
• Finds no match (key doesn't exist)
• Raises KeyError
• Cannot return value for non-existent key

Example:
{'a': 1, 'b': 2}['c']  # KeyError: 'c'
d = {'a': 1, 'b': 2}
d['x']                 # KeyError: 'x'
if 'c' in d:           # Check first
    d['c']             # Safe to access

Common uses:
• Error handling: try/except for KeyError
• Checking first: if key in dict: dict[key]
• Safe access: value = dict.get(key)
• Key existence validation

Example: Accessing a non-existent key like {'a': 1, 'b': 2}['c'] raises a KeyError because Python cannot find the key 'c' in the dictionary, and square bracket access requires the key to exist.
`
  }),
  (_i: number) => ({ 
    q: `What is len({'a': 1, 'b': 2})?`, 
    o: ["2", "1", "0", "Error"], 
    c: 0, 
    e: "len() returns number of key-value pairs.",
    de: `The len() function returns the number of key-value pairs in a dictionary. len({'a': 1, 'b': 2}) returns 2 because the dictionary contains two key-value pairs: 'a': 1 and 'b': 2. len() counts pairs, not individual keys or values - each key-value pair counts as one unit. This is consistent with how len() works on other collections - it returns the number of items in the collection.

len() on dictionary:
• len({'a': 1, 'b': 2}) = 2 (number of pairs)
• len() counts key-value pairs
• Each pair counts as one
• Returns integer count
• Works with any dictionary

How it works:
• len() called with {'a': 1, 'b': 2}
• Counts key-value pairs in dictionary
• Finds two pairs: 'a': 1, 'b': 2
• Returns count: 2
• Returns integer: 2

Example:
len({'a': 1, 'b': 2})  # 2 (two pairs)
len({'a': 1})          # 1 (one pair)
len({})                # 0 (empty dictionary)
len({'a': 1, 'b': 2, 'c': 3}) # 3 (three pairs)

Common uses:
• Checking size: if len(dict) > 0:
• Getting count: count = len(data)
• Size validation
• Pair counting

Example: len({'a': 1, 'b': 2}) returns 2 because len() counts the number of key-value pairs in the dictionary, which is 2.
`
  }),
  (_i: number) => ({ 
    q: `What is len({})?`, 
    o: ["0", "1", "Error", "None"], 
    c: 0, 
    e: "Empty dictionary has length 0.",
    de: `An empty dictionary has a length of 0 because it contains no key-value pairs. len({}) returns 0 because the empty dictionary {} has zero pairs. len() counts the number of key-value pairs in a dictionary, and an empty dictionary naturally has zero pairs. Empty dictionaries are falsy in boolean contexts but are still valid dictionary objects.

Empty dictionary length:
• len({}) = 0 (zero pairs)
• Empty dictionary contains no pairs
• Length is 0 by definition
• Valid dictionary object, just empty
• Falsy but exists

How it works:
• len() takes empty dictionary {} as argument
• Counts key-value pairs in dictionary
• Finds zero pairs
• Returns 0
• Empty dictionaries always return 0

Example:
len({})               # 0 (empty dictionary)
len(dict())           # 0 (empty dictionary)
bool({})              # False (falsy but exists)
{}['key'] = 'value'   # {'key': 'value'} (can add pairs)

Common uses:
• Checking if empty: if len(items) == 0:
• Validation: if len(data) > 0:
• Empty check
• Size verification

Example: len({}) returns 0 because the empty dictionary contains zero key-value pairs, and len() counts and returns the number of pairs (which is 0 for an empty dictionary).
`
  }),
  
  // 11-20: Dictionary Methods - Accessing Values
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.get('a')?`, 
    o: ["1", "'a'", "2", "Error"], 
    c: 0, 
    e: "get() returns value for key.",
    de: `The get() method returns the value associated with a key, or None if the key doesn't exist. {'a': 1, 'b': 2}.get('a') returns 1 because get() looks up the key 'a' in the dictionary and returns its value. Unlike square bracket access [], get() doesn't raise an error if the key doesn't exist - it returns None (or a default value if provided). This makes get() safer for accessing potentially missing keys.

get() method:
• {'a': 1, 'b': 2}.get('a') = 1 (returns value)
• get(key) returns value for key
• Returns None if key not found (no default)
• Safe access (no KeyError)
• Works with any key

How it works:
• get('a') called on {'a': 1, 'b': 2}
• Searches for key 'a' in dictionary
• Finds mapping: 'a' → 1
• Returns value: 1
• No error if key not found

Example:
{'a': 1, 'b': 2}.get('a')  # 1 (value for key)
{'a': 1, 'b': 2}.get('c')  # None (key not found, no error)
{'a': 1, 'b': 2}.get('b')  # 2 (value for key)

Common uses:
• Safe access: value = dict.get(key)
• Avoiding KeyError: data = items.get(key)
• Default value access
• Safe dictionary lookup

Example: {'a': 1, 'b': 2}.get('a') returns 1 because get() looks up the key 'a' in the dictionary and returns its value, which is 1.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.get('c')?`, 
    o: ["None", "Error", "0", "'c'"], 
    c: 0, 
    e: "get() returns None if key not found (no default).",
    de: `The get() method returns None when a key doesn't exist and no default value is provided. {'a': 1, 'b': 2}.get('c') returns None because get() searches for the key 'c' in the dictionary, doesn't find it, and returns None instead of raising an error. This is the safe way to access dictionary values - it never raises a KeyError, but returns None for missing keys (unless you provide a default value).

get() - key not found:
• {'a': 1, 'b': 2}.get('c') = None
• get(key) returns None if key not found
• No default provided
• No error raised (unlike [])
• Safe access method

How it works:
• get('c') called on {'a': 1, 'b': 2}
• Searches for key 'c' in dictionary
• Finds no match (key doesn't exist)
• Returns None (no error)
• Safe behavior

Example:
{'a': 1, 'b': 2}.get('c')  # None (not found, no error)
{'a': 1, 'b': 2}.get('x')  # None (not found, no error)
{'a': 1, 'b': 2}.get('c', 0) # 0 (not found, returns default)

Common uses:
• Safe access: value = dict.get(key) (might be None)
• Checking existence: if dict.get(key): ...
• Default handling: result = items.get(key) or default
• Error-free access

Example: {'a': 1, 'b': 2}.get('c') returns None because get() searches for the key 'c' in the dictionary, doesn't find it, and returns None instead of raising a KeyError.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.get('c', 0)?`, 
    o: ["0", "None", "Error", "'c'"], 
    c: 0, 
    e: "get() returns default if key not found.",
    de: `The get() method can take a second argument as a default value to return if the key doesn't exist. {'a': 1, 'b': 2}.get('c', 0) returns 0 because get() searches for the key 'c' in the dictionary, doesn't find it, and returns the default value (0) instead of None. This is useful when you want a specific value for missing keys rather than None.

get() with default:
• {'a': 1, 'b': 2}.get('c', 0) = 0 (returns default)
• get(key, default) returns default if key not found
• Default value provided
• No error raised
• Safe access with fallback

How it works:
• get('c', 0) called on {'a': 1, 'b': 2}
• Searches for key 'c' in dictionary
• Finds no match (key doesn't exist)
• Returns default value: 0
• No error raised

Example:
{'a': 1, 'b': 2}.get('c', 0)  # 0 (not found, returns default)
{'a': 1, 'b': 2}.get('c', 'missing') # 'missing' (returns default)
{'a': 1, 'b': 2}.get('a', 0)  # 1 (found, returns actual value)

Common uses:
• Default values: value = dict.get(key, default)
• Fallback values: data = items.get(key, fallback)
• Safe access with defaults
• Error-free access with fallback

Example: {'a': 1, 'b': 2}.get('c', 0) returns 0 because get() searches for the key 'c' in the dictionary, doesn't find it, and returns the default value 0 instead of None or raising an error.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.get('a', 0)?`, 
    o: ["1", "0", "None", "Error"], 
    c: 0, 
    e: "get() returns actual value if key exists, ignores default.",
    de: `The get() method returns the actual value if the key exists, even if a default value is provided. {'a': 1, 'b': 2}.get('a', 0) returns 1 because get() finds the key 'a' in the dictionary and returns its actual value (1), ignoring the default value (0). The default value is only used when the key doesn't exist - if the key exists, get() returns the actual value associated with that key.

get() with existing key:
• {'a': 1, 'b': 2}.get('a', 0) = 1 (returns actual value)
• get(key, default) returns actual value if key exists
• Default value ignored when key found
• Returns value from dictionary
• Default only used if key missing

How it works:
• get('a', 0) called on {'a': 1, 'b': 2}
• Searches for key 'a' in dictionary
• Finds mapping: 'a' → 1
• Returns actual value: 1 (ignores default 0)
• Default only used if key not found

Example:
{'a': 1, 'b': 2}.get('a', 0)  # 1 (found, returns actual value)
{'a': 1, 'b': 2}.get('b', 10) # 2 (found, returns actual value)
{'a': 1, 'b': 2}.get('c', 0)  # 0 (not found, returns default)

Common uses:
• Safe access with fallback: value = dict.get(key, default)
• Always returning value: result = items.get(key, 0)
• Default handling
• Fallback values

Example: {'a': 1, 'b': 2}.get('a', 0) returns 1 because get() finds the key 'a' in the dictionary and returns its actual value (1), ignoring the default value (0), which is only used when the key doesn't exist.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1}.setdefault('a', 2)?`, 
    o: ["1", "2", "None", "Error"], 
    c: 0, 
    e: "setdefault() returns existing value if key exists.",
    de: `The setdefault() method returns the existing value if the key already exists in the dictionary. {'a': 1}.setdefault('a', 2) returns 1 because setdefault() finds the key 'a' already exists with value 1, and returns that existing value, ignoring the default value (2). Unlike get(), setdefault() doesn't just return a value - if the key doesn't exist, it sets the key to the default value and returns it.

setdefault() with existing key:
• {'a': 1}.setdefault('a', 2) = 1 (returns existing value)
• setdefault(key, default) returns existing value if key exists
• Default value ignored when key found
• Dictionary unchanged (key already exists)
• Returns value from dictionary

How it works:
• setdefault('a', 2) called on {'a': 1}
• Searches for key 'a' in dictionary
• Finds existing mapping: 'a' → 1
• Returns existing value: 1 (ignores default 2)
• Dictionary unchanged: {'a': 1}

Example:
{'a': 1}.setdefault('a', 2)  # 1 (returns existing value)
{'a': 1}.setdefault('a', 10) # 1 (returns existing value)
{'a': 1}                     # {'a': 1} (unchanged)

Common uses:
• Getting or setting: value = dict.setdefault(key, default)
• Ensuring key exists: dict.setdefault(key, [])
• Default initialization
• Value retrieval or creation

Example: {'a': 1}.setdefault('a', 2) returns 1 because setdefault() finds the key 'a' already exists with value 1, and returns that existing value, ignoring the default value (2).
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1}.setdefault('b', 2)?`, 
    o: ["2", "1", "None", "Error"], 
    c: 0, 
    e: "setdefault() sets and returns default if key doesn't exist.",
    de: `The setdefault() method sets the key to the default value and returns it if the key doesn't exist. {'a': 1}.setdefault('b', 2) returns 2 because setdefault() searches for the key 'b' in the dictionary, doesn't find it, sets 'b' to the default value (2), and returns that value. This is different from get() - setdefault() modifies the dictionary if the key is missing, while get() doesn't modify the dictionary.

setdefault() with missing key:
• {'a': 1}.setdefault('b', 2) = 2 (sets and returns default)
• setdefault(key, default) sets key to default if missing
• Modifies dictionary in place
• Returns default value
• Dictionary changed: {'a': 1} → {'a': 1, 'b': 2}

How it works:
• setdefault('b', 2) called on {'a': 1}
• Searches for key 'b' in dictionary
• Finds no match (key doesn't exist)
• Sets 'b' to default value: 2
• Returns default value: 2
• Dictionary modified: {'a': 1, 'b': 2}

Example:
{'a': 1}.setdefault('b', 2)  # 2 (sets 'b' to 2, returns 2)
{'a': 1}                     # {'a': 1, 'b': 2} (modified)
{'a': 1}.setdefault('c', 0)  # 0 (sets 'c' to 0, returns 0)

Common uses:
• Initializing defaults: value = dict.setdefault(key, default)
• Ensuring key exists: dict.setdefault(key, [])
• Default creation
• Value initialization

Example: {'a': 1}.setdefault('b', 2) returns 2 because setdefault() doesn't find the key 'b' in the dictionary, sets 'b' to the default value (2), and returns that value, modifying the dictionary to {'a': 1, 'b': 2}.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between get() and setdefault()?`, 
    o: ["setdefault() sets key if missing, get() doesn't", "No difference", "get() is faster", "setdefault() is deprecated"], 
    c: 0, 
    e: "setdefault() modifies dict if key missing, get() doesn't.",
    de: `The key difference between get() and setdefault() is whether they modify the dictionary. get() only retrieves values - it returns None (or a default) if the key doesn't exist, but never modifies the dictionary. setdefault() retrieves values if the key exists, but if the key doesn't exist, it sets the key to the default value and returns it, modifying the dictionary. Both return the same value when the key exists, but only setdefault() changes the dictionary when the key is missing.

get() vs setdefault():
• get(key, default): returns value or default, never modifies dict
• setdefault(key, default): returns value or default, sets key if missing
• get() is read-only (doesn't change dict)
• setdefault() modifies dict if key missing
• Both return same value when key exists

How it works:
• get('c', 0): searches for 'c', not found, returns 0, dict unchanged
• setdefault('c', 0): searches for 'c', not found, sets 'c' to 0, returns 0, dict modified
• Both return value when key exists
• Only setdefault() modifies when missing

Example:
d = {'a': 1}
d.get('b', 0)        # 0 (returns 0, d unchanged: {'a': 1})
d.setdefault('b', 0) # 0 (returns 0, d modified: {'a': 1, 'b': 0})

Common uses:
• get(): safe read-only access: value = dict.get(key, default)
• setdefault(): ensure key exists: value = dict.setdefault(key, default)
• Choose based on whether you want to modify dict
• Important distinction for dictionary behavior

Example: The difference is get() only retrieves values and never modifies the dictionary (e.g., {'a': 1}.get('b', 0) returns 0 but doesn't change the dict), while setdefault() modifies the dictionary if the key is missing (e.g., {'a': 1}.setdefault('b', 0) returns 0 and adds 'b': 0 to the dict).
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.pop('a')?`, 
    o: ["1", "{'b': 2}", "None", "Error"], 
    c: 0, 
    e: "pop() returns and removes value for key.",
    de: `The pop() method removes a key-value pair from a dictionary and returns the value. {'a': 1, 'b': 2}.pop('a') returns 1 because pop() finds the key 'a' in the dictionary, removes the pair 'a': 1, and returns the value 1. After calling pop('a'), the dictionary becomes {'b': 2} - the key-value pair is removed. pop() modifies the dictionary in place and returns the removed value.

pop() method:
• {'a': 1, 'b': 2}.pop('a') = 1 (returns removed value)
• pop(key) removes key-value pair
• Modifies dictionary in place
• Returns the removed value
• Dictionary changed: {'a': 1, 'b': 2} → {'b': 2}

How it works:
• pop('a') called on {'a': 1, 'b': 2}
• Searches for key 'a' in dictionary
• Finds mapping: 'a' → 1
• Removes pair 'a': 1 from dictionary
• Returns removed value: 1
• Dictionary modified: {'b': 2}

Example:
d = {'a': 1, 'b': 2}
d.pop('a')            # 1 (returns removed value)
d                     # {'b': 2} (modified)
{'a': 1, 'b': 2}.pop('b') # 2 (returns removed value)

Common uses:
• Removing pairs: value = dict.pop(key)
• Getting and removing: removed = items.pop(key)
• Dictionary cleanup
• In-place modification

Example: {'a': 1, 'b': 2}.pop('a') returns 1 because pop() removes the key-value pair 'a': 1 from the dictionary and returns the removed value, leaving the dictionary as {'b': 2}.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.pop('c')?`, 
    o: ["KeyError", "None", "0", "Error"], 
    c: 0, 
    e: "pop() raises KeyError if key not found (no default).",
    de: `The pop() method raises a KeyError when called with a non-existent key and no default value is provided. {'a': 1, 'b': 2}.pop('c') raises a KeyError because pop() searches for the key 'c' in the dictionary, doesn't find it, and raises an error since there's no value to remove and return. This is different from get(), which returns None for missing keys - pop() requires the key to exist (or a default value to be provided) because it removes the pair.

pop() - key not found:
• {'a': 1, 'b': 2}.pop('c') raises KeyError
• Key 'c' doesn't exist in dictionary
• pop() requires key to exist (no default)
• Raises KeyError (cannot remove non-existent key)
• Error message: "KeyError: 'c'"

How it works:
• pop('c') called on {'a': 1, 'b': 2}
• Searches for key 'c' in dictionary
• Finds no match (key doesn't exist)
• Cannot remove non-existent pair
• Raises KeyError
• No value to return

Example:
{'a': 1, 'b': 2}.pop('c')  # KeyError: 'c'
d = {'a': 1, 'b': 2}
d.pop('x')                 # KeyError: 'x'
if 'c' in d:               # Check first
    d.pop('c')             # Safe to pop

Common uses:
• Error handling: try/except for KeyError
• Checking first: if key in dict: dict.pop(key)
• Safe removal: value = dict.pop(key, default)
• Key existence validation

Example: Calling pop() with a non-existent key like {'a': 1, 'b': 2}.pop('c') raises a KeyError because pop() cannot remove a key-value pair that doesn't exist, and no default value was provided.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.pop('c', 0)?`, 
    o: ["0", "None", "KeyError", "Error"], 
    c: 0, 
    e: "pop() returns default if key not found.",
    de: `The pop() method can take a second argument as a default value to return if the key doesn't exist, without modifying the dictionary. {'a': 1, 'b': 2}.pop('c', 0) returns 0 because pop() searches for the key 'c' in the dictionary, doesn't find it, and returns the default value (0) without raising an error. Unlike pop() without a default, this version doesn't raise a KeyError - it just returns the default value. The dictionary remains unchanged because there was no pair to remove.

pop() with default:
• {'a': 1, 'b': 2}.pop('c', 0) = 0 (returns default)
• pop(key, default) returns default if key not found
• No error raised (unlike pop() without default)
• Dictionary unchanged (no pair to remove)
• Returns default value

How it works:
• pop('c', 0) called on {'a': 1, 'b': 2}
• Searches for key 'c' in dictionary
• Finds no match (key doesn't exist)
• Cannot remove non-existent pair
• Returns default value: 0 (no error)
• Dictionary unchanged: {'a': 1, 'b': 2}

Example:
{'a': 1, 'b': 2}.pop('c', 0)  # 0 (not found, returns default)
{'a': 1, 'b': 2}.pop('c', 'missing') # 'missing' (returns default)
{'a': 1, 'b': 2}              # {'a': 1, 'b': 2} (unchanged)

Common uses:
• Safe removal: value = dict.pop(key, default)
• Default handling: removed = items.pop(key, fallback)
• Error-free removal
• Safe pop with fallback

Example: {'a': 1, 'b': 2}.pop('c', 0) returns 0 because pop() searches for the key 'c' in the dictionary, doesn't find it, and returns the default value (0) without raising an error, leaving the dictionary unchanged.
`
  }),
  
  // 21-30: Dictionary Methods - Keys, Values, Items
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.keys()?`, 
    o: ["dict_keys(['a', 'b'])", "['a', 'b']", "{'a', 'b'}", "Error"], 
    c: 0, 
    e: "keys() returns dict_keys view object.",
    de: `The keys() method returns a view object that displays all keys in the dictionary. {'a': 1, 'b': 2}.keys() returns a dict_keys(['a', 'b']) object because keys() creates a view of the dictionary's keys. A view object is a dynamic view of the dictionary - it reflects changes made to the dictionary. The view is not a list, but it can be converted to a list using list(). Views are memory-efficient and update automatically when the dictionary changes.

keys() method:
• {'a': 1, 'b': 2}.keys() = dict_keys(['a', 'b'])
• keys() returns dict_keys view object
• View reflects dictionary keys
• Not a list (but can be converted)
• Updates automatically when dict changes

How it works:
• keys() called on {'a': 1, 'b': 2}
• Creates view object of keys
• View contains: 'a', 'b'
• Returns dict_keys view: dict_keys(['a', 'b'])
• View updates if dictionary changes

Example:
{'a': 1, 'b': 2}.keys()  # dict_keys(['a', 'b'])
list({'a': 1, 'b': 2}.keys()) # ['a', 'b'] (converted to list)
for key in {'a': 1, 'b': 2}.keys():  # Iterates: 'a', 'b'
    print(key)

Common uses:
• Getting keys: keys = dict.keys()
• Iterating keys: for key in dict.keys():
• Key iteration
• Dictionary key access

Example: {'a': 1, 'b': 2}.keys() returns a dict_keys(['a', 'b']) view object because keys() creates a dynamic view of all keys in the dictionary, which can be iterated or converted to a list.
`
  }),
  (_i: number) => ({ 
    q: `What is list({'a': 1, 'b': 2}.keys())?`, 
    o: ["['a', 'b']", "dict_keys(['a', 'b'])", "{'a', 'b'}", "Error"], 
    c: 0, 
    e: "list() converts keys view to list.",
    de: `The list() function can convert a dict_keys view to a list. list({'a': 1, 'b': 2}.keys()) returns ['a', 'b'] because list() consumes the view object created by keys() and collects all keys into a new list. The keys() method returns a view object, and list() iterates through that view, collecting all keys into a list. This is how you get an actual list of keys from keys().

list(keys()):
• list({'a': 1, 'b': 2}.keys()) = ['a', 'b']
• keys() returns dict_keys view
• list() consumes view
• Collects keys into new list
• Creates list of keys

How it works:
• keys() called on {'a': 1, 'b': 2}
• Returns dict_keys view: ['a', 'b']
• list() iterates through view
• Collects keys: 'a', 'b'
• Returns new list: ['a', 'b']

Example:
list({'a': 1, 'b': 2}.keys())  # ['a', 'b'] (list of keys)
list({'x': 10, 'y': 20}.keys()) # ['x', 'y'] (list of keys)
list({}.keys())                 # [] (empty list)

Common uses:
• Getting key list: key_list = list(dict.keys())
• Creating key list: keys = list(items.keys())
• Converting view to list
• Key list creation

Example: list({'a': 1, 'b': 2}.keys()) returns ['a', 'b'] because list() consumes the dict_keys view created by keys() and collects all keys into a new list.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.values()?`, 
    o: ["dict_values([1, 2])", "[1, 2]", "{1, 2}", "Error"], 
    c: 0, 
    e: "values() returns dict_values view object.",
    de: `The values() method returns a view object that displays all values in the dictionary. {'a': 1, 'b': 2}.values() returns a dict_values([1, 2]) object because values() creates a view of the dictionary's values. A view object is a dynamic view of the dictionary - it reflects changes made to the dictionary. The view is not a list, but it can be converted to a list using list(). Views are memory-efficient and update automatically when the dictionary changes.

values() method:
• {'a': 1, 'b': 2}.values() = dict_values([1, 2])
• values() returns dict_values view object
• View reflects dictionary values
• Not a list (but can be converted)
• Updates automatically when dict changes

How it works:
• values() called on {'a': 1, 'b': 2}
• Creates view object of values
• View contains: 1, 2
• Returns dict_values view: dict_values([1, 2])
• View updates if dictionary changes

Example:
{'a': 1, 'b': 2}.values()  # dict_values([1, 2])
list({'a': 1, 'b': 2}.values()) # [1, 2] (converted to list)
for value in {'a': 1, 'b': 2}.values():  # Iterates: 1, 2
    print(value)

Common uses:
• Getting values: values = dict.values()
• Iterating values: for value in dict.values():
• Value iteration
• Dictionary value access

Example: {'a': 1, 'b': 2}.values() returns a dict_values([1, 2]) view object because values() creates a dynamic view of all values in the dictionary, which can be iterated or converted to a list.
`
  }),
  (_i: number) => ({ 
    q: `What is list({'a': 1, 'b': 2}.values())?`, 
    o: ["[1, 2]", "dict_values([1, 2])", "{1, 2}", "Error"], 
    c: 0, 
    e: "list() converts values view to list.",
    de: `The list() function can convert a dict_values view to a list. list({'a': 1, 'b': 2}.values()) returns [1, 2] because list() consumes the view object created by values() and collects all values into a new list. The values() method returns a view object, and list() iterates through that view, collecting all values into a list. This is how you get an actual list of values from values().

list(values()):
• list({'a': 1, 'b': 2}.values()) = [1, 2]
• values() returns dict_values view
• list() consumes view
• Collects values into new list
• Creates list of values

How it works:
• values() called on {'a': 1, 'b': 2}
• Returns dict_values view: [1, 2]
• list() iterates through view
• Collects values: 1, 2
• Returns new list: [1, 2]

Example:
list({'a': 1, 'b': 2}.values())  # [1, 2] (list of values)
list({'x': 10, 'y': 20}.values()) # [10, 20] (list of values)
list({}.values())                 # [] (empty list)

Common uses:
• Getting value list: value_list = list(dict.values())
• Creating value list: values = list(items.values())
• Converting view to list
• Value list creation

Example: list({'a': 1, 'b': 2}.values()) returns [1, 2] because list() consumes the dict_values view created by values() and collects all values into a new list.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.items()?`, 
    o: ["dict_items([('a', 1), ('b', 2)])", "[('a', 1), ('b', 2)]", "Error", "None"], 
    c: 0, 
    e: "items() returns dict_items view of key-value pairs.",
    de: `The items() method returns a view object that displays all key-value pairs in the dictionary as tuples. {'a': 1, 'b': 2}.items() returns a dict_items([('a', 1), ('b', 2)]) object because items() creates a view of the dictionary's key-value pairs, where each pair is represented as a tuple (key, value). A view object is a dynamic view of the dictionary - it reflects changes made to the dictionary. The view is not a list, but it can be converted to a list using list().

items() method:
• {'a': 1, 'b': 2}.items() = dict_items([('a', 1), ('b', 2)])
• items() returns dict_items view object
• View contains (key, value) tuples
• Not a list (but can be converted)
• Updates automatically when dict changes

How it works:
• items() called on {'a': 1, 'b': 2}
• Creates view object of key-value pairs
• View contains: ('a', 1), ('b', 2)
• Returns dict_items view: dict_items([('a', 1), ('b', 2)])
• View updates if dictionary changes

Example:
{'a': 1, 'b': 2}.items()  # dict_items([('a', 1), ('b', 2)])
list({'a': 1, 'b': 2}.items()) # [('a', 1), ('b', 2)] (converted to list)
for key, value in {'a': 1, 'b': 2}.items():  # Iterates: ('a', 1), ('b', 2)
    print(key, value)

Common uses:
• Getting pairs: pairs = dict.items()
• Iterating pairs: for key, value in dict.items():
• Pair iteration
• Dictionary pair access

Example: {'a': 1, 'b': 2}.items() returns a dict_items([('a', 1), ('b', 2)]) view object because items() creates a dynamic view of all key-value pairs in the dictionary as tuples, which can be iterated or converted to a list.
`
  }),
  (_i: number) => ({ 
    q: `What is list({'a': 1, 'b': 2}.items())?`, 
    o: ["[('a', 1), ('b', 2)]", "dict_items([('a', 1), ('b', 2)])", "Error", "None"], 
    c: 0, 
    e: "list() converts items view to list of tuples.",
    de: `The list() function can convert a dict_items view to a list of tuples. list({'a': 1, 'b': 2}.items()) returns [('a', 1), ('b', 2)] because list() consumes the view object created by items() and collects all key-value pairs as tuples into a new list. The items() method returns a view object, and list() iterates through that view, collecting all pairs as (key, value) tuples into a list. This is how you get an actual list of key-value pairs from items().

list(items()):
• list({'a': 1, 'b': 2}.items()) = [('a', 1), ('b', 2)]
• items() returns dict_items view
• list() consumes view
• Collects pairs as tuples into new list
• Creates list of (key, value) tuples

How it works:
• items() called on {'a': 1, 'b': 2}
• Returns dict_items view: [('a', 1), ('b', 2)]
• list() iterates through view
• Collects pairs as tuples: ('a', 1), ('b', 2)
• Returns new list: [('a', 1), ('b', 2)]

Example:
list({'a': 1, 'b': 2}.items())  # [('a', 1), ('b', 2)] (list of tuples)
list({'x': 10, 'y': 20}.items()) # [('x', 10), ('y', 20)] (list of tuples)
list({}.items())                 # [] (empty list)

Common uses:
• Getting pair list: pair_list = list(dict.items())
• Creating pair list: pairs = list(items.items())
• Converting view to list
• Pair list creation

Example: list({'a': 1, 'b': 2}.items()) returns [('a', 1), ('b', 2)] because list() consumes the dict_items view created by items() and collects all key-value pairs as tuples into a new list.
`
  }),
  (_i: number) => ({ 
    q: `What is 'a' in {'a': 1, 'b': 2}?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in checks for key membership (not value).",
    de: `The in operator checks for key membership in a dictionary, not value membership. 'a' in {'a': 1, 'b': 2} returns True because in searches for the key 'a' in the dictionary and finds it. The in operator for dictionaries only checks keys, not values - it doesn't search through values. This is important to remember: in with dictionaries is key-based, not value-based.

in operator with dictionary:
• 'a' in {'a': 1, 'b': 2} = True
• in checks if key exists in dictionary
• Searches keys only (not values)
• Returns True if key found
• Returns False if key not found

How it works:
• 'a' is the value to check
• in is membership operator
• {'a': 1, 'b': 2} is the dictionary
• Searches for key 'a' in dictionary
• Finds key 'a', returns True

Example:
'a' in {'a': 1, 'b': 2}  # True (key 'a' exists)
'c' in {'a': 1, 'b': 2}  # False (key 'c' doesn't exist)
1 in {'a': 1, 'b': 2}    # False (1 is a value, not a key)

Common uses:
• Checking key existence: if key in dict:
• Key validation: if item in items:
• Key membership check
• Dictionary key verification

Example: 'a' in {'a': 1, 'b': 2} returns True because the in operator checks if 'a' exists as a key in the dictionary, and it finds the key 'a'.
`
  }),
  (_i: number) => ({ 
    q: `What is 1 in {'a': 1, 'b': 2}?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "in checks keys, not values.",
    de: `The in operator checks for key membership in a dictionary, not value membership. 1 in {'a': 1, 'b': 2} returns False because in searches for the key 1 in the dictionary, but the keys are 'a' and 'b' (strings), not 1. Even though 1 is a value in the dictionary, in only checks keys. To check if a value exists, you need to use .values() or iterate through values.

in operator - keys only:
• 1 in {'a': 1, 'b': 2} = False
• in checks if key exists in dictionary
• Searches keys only (not values)
• Key 1 doesn't exist (keys are 'a', 'b')
• Returns False (key not found)

How it works:
• 1 is the value to check
• in is membership operator
• {'a': 1, 'b': 2} is the dictionary
• Searches for key 1 in dictionary
• Keys are 'a' and 'b', not 1
• Returns False (key not found)

Example:
1 in {'a': 1, 'b': 2}    # False (1 is not a key)
2 in {'a': 1, 'b': 2}    # False (2 is not a key)
'a' in {'a': 1, 'b': 2}  # True ('a' is a key)

Common uses:
• Understanding in checks keys: if value in dict: (checks keys!)
• Checking values: if value in dict.values(): (checks values)
• Key vs value membership
• Dictionary membership check

Example: 1 in {'a': 1, 'b': 2} returns False because the in operator checks if 1 exists as a key in the dictionary, but the keys are 'a' and 'b', not 1. The in operator only checks keys, not values.
`
  }),
  (_i: number) => ({ 
    q: `What is 1 in {'a': 1, 'b': 2}.values()?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in with .values() checks value membership.",
    de: `The in operator with .values() checks for value membership in the dictionary. 1 in {'a': 1, 'b': 2}.values() returns True because .values() returns a view of all values, and in checks if 1 exists in those values. This is how you check if a value (not a key) exists in a dictionary - you need to use .values() because in with a dictionary directly only checks keys.

in with .values():
• 1 in {'a': 1, 'b': 2}.values() = True
• .values() returns view of all values
• in checks if value exists in values view
• Searches through values (not keys)
• Returns True if value found

How it works:
• 1 is the value to check
• in is membership operator
• {'a': 1, 'b': 2}.values() is values view: [1, 2]
• Searches for value 1 in values view
• Finds value 1, returns True

Example:
1 in {'a': 1, 'b': 2}.values()  # True (1 is a value)
3 in {'a': 1, 'b': 2}.values()  # False (3 is not a value)
'a' in {'a': 1, 'b': 2}.values() # False ('a' is not a value)

Common uses:
• Checking value existence: if value in dict.values():
• Value membership: if item in items.values():
• Value-based membership check
• Dictionary value verification

Example: 1 in {'a': 1, 'b': 2}.values() returns True because .values() returns a view of all values (1, 2), and the in operator checks if 1 exists in those values, which it does.
`
  }),
  (_i: number) => ({ 
    q: `What is ('a', 1) in {'a': 1, 'b': 2}.items()?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "in with .items() checks for key-value pair.",
    de: `The in operator with .items() checks for key-value pair membership in the dictionary. ('a', 1) in {'a': 1, 'b': 2}.items() returns True because .items() returns a view of all key-value pairs as tuples, and in checks if the tuple ('a', 1) exists in those pairs. This is how you check if a specific key-value pair exists in a dictionary - you need to use .items() and provide the pair as a tuple.

in with .items():
• ('a', 1) in {'a': 1, 'b': 2}.items() = True
• .items() returns view of all (key, value) tuples
• in checks if tuple exists in items view
• Searches through pairs (not individual keys or values)
• Returns True if pair found

How it works:
• ('a', 1) is the tuple to check
• in is membership operator
• {'a': 1, 'b': 2}.items() is items view: [('a', 1), ('b', 2)]
• Searches for tuple ('a', 1) in items view
• Finds pair ('a', 1), returns True

Example:
('a', 1) in {'a': 1, 'b': 2}.items()  # True (pair exists)
('a', 2) in {'a': 1, 'b': 2}.items()  # False (pair doesn't exist)
('c', 1) in {'a': 1, 'b': 2}.items()  # False (pair doesn't exist)

Common uses:
• Checking pair existence: if (key, value) in dict.items():
• Pair membership: if pair in items.items():
• Pair-based membership check
• Dictionary pair verification

Example: ('a', 1) in {'a': 1, 'b': 2}.items() returns True because .items() returns a view of all key-value pairs as tuples [('a', 1), ('b', 2)], and the in operator checks if the tuple ('a', 1) exists in those pairs, which it does.
`
  }),
  
  // 31-40: Dictionary Methods - Modifying
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; d['b'] = 2; d?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "Assignment adds or updates key-value pair.",
    de: `Assignment with square brackets adds a new key-value pair to a dictionary if the key doesn't exist. If d = {'a': 1} and then d['b'] = 2, the dictionary d becomes {'a': 1, 'b': 2} because assignment with a new key adds that key-value pair to the dictionary. This is how you add new pairs to a dictionary - simply assign a value to a new key using square bracket notation.

Dictionary assignment - adding:
• d = {'a': 1}; d['b'] = 2; d = {'a': 1, 'b': 2}
• Assignment with new key adds pair
• d['b'] = 2 creates new key 'b' with value 2
• Modifies dictionary in place
• Dictionary changed: {'a': 1} → {'a': 1, 'b': 2}

How it works:
• d = {'a': 1} creates dictionary
• d['b'] = 2 assigns value 2 to key 'b'
• Key 'b' doesn't exist, so it's added
• Creates new pair: 'b': 2
• Dictionary modified: {'a': 1, 'b': 2}

Example:
d = {'a': 1}
d['b'] = 2            # Adds 'b': 2
d                    # {'a': 1, 'b': 2}
d['c'] = 3            # Adds 'c': 3
d                    # {'a': 1, 'b': 2, 'c': 3}

Common uses:
• Adding pairs: dict[key] = value
• Building dictionaries: items[key] = data
• Dictionary modification
• Pair addition

Example: If d = {'a': 1} and then d['b'] = 2, the dictionary d becomes {'a': 1, 'b': 2} because assignment with a new key adds that key-value pair to the dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; d['a'] = 2; d?`, 
    o: ["{'a': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "Assignment updates existing key.",
    de: `Assignment with square brackets updates an existing key-value pair if the key already exists. If d = {'a': 1} and then d['a'] = 2, the dictionary d becomes {'a': 2} because assignment with an existing key updates that key's value. The old value (1) is replaced with the new value (2). This is how you modify existing pairs in a dictionary.

Dictionary assignment - updating:
• d = {'a': 1}; d['a'] = 2; d = {'a': 2}
• Assignment with existing key updates value
• d['a'] = 2 changes value of key 'a' from 1 to 2
• Modifies dictionary in place
• Dictionary changed: {'a': 1} → {'a': 2}

How it works:
• d = {'a': 1} creates dictionary
• d['a'] = 2 assigns value 2 to key 'a'
• Key 'a' exists, so its value is updated
• Replaces old value: 1 → 2
• Dictionary modified: {'a': 2}

Example:
d = {'a': 1}
d['a'] = 2            # Updates 'a': 1 to 'a': 2
d                    # {'a': 2}
d['a'] = 10           # Updates 'a': 2 to 'a': 10
d                    # {'a': 10}

Common uses:
• Updating values: dict[key] = new_value
• Modifying dictionaries: items[key] = updated_data
• Dictionary modification
• Value updates

Example: If d = {'a': 1} and then d['a'] = 2, the dictionary d becomes {'a': 2} because assignment with an existing key updates that key's value, replacing 1 with 2.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1}.update({'b': 2})?`, 
    o: ["None", "{'a': 1, 'b': 2}", "Error", "{'b': 2}"], 
    c: 0, 
    e: "update() modifies dict in place, returns None.",
    de: `The update() method merges another dictionary into the current dictionary and returns None. {'a': 1}.update({'b': 2}) returns None because update() modifies the dictionary in place. After calling update({'b': 2}), the dictionary {'a': 1} becomes {'a': 1, 'b': 2} - the new key-value pairs from the argument dictionary are added to the original dictionary. update() doesn't return the modified dictionary - it returns None.

update() method:
• {'a': 1}.update({'b': 2}) = None (returns None)
• update() merges another dict into current dict
• Modifies dictionary in place
• Returns None (doesn't return new dict)
• Dictionary changed: {'a': 1} → {'a': 1, 'b': 2}

How it works:
• update({'b': 2}) called on {'a': 1}
• Merges {'b': 2} into {'a': 1}
• Adds new key 'b' with value 2
• Modifies original dictionary: {'a': 1, 'b': 2}
• Returns None (no return value)

Example:
d = {'a': 1}
d.update({'b': 2})    # None (returns None)
d                     # {'a': 1, 'b': 2} (modified)
{'a': 1}.update({'b': 2}) # None (returns None)

Common uses:
• Merging dictionaries: dict1.update(dict2)
• Adding multiple pairs: items.update(new_items)
• Dictionary merging
• In-place modification

Example: {'a': 1}.update({'b': 2}) returns None because update() modifies the dictionary in place (changing {'a': 1} to {'a': 1, 'b': 2}), and the method itself returns None rather than returning the modified dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; d.update({'b': 2}); d?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "update() adds/updates keys from another dict.",
    de: `The update() method merges key-value pairs from another dictionary into the current dictionary. If d = {'a': 1} and then d.update({'b': 2}), the dictionary d becomes {'a': 1, 'b': 2} because update() adds the key-value pairs from the argument dictionary to the original dictionary. New keys are added, and if keys already exist, their values are updated. update() modifies the dictionary in place.

update() - adding pairs:
• d = {'a': 1}; d.update({'b': 2}); d = {'a': 1, 'b': 2}
• update() merges pairs from argument dict
• Adds new key 'b' with value 2
• Modifies dictionary in place
• Dictionary changed: {'a': 1} → {'a': 1, 'b': 2}

How it works:
• d = {'a': 1} creates dictionary
• d.update({'b': 2}) merges {'b': 2} into d
• Adds new key 'b' with value 2
• Modifies original dictionary: {'a': 1, 'b': 2}
• Returns None (no return value)

Example:
d = {'a': 1}
d.update({'b': 2})    # None (returns None)
d                     # {'a': 1, 'b': 2} (modified)
d.update({'c': 3, 'd': 4}) # Adds multiple pairs
d                     # {'a': 1, 'b': 2, 'c': 3, 'd': 4}

Common uses:
• Merging dictionaries: dict1.update(dict2)
• Adding multiple pairs: items.update(new_items)
• Dictionary combination
• In-place merging

Example: If d = {'a': 1} and then d.update({'b': 2}), the dictionary d becomes {'a': 1, 'b': 2} because update() merges the key-value pairs from {'b': 2} into the original dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; d.update({'a': 2}); d?`, 
    o: ["{'a': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "update() overwrites existing keys.",
    de: `The update() method overwrites existing keys with new values from the argument dictionary. If d = {'a': 1} and then d.update({'a': 2}), the dictionary d becomes {'a': 2} because update() finds that the key 'a' already exists, and it overwrites the existing value (1) with the new value (2) from the argument dictionary. update() both adds new keys and updates existing keys.

update() - overwriting:
• d = {'a': 1}; d.update({'a': 2}); d = {'a': 2}
• update() overwrites existing keys
• Key 'a' exists, value updated: 1 → 2
• Modifies dictionary in place
• Dictionary changed: {'a': 1} → {'a': 2}

How it works:
• d = {'a': 1} creates dictionary
• d.update({'a': 2}) merges {'a': 2} into d
• Key 'a' already exists
• Overwrites existing value: 1 → 2
• Dictionary modified: {'a': 2}

Example:
d = {'a': 1}
d.update({'a': 2})    # None (returns None)
d                     # {'a': 2} (value updated)
d.update({'a': 10, 'b': 20}) # Updates 'a', adds 'b'
d                     # {'a': 10, 'b': 20}

Common uses:
• Updating values: dict.update({key: new_value})
• Merging with overwrite: items.update(updates)
• Dictionary updates
• Value overwriting

Example: If d = {'a': 1} and then d.update({'a': 2}), the dictionary d becomes {'a': 2} because update() overwrites the existing key 'a' with the new value 2 from the argument dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.popitem()?`, 
    o: ["('b', 2) or ('a', 1)", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "popitem() returns and removes arbitrary key-value pair (LIFO in 3.7+).",
    de: `The popitem() method removes and returns an arbitrary key-value pair from the dictionary as a tuple. {'a': 1, 'b': 2}.popitem() returns ('b', 2) or ('a', 1) because popitem() removes one pair and returns it as a (key, value) tuple. In Python 3.7+, dictionaries maintain insertion order, so popitem() removes and returns the last inserted pair (LIFO - Last In First Out). In earlier versions, popitem() removes an arbitrary pair.

popitem() method:
• {'a': 1, 'b': 2}.popitem() = ('b', 2) or ('a', 1) (returns tuple)
• popitem() removes and returns one pair
• Returns (key, value) tuple
• Modifies dictionary in place
• In Python 3.7+: removes last inserted pair (LIFO)

How it works:
• popitem() called on {'a': 1, 'b': 2}
• Removes one key-value pair
• Returns pair as tuple: (key, value)
• In Python 3.7+: removes last inserted ('b', 2)
• Dictionary modified: {'a': 1} or {'b': 2}

Example:
d = {'a': 1, 'b': 2}
d.popitem()           # ('b', 2) (returns last pair in 3.7+)
d                     # {'a': 1} (pair removed)
d.popitem()           # ('a', 1) (returns last pair)
d                     # {} (empty)

Common uses:
• Removing pairs: key, value = dict.popitem()
• Getting and removing: pair = items.popitem()
• Dictionary cleanup
• LIFO removal

Example: {'a': 1, 'b': 2}.popitem() returns ('b', 2) or ('a', 1) because popitem() removes one key-value pair from the dictionary and returns it as a (key, value) tuple. In Python 3.7+, it removes the last inserted pair (LIFO).
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1}.popitem()?`, 
    o: ["('a', 1)", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "popitem() on single-item dict returns that item.",
    de: `The popitem() method on a single-item dictionary returns that one key-value pair. {'a': 1}.popitem() returns ('a', 1) because popitem() removes the only key-value pair in the dictionary and returns it as a (key, value) tuple. After calling popitem(), the dictionary becomes empty {}. This is useful for removing the last remaining pair from a dictionary.

popitem() on single-item dict:
• {'a': 1}.popitem() = ('a', 1) (returns tuple)
• popitem() removes only pair
• Returns (key, value) tuple
• Modifies dictionary in place
• Dictionary changed: {'a': 1} → {}

How it works:
• popitem() called on {'a': 1}
• Removes the only key-value pair: 'a': 1
• Returns pair as tuple: ('a', 1)
• Dictionary becomes empty: {}
• Returns tuple: ('a', 1)

Example:
d = {'a': 1}
d.popitem()           # ('a', 1) (returns only pair)
d                     # {} (empty)
{'x': 10}.popitem()   # ('x', 10) (returns only pair)

Common uses:
• Removing last pair: key, value = dict.popitem()
• Getting and removing: pair = items.popitem()
• Single-item removal
• Dictionary emptying

Example: {'a': 1}.popitem() returns ('a', 1) because popitem() removes the only key-value pair in the dictionary and returns it as a (key, value) tuple, leaving the dictionary empty.
`
  }),
  (_i: number) => ({ 
    q: `What is {}.popitem()?`, 
    o: ["KeyError", "None", "()", "Error"], 
    c: 0, 
    e: "popitem() on empty dict raises KeyError.",
    de: `Calling popitem() on an empty dictionary raises a KeyError because there are no key-value pairs to remove. If you try to pop from an empty dictionary like {}.popitem(), Python raises a KeyError with a message indicating that you're trying to pop from an empty dictionary. This is similar to pop() on an empty list - there's nothing to remove, so an error is raised.

popitem() on empty dict:
• {}.popitem() raises KeyError
• Empty dictionary has no pairs to remove
• KeyError indicates invalid operation
• Must check if dict is not empty before popping
• Error message: "popitem(): dictionary is empty"

How it works:
• popitem() called on empty dictionary {}
• Searches for key-value pair to remove
• Finds no pairs (dictionary is empty)
• Raises KeyError
• No pair to return

Example:
{}.popitem()          # KeyError: popitem(): dictionary is empty
d = {}
d.popitem()           # KeyError: popitem(): dictionary is empty
if d:                 # Check first
    d.popitem()       # Safe to pop

Common uses:
• Error handling: try/except for KeyError
• Checking first: if dict: dict.popitem()
• Validating dict not empty
• Safe popping with validation

Example: Calling popitem() on an empty dictionary raises a KeyError because there are no key-value pairs to remove from the dictionary, and Python raises this error to indicate that the operation cannot be performed on an empty dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.clear()?`, 
    o: ["None", "{}", "{'a': 1, 'b': 2}", "Error"], 
    c: 0, 
    e: "clear() removes all items, returns None.",
    de: `The clear() method removes all key-value pairs from a dictionary and returns None. {'a': 1, 'b': 2}.clear() returns None because clear() modifies the dictionary in place, removing all pairs and leaving an empty dictionary. After calling clear(), the dictionary {'a': 1, 'b': 2} becomes {} - all pairs are removed, but the dictionary object itself still exists. This is different from reassigning to an empty dictionary - clear() modifies the existing object.

clear() method:
• {'a': 1, 'b': 2}.clear() = None (returns None)
• clear() removes all key-value pairs
• Modifies dictionary in place
• Returns None (doesn't return new dict)
• Dictionary changed: {'a': 1, 'b': 2} → {}

How it works:
• clear() called on {'a': 1, 'b': 2}
• Removes all key-value pairs
• Dictionary becomes empty: {}
• Original dictionary object still exists
• Returns None (no return value)

Example:
d = {'a': 1, 'b': 2}
d.clear()            # None (returns None)
d                    # {} (dictionary is now empty)
{'a': 1, 'b': 2}.clear() # None (returns None)

Common uses:
• Clearing dictionary: dict.clear()
• Removing all items: items.clear()
• Resetting dictionary
• In-place modification

Example: {'a': 1, 'b': 2}.clear() returns None because clear() removes all key-value pairs from the dictionary (changing {'a': 1, 'b': 2} to {}), and the method itself returns None rather than returning the empty dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; d.clear(); d?`, 
    o: ["{}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "clear() empties the dictionary.",
    de: `The clear() method empties a dictionary by removing all key-value pairs. If d = {'a': 1} and then d.clear(), the dictionary d becomes {} because clear() removes all pairs from the dictionary. The dictionary object itself still exists, but it contains no pairs. This is different from reassigning d = {} - clear() modifies the existing object, while reassignment creates a new object (which matters if other variables reference the same dictionary).

clear() empties dictionary:
• d = {'a': 1}; d.clear(); d = {}
• clear() removes all pairs
• Dictionary becomes empty
• Original object still exists
• All pairs removed

How it works:
• d = {'a': 1} creates dictionary
• d.clear() removes all pairs
• Dictionary becomes empty: {}
• Original dictionary object unchanged (just emptied)
• Returns None (no return value)

Example:
d = {'a': 1}
d.clear()            # None (returns None)
d                    # {} (empty)
a = {'x': 1, 'y': 2}
b = a                # b references same dict as a
a.clear()            # Clears both a and b
b                    # {} (also empty, same object)

Common uses:
• Clearing dictionary: dict.clear()
• Removing all items: items.clear()
• Resetting dictionary
• In-place emptying

Example: If d = {'a': 1} and then d.clear(), the dictionary d becomes {} because clear() removes all key-value pairs from the dictionary, leaving it empty.
`
  }),
  
  // 41-50: Dictionary Copying and Merging
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.copy()?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "None", "Error"], 
    c: 0, 
    e: "copy() creates shallow copy.",
    de: `The copy() method creates a shallow copy of a dictionary and returns it. {'a': 1, 'b': 2}.copy() returns {'a': 1, 'b': 2} because copy() creates a new dictionary object with the same key-value pairs. A shallow copy means the outer dictionary is copied, but if the dictionary contains nested objects (like lists or other dictionaries), those nested objects are not copied - they are shared between the original and the copy. For flat dictionaries (no nesting), shallow copy creates a completely independent dictionary.

copy() method:
• {'a': 1, 'b': 2}.copy() = {'a': 1, 'b': 2} (new dict)
• copy() creates shallow copy
• Creates new dictionary object
• Key-value pairs are copied (not shared)
• Returns new dictionary

How it works:
• copy() called on {'a': 1, 'b': 2}
• Creates new dictionary object
• Copies key-value pairs to new dictionary: {'a': 1, 'b': 2}
• New dictionary is independent of original
• Returns new dictionary: {'a': 1, 'b': 2}

Example:
a = {'a': 1, 'b': 2}
b = a.copy()         # {'a': 1, 'b': 2} (new dict)
b['c'] = 3           # b = {'a': 1, 'b': 2, 'c': 3}
a                    # {'a': 1, 'b': 2} (unchanged)

Common uses:
• Creating copies: new_dict = dict.copy()
• Independent dictionaries: copy = items.copy()
• Shallow copying
• Copy creation

Example: {'a': 1, 'b': 2}.copy() returns {'a': 1, 'b': 2} because copy() creates a new dictionary object with the same key-value pairs, resulting in a shallow copy of the original dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is dict({'a': 1, 'b': 2})?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "None", "Error"], 
    c: 0, 
    e: "dict() constructor creates shallow copy.",
    de: `The dict() constructor creates a shallow copy when called with a dictionary as an argument. dict({'a': 1, 'b': 2}) returns {'a': 1, 'b': 2} because dict() takes the dictionary {'a': 1, 'b': 2} and creates a new dictionary object with the same key-value pairs. This is essentially the same as using copy() - it creates a shallow copy where the outer dictionary is new, but nested objects (if any) are shared. For flat dictionaries, this creates a completely independent dictionary.

dict() constructor:
• dict({'a': 1, 'b': 2}) = {'a': 1, 'b': 2} (new dict)
• dict() creates shallow copy
• Creates new dictionary object
• Key-value pairs are copied (not shared)
• Returns new dictionary

How it works:
• dict() called with {'a': 1, 'b': 2}
• Creates new dictionary object
• Copies key-value pairs to new dictionary: {'a': 1, 'b': 2}
• New dictionary is independent of original
• Returns new dictionary: {'a': 1, 'b': 2}

Example:
a = {'a': 1, 'b': 2}
b = dict(a)          # {'a': 1, 'b': 2} (new dict)
b['c'] = 3           # b = {'a': 1, 'b': 2, 'c': 3}
a                    # {'a': 1, 'b': 2} (unchanged)

Common uses:
• Creating copies: new_dict = dict(old_dict)
• Shallow copying: copy = dict(original)
• Dictionary construction
• Copy creation

Example: dict({'a': 1, 'b': 2}) returns {'a': 1, 'b': 2} because dict() creates a new dictionary object with the same key-value pairs, resulting in a shallow copy of the original dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is {**{'a': 1}, **{'b': 2}}?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "** unpacks dictionaries, merges them.",
    de: `The ** operator unpacks dictionaries and merges them into a new dictionary. {**{'a': 1}, **{'b': 2}} returns {'a': 1, 'b': 2} because ** unpacks each dictionary, spreading its key-value pairs into the new dictionary literal. The first **{'a': 1} unpacks to 'a': 1, and the second **{'b': 2} unpacks to 'b': 2, resulting in {'a': 1, 'b': 2}. This is a concise way to merge dictionaries in Python 3.5+.

** unpacking for merging:
• {**{'a': 1}, **{'b': 2}} = {'a': 1, 'b': 2}
• ** unpacks dictionary key-value pairs
• First dict unpacks: 'a': 1
• Second dict unpacks: 'b': 2
• Merges into new dictionary: {'a': 1, 'b': 2}

How it works:
• {**{'a': 1}, **{'b': 2}} creates new dictionary
• **{'a': 1} unpacks to 'a': 1
• **{'b': 2} unpacks to 'b': 2
• Combines pairs: {'a': 1, 'b': 2}
• Returns new merged dictionary

Example:
{**{'a': 1}, **{'b': 2}}        # {'a': 1, 'b': 2}
{**{'x': 10}, **{'y': 20}}      # {'x': 10, 'y': 20}
{**{'a': 1}, **{'b': 2}, **{'c': 3}} # {'a': 1, 'b': 2, 'c': 3}

Common uses:
• Merging dictionaries: merged = {**dict1, **dict2}
• Combining dicts: combined = {**a, **b, **c}
• Dictionary merging
• Unpacking dictionaries

Example: {**{'a': 1}, **{'b': 2}} returns {'a': 1, 'b': 2} because ** unpacks each dictionary, spreading their key-value pairs into a new dictionary literal, effectively merging them.
`
  }),
  (_i: number) => ({ 
    q: `What is {**{'a': 1}, **{'a': 2}}?`, 
    o: ["{'a': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "Later dict overwrites earlier keys when unpacking.",
    de: `When unpacking dictionaries with overlapping keys, later dictionaries overwrite earlier ones. {**{'a': 1}, **{'a': 2}} returns {'a': 2} because the first **{'a': 1} sets 'a': 1, but then the second **{'a': 2} overwrites it with 'a': 2. The order matters - dictionaries unpacked later take precedence over dictionaries unpacked earlier when there are key conflicts. This is useful for merging dictionaries where you want later values to override earlier ones.

** unpacking with conflicts:
• {**{'a': 1}, **{'a': 2}} = {'a': 2}
• First dict unpacks: 'a': 1
• Second dict unpacks: 'a': 2
• Later dict overwrites earlier: 'a': 2 wins
• Result: {'a': 2}

How it works:
• {**{'a': 1}, **{'a': 2}} creates new dictionary
• **{'a': 1} unpacks to 'a': 1
• **{'a': 2} unpacks to 'a': 2
• Second overwrites first: 'a': 2
• Returns: {'a': 2}

Example:
{**{'a': 1}, **{'a': 2}}        # {'a': 2} (later wins)
{**{'x': 10}, **{'x': 20}}     # {'x': 20} (later wins)
{**{'a': 1, 'b': 2}, **{'a': 3}} # {'a': 3, 'b': 2} (later overwrites)

Common uses:
• Merging with overwrite: merged = {**base, **updates}
• Updating values: combined = {**old, **new}
• Dictionary updates
• Override behavior

Example: {**{'a': 1}, **{'a': 2}} returns {'a': 2} because when unpacking dictionaries with the same key, the later dictionary overwrites the earlier one, so 'a': 2 takes precedence over 'a': 1.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1} | {'b': 2}?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "| operator merges dictionaries (Python 3.9+).",
    de: `The | operator merges two dictionaries and returns a new dictionary (Python 3.9+). {'a': 1} | {'b': 2} returns {'a': 1, 'b': 2} because | combines the key-value pairs from both dictionaries into a new dictionary. The | operator creates a new dictionary object - it doesn't modify the original dictionaries. This is a clean, readable way to merge dictionaries introduced in Python 3.9.

| operator for merging:
• {'a': 1} | {'b': 2} = {'a': 1, 'b': 2}
• | operator merges dictionaries
• Creates new dictionary object
• Combines key-value pairs from both
• Returns new merged dictionary

How it works:
• {'a': 1} | {'b': 2} merges two dictionaries
• Takes pairs from left: 'a': 1
• Takes pairs from right: 'b': 2
• Combines into new dict: {'a': 1, 'b': 2}
• Returns new dictionary (originals unchanged)

Example:
{'a': 1} | {'b': 2}           # {'a': 1, 'b': 2}
{'x': 10} | {'y': 20}         # {'x': 10, 'y': 20}
{'a': 1, 'b': 2} | {'c': 3}   # {'a': 1, 'b': 2, 'c': 3}

Common uses:
• Merging dictionaries: merged = dict1 | dict2
• Combining dicts: combined = a | b | c
• Dictionary merging
• Clean merge syntax

Example: {'a': 1} | {'b': 2} returns {'a': 1, 'b': 2} because the | operator merges the key-value pairs from both dictionaries into a new dictionary (Python 3.9+).
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1} | {'a': 2}?`, 
    o: ["{'a': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "| operator overwrites with right dict values.",
    de: `When using the | operator with overlapping keys, the right dictionary's values overwrite the left dictionary's values. {'a': 1} | {'a': 2} returns {'a': 2} because the | operator takes the key 'a' from the right dictionary (value 2) and overwrites the value from the left dictionary (value 1). The right dictionary takes precedence when there are key conflicts. This is useful for updating dictionaries where you want the right-hand values to override the left-hand values.

| operator with conflicts:
• {'a': 1} | {'a': 2} = {'a': 2}
• | operator merges dictionaries
• Key 'a' exists in both
• Right dict overwrites left: 'a': 2 wins
• Result: {'a': 2}

How it works:
• {'a': 1} | {'a': 2} merges two dictionaries
• Left dict has: 'a': 1
• Right dict has: 'a': 2
• Right overwrites left: 'a': 2
• Returns: {'a': 2}

Example:
{'a': 1} | {'a': 2}           # {'a': 2} (right wins)
{'x': 10} | {'x': 20}         # {'x': 20} (right wins)
{'a': 1, 'b': 2} | {'a': 3}   # {'a': 3, 'b': 2} (right overwrites)

Common uses:
• Merging with overwrite: merged = base | updates
• Updating values: combined = old | new
• Dictionary updates
• Override behavior

Example: {'a': 1} | {'a': 2} returns {'a': 2} because the | operator overwrites values from the left dictionary with values from the right dictionary when there are key conflicts, so 'a': 2 takes precedence.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; d |= {'b': 2}; d?`, 
    o: ["{'a': 1, 'b': 2}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "|= updates dict in place (Python 3.9+).",
    de: `The |= operator updates a dictionary in place by merging another dictionary into it (Python 3.9+). If d = {'a': 1} and then d |= {'b': 2}, the dictionary d becomes {'a': 1, 'b': 2} because |= merges the key-value pairs from {'b': 2} into the existing dictionary d. Unlike | which creates a new dictionary, |= modifies the existing dictionary in place. This is similar to update() but with a more concise syntax.

|= operator (in-place update):
• d = {'a': 1}; d |= {'b': 2}; d = {'a': 1, 'b': 2}
• |= updates dictionary in place
• Merges right dict into left dict
• Modifies existing dictionary
• Returns None (but modifies d)

How it works:
• d = {'a': 1} creates dictionary
• d |= {'b': 2} merges {'b': 2} into d
• Adds new key 'b' with value 2
• Modifies original dictionary: {'a': 1, 'b': 2}
• Returns None (but d is modified)

Example:
d = {'a': 1}
d |= {'b': 2}         # None (returns None)
d                     # {'a': 1, 'b': 2} (modified)
d |= {'c': 3}         # Adds 'c': 3
d                     # {'a': 1, 'b': 2, 'c': 3}

Common uses:
• In-place merging: dict1 |= dict2
• Updating dictionaries: items |= updates
• Dictionary modification
• Concise update syntax

Example: If d = {'a': 1} and then d |= {'b': 2}, the dictionary d becomes {'a': 1, 'b': 2} because |= merges the key-value pairs from {'b': 2} into the existing dictionary d, modifying it in place (Python 3.9+).
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between | and |= for dicts?`, 
    o: ["| creates new dict, |= modifies in place", "No difference", "|= is faster", "| is deprecated"], 
    c: 0, 
    e: "| creates new dict, |= modifies existing.",
    de: `The key difference between | and |= is whether they modify the existing dictionary or create a new one. | creates a new dictionary by merging two dictionaries, leaving the originals unchanged. |= modifies the left dictionary in place by merging the right dictionary into it. | is for creating new dictionaries, while |= is for updating existing dictionaries. Both merge dictionaries, but | is non-destructive (creates new) while |= is destructive (modifies existing).

| vs |=:
• | creates new dictionary (non-destructive)
• |= modifies existing dictionary (destructive)
• | returns new dict, originals unchanged
• |= returns None, modifies left dict
• Both merge dictionaries

How it works:
• d1 | d2: creates new dict, d1 and d2 unchanged
• d1 |= d2: modifies d1, merges d2 into d1
• | is for creating new merged dicts
• |= is for updating existing dicts
• Choose based on whether you want to modify original

Example:
a = {'a': 1}
b = {'b': 2}
c = a | b            # {'a': 1, 'b': 2} (new dict)
a                    # {'a': 1} (unchanged)
a |= b               # None (returns None)
a                    # {'a': 1, 'b': 2} (modified)

Common uses:
• |: creating new merged dicts: merged = dict1 | dict2
• |=: updating existing dicts: dict1 |= dict2
• Choose based on whether to modify original
• Important distinction for dictionary behavior

Example: The difference is | creates a new dictionary by merging two dictionaries (e.g., {'a': 1} | {'b': 2} returns {'a': 1, 'b': 2} without modifying originals), while |= modifies the left dictionary in place (e.g., d |= {'b': 2} modifies d to include {'b': 2}).
`
  }),
  (_i: number) => ({ 
    q: `What is a = {'a': [1]}; b = a.copy(); b['a'].append(2); a?`, 
    o: ["{'a': [1, 2]}", "{'a': [1]}", "Error", "None"], 
    c: 0, 
    e: "Shallow copy shares nested objects.",
    de: `A shallow copy shares nested objects between the original and the copy. If a = {'a': [1]} and b = a.copy(), then b['a'].append(2) causes a to become {'a': [1, 2]} because copy() creates a shallow copy - the outer dictionary is new, but the nested list [1] is shared between a and b. When you modify the nested list through b, you're modifying the same list object that a also references. This is why shallow copies can be problematic with nested mutable objects.

Shallow copy with nesting:
• a = {'a': [1]}; b = a.copy(); b['a'].append(2); a = {'a': [1, 2]}
• copy() creates shallow copy
• Outer dict is new, nested list is shared
• Modifying nested list affects both dicts
• Shallow copy shares nested objects

How it works:
• a = {'a': [1]} creates dict with nested list
• b = a.copy() creates new dict but shares list
• b['a'].append(2) modifies shared list
• Both a and b reference same list object
• a becomes {'a': [1, 2]} (list modified)

Example:
a = {'a': [1]}
b = a.copy()         # b = {'a': [1]} (new dict, shared list)
b['a'].append(2)     # Modifies shared list
a                    # {'a': [1, 2]} (list modified)
b                    # {'a': [1, 2]} (same list)

Common uses:
• Understanding shallow copy limitations
• When to use deep copy: import copy; b = copy.deepcopy(a)
• Nested object behavior
• Copy behavior awareness

Example: If a = {'a': [1]} and b = a.copy(), then b['a'].append(2) causes a to become {'a': [1, 2]} because copy() creates a shallow copy where the nested list [1] is shared between both dictionaries, so modifying it through one affects the other.
`
  }),
  (_i: number) => ({ 
    q: `What is import copy; copy.deepcopy({'a': [1]})?`, 
    o: ["{'a': [1]} (deep copy)", "{'a': [1]} (shallow copy)", "Error", "None"], 
    c: 0, 
    e: "deepcopy() creates independent nested objects.",
    de: `The deepcopy() function from the copy module creates a deep copy where nested objects are also copied, making them independent. copy.deepcopy({'a': [1]}) returns {'a': [1]} where the nested list [1] is a new, independent list object. Unlike shallow copy, deep copy recursively copies all nested objects, so modifications to nested objects in the copy don't affect the original. This is the solution to the shallow copy problem with nested mutable objects.

deepcopy() function:
• copy.deepcopy({'a': [1]}) = {'a': [1]} (deep copy)
• deepcopy() creates deep copy
• Recursively copies all nested objects
• Nested objects are independent
• No shared references

How it works:
• copy.deepcopy({'a': [1]}) creates deep copy
• Copies outer dictionary
• Recursively copies nested list [1]
• Creates new list object (not shared)
• Returns independent copy: {'a': [1]}

Example:
import copy
a = {'a': [1]}
b = copy.deepcopy(a) # b = {'a': [1]} (deep copy)
b['a'].append(2)     # Modifies b's list
a                    # {'a': [1]} (unchanged, independent)
b                    # {'a': [1, 2]} (modified)

Common uses:
• Creating independent copies: copy = copy.deepcopy(original)
• Avoiding shared references: deep = copy.deepcopy(nested)
• Deep copying
• Independent nested objects

Example: copy.deepcopy({'a': [1]}) returns {'a': [1]} where the nested list [1] is a new, independent list object because deepcopy() recursively copies all nested objects, making them completely independent of the original.
`
  }),
  
  // 51-60: Dictionary Comprehensions
  (_i: number) => ({ 
    q: `What is {x: x*2 for x in [1, 2, 3]}?`, 
    o: ["{1: 2, 2: 4, 3: 6}", "{1, 2, 3}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension creates dict from iterable.",
    de: `A dictionary comprehension creates a dictionary from an iterable using a concise syntax. {x: x*2 for x in [1, 2, 3]} returns {1: 2, 2: 4, 3: 6} because the comprehension iterates through [1, 2, 3], and for each element x, it creates a key-value pair where the key is x and the value is x*2. Dictionary comprehensions follow the pattern {key: value for item in iterable}, creating a new dictionary efficiently.

Dictionary comprehension:
• {x: x*2 for x in [1, 2, 3]} = {1: 2, 2: 4, 3: 6}
• Comprehension syntax: {key: value for item in iterable}
• Iterates through [1, 2, 3]
• For each x: creates pair x: x*2
• Returns new dictionary

How it works:
• Comprehension iterates: x = 1, 2, 3
• For x = 1: creates pair 1: 1*2 = 1: 2
• For x = 2: creates pair 2: 2*2 = 2: 4
• For x = 3: creates pair 3: 3*2 = 3: 6
• Returns: {1: 2, 2: 4, 3: 6}

Example:
{x: x*2 for x in [1, 2, 3]}        # {1: 2, 2: 4, 3: 6}
{x: x**2 for x in [1, 2, 3]}       # {1: 1, 2: 4, 3: 9}
{x: len(x) for x in ['a', 'ab', 'abc']} # {'a': 1, 'ab': 2, 'abc': 3}

Common uses:
• Creating dictionaries: dict = {k: v for k, v in pairs}
• Transforming data: mapping = {x: transform(x) for x in items}
• Dictionary creation
• Efficient dict construction

Example: {x: x*2 for x in [1, 2, 3]} returns {1: 2, 2: 4, 3: 6} because the dictionary comprehension iterates through [1, 2, 3] and creates key-value pairs where each key is x and each value is x*2.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: x**2 for x in range(3)}?`, 
    o: ["{0: 0, 1: 1, 2: 4}", "{0, 1, 2}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with range.",
    de: `Dictionary comprehensions work with any iterable, including range(). {x: x**2 for x in range(3)} returns {0: 0, 1: 1, 2: 4} because range(3) generates 0, 1, 2, and the comprehension creates key-value pairs where each key is x and each value is x**2 (x squared). range() is commonly used in comprehensions to generate sequences of numbers.

Dictionary comprehension with range:
• {x: x**2 for x in range(3)} = {0: 0, 1: 1, 2: 4}
• range(3) generates: 0, 1, 2
• For each x: creates pair x: x**2
• Returns new dictionary
• Works with any iterable

How it works:
• range(3) generates: 0, 1, 2
• For x = 0: creates pair 0: 0**2 = 0: 0
• For x = 1: creates pair 1: 1**2 = 1: 1
• For x = 2: creates pair 2: 2**2 = 2: 4
• Returns: {0: 0, 1: 1, 2: 4}

Example:
{x: x**2 for x in range(3)}        # {0: 0, 1: 1, 2: 4}
{x: x*10 for x in range(5)}        # {0: 0, 1: 10, 2: 20, 3: 30, 4: 40}
{x: chr(65+x) for x in range(3)}   # {0: 'A', 1: 'B', 2: 'C'}

Common uses:
• Number sequences: dict = {x: f(x) for x in range(n)}
• Generating mappings: mapping = {i: value for i in range(n)}
• Range-based dictionaries
• Sequential dict creation

Example: {x: x**2 for x in range(3)} returns {0: 0, 1: 1, 2: 4} because range(3) generates 0, 1, 2, and the comprehension creates key-value pairs where each key is x and each value is x**2.
`
  }),
  (_i: number) => ({ 
    q: `What is {k: v*2 for k, v in {'a': 1, 'b': 2}.items()}?`, 
    o: ["{'a': 2, 'b': 4}", "{'a': 1, 'b': 2}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension iterating over items.",
    de: `Dictionary comprehensions can iterate over existing dictionary items using .items(). {k: v*2 for k, v in {'a': 1, 'b': 2}.items()} returns {'a': 2, 'b': 4} because .items() yields (key, value) tuples, which are unpacked into k and v, and the comprehension creates new pairs where keys remain the same but values are doubled. This is useful for transforming dictionary values while keeping the same keys.

Dictionary comprehension with items():
• {k: v*2 for k, v in {'a': 1, 'b': 2}.items()} = {'a': 2, 'b': 4}
• .items() yields (key, value) tuples
• Unpacks into k, v
• Creates new pairs: k: v*2
• Returns transformed dictionary

How it works:
• {'a': 1, 'b': 2}.items() yields: ('a', 1), ('b', 2)
• Unpacks: k='a', v=1 and k='b', v=2
• For ('a', 1): creates pair 'a': 1*2 = 'a': 2
• For ('b', 2): creates pair 'b': 2*2 = 'b': 4
• Returns: {'a': 2, 'b': 4}

Example:
{k: v*2 for k, v in {'a': 1, 'b': 2}.items()}  # {'a': 2, 'b': 4}
{k: v**2 for k, v in {'x': 3, 'y': 4}.items()} # {'x': 9, 'y': 16}
{k: str(v) for k, v in {'a': 1, 'b': 2}.items()} # {'a': '1', 'b': '2'}

Common uses:
• Transforming values: new = {k: transform(v) for k, v in old.items()}
• Value operations: updated = {k: v*2 for k, v in data.items()}
• Dictionary transformation
• Value modification

Example: {k: v*2 for k, v in {'a': 1, 'b': 2}.items()} returns {'a': 2, 'b': 4} because the comprehension iterates over the items, unpacks each (key, value) tuple, and creates new pairs where values are doubled while keys remain the same.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: x for x in [1, 2, 3] if x > 1}?`, 
    o: ["{2: 2, 3: 3}", "{1: 1, 2: 2, 3: 3}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with condition.",
    de: `Dictionary comprehensions can include conditional filters using if. {x: x for x in [1, 2, 3] if x > 1} returns {2: 2, 3: 3} because the if x > 1 condition filters the elements, only including x values greater than 1. The comprehension iterates through [1, 2, 3], but only creates pairs for elements that satisfy the condition (x > 1), so 1 is excluded but 2 and 3 are included.

Dictionary comprehension with condition:
• {x: x for x in [1, 2, 3] if x > 1} = {2: 2, 3: 3}
• if condition filters elements
• Only includes x where x > 1
• Excludes 1, includes 2 and 3
• Returns filtered dictionary

How it works:
• Iterates through [1, 2, 3]
• For x = 1: if 1 > 1 is False, skip
• For x = 2: if 2 > 1 is True, creates pair 2: 2
• For x = 3: if 3 > 1 is True, creates pair 3: 3
• Returns: {2: 2, 3: 3}

Example:
{x: x for x in [1, 2, 3] if x > 1}        # {2: 2, 3: 3}
{x: x*2 for x in [1, 2, 3] if x % 2 == 0}  # {2: 4} (only even)
{x: x for x in range(5) if x % 2 == 1}     # {1: 1, 3: 3} (only odd)

Common uses:
• Filtering dictionaries: filtered = {k: v for k, v in items if condition}
• Conditional creation: dict = {x: f(x) for x in items if predicate(x)}
• Dictionary filtering
• Conditional dict creation

Example: {x: x for x in [1, 2, 3] if x > 1} returns {2: 2, 3: 3} because the if x > 1 condition filters the elements, only including values greater than 1, so 1 is excluded but 2 and 3 are included.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: 'even' if x%2==0 else 'odd' for x in [1, 2, 3]}?`, 
    o: ["{1: 'odd', 2: 'even', 3: 'odd'}", "{1: 1, 2: 2, 3: 3}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with ternary in value.",
    de: `Dictionary comprehensions can use ternary expressions (conditional expressions) in the value part. {x: 'even' if x%2==0 else 'odd' for x in [1, 2, 3]} returns {1: 'odd', 2: 'even', 3: 'odd'} because the ternary expression 'even' if x%2==0 else 'odd' evaluates to 'even' when x is even (x%2==0) and 'odd' when x is odd. This allows creating different values based on conditions within the comprehension.

Dictionary comprehension with ternary:
• {x: 'even' if x%2==0 else 'odd' for x in [1, 2, 3]} = {1: 'odd', 2: 'even', 3: 'odd'}
• Ternary: 'even' if x%2==0 else 'odd'
• Evaluates condition for each x
• Returns 'even' if even, 'odd' if odd
• Creates conditional values

How it works:
• Iterates through [1, 2, 3]
• For x = 1: 1%2==0 is False, value = 'odd', creates 1: 'odd'
• For x = 2: 2%2==0 is True, value = 'even', creates 2: 'even'
• For x = 3: 3%2==0 is False, value = 'odd', creates 3: 'odd'
• Returns: {1: 'odd', 2: 'even', 3: 'odd'}

Example:
{x: 'even' if x%2==0 else 'odd' for x in [1, 2, 3]}  # {1: 'odd', 2: 'even', 3: 'odd'}
{x: 'big' if x > 5 else 'small' for x in [3, 7, 2]}  # {3: 'small', 7: 'big', 2: 'small'}
{x: 'pos' if x > 0 else 'neg' for x in [-1, 1, 0]}   # {-1: 'neg', 1: 'pos', 0: 'neg'}

Common uses:
• Conditional values: dict = {k: 'A' if condition else 'B' for k in items}
• Value mapping: mapping = {x: 'type1' if pred(x) else 'type2' for x in items}
• Conditional dict creation
• Ternary expressions in comprehensions

Example: {x: 'even' if x%2==0 else 'odd' for x in [1, 2, 3]} returns {1: 'odd', 2: 'even', 3: 'odd'} because the ternary expression evaluates to 'even' when x is even and 'odd' when x is odd, creating conditional values in the dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is {str(x): x for x in [1, 2, 3]}?`, 
    o: ["{'1': 1, '2': 2, '3': 3}", "{1: 1, 2: 2, 3: 3}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with key transformation.",
    de: `Dictionary comprehensions can transform keys using expressions. {str(x): x for x in [1, 2, 3]} returns {'1': 1, '2': 2, '3': 3} because str(x) converts each integer x to its string representation, which becomes the key, while x remains the value. This allows creating dictionaries with transformed keys (or values) from the original data. Key transformations are common when you need different key types or formats.

Dictionary comprehension with key transformation:
• {str(x): x for x in [1, 2, 3]} = {'1': 1, '2': 2, '3': 3}
• str(x) transforms key to string
• Value remains x (integer)
• Creates string keys from integer values
• Returns transformed dictionary

How it works:
• Iterates through [1, 2, 3]
• For x = 1: str(1) = '1', creates pair '1': 1
• For x = 2: str(2) = '2', creates pair '2': 2
• For x = 3: str(3) = '3', creates pair '3': 3
• Returns: {'1': 1, '2': 2, '3': 3}

Example:
{str(x): x for x in [1, 2, 3]}        # {'1': 1, '2': 2, '3': 3}
{x: str(x) for x in [1, 2, 3]}         # {1: '1', 2: '2', 3: '3'} (value transform)
{chr(65+x): x for x in range(3)}       # {'A': 0, 'B': 1, 'C': 2}

Common uses:
• Key transformation: dict = {transform(k): v for k, v in items}
• Type conversion: mapping = {str(k): k for k in numbers}
• Key formatting
• Dictionary key transformation

Example: {str(x): x for x in [1, 2, 3]} returns {'1': 1, '2': 2, '3': 3} because str(x) converts each integer x to its string representation for the key, while keeping the integer as the value.
`
  }),
  (_i: number) => ({ 
    q: `What is {(x, y): x+y for x in [1, 2] for y in [3, 4]}?`, 
    o: ["{(1, 3): 4, (1, 4): 5, (2, 3): 5, (2, 4): 6}", "Error", "None", "{1: 1, 2: 2}"], 
    c: 0, 
    e: "Dictionary comprehension with nested loops, tuple keys.",
    de: `Dictionary comprehensions can have nested loops and use tuples as keys. {(x, y): x+y for x in [1, 2] for y in [3, 4]} returns {(1, 3): 4, (1, 4): 5, (2, 3): 5, (2, 4): 6} because the nested loops iterate through all combinations: for each x in [1, 2] and each y in [3, 4], it creates a key-value pair where the key is the tuple (x, y) and the value is x+y. This creates a Cartesian product of the two lists as keys.

Dictionary comprehension with nested loops:
• {(x, y): x+y for x in [1, 2] for y in [3, 4]} = {(1, 3): 4, (1, 4): 5, (2, 3): 5, (2, 4): 6}
• Nested loops: for x in [1, 2] for y in [3, 4]
• Creates all combinations
• Key is tuple (x, y)
• Value is x+y

How it works:
• Outer loop: x = 1, 2
• Inner loop: y = 3, 4
• Combinations: (1,3), (1,4), (2,3), (2,4)
• For (1, 3): creates pair (1, 3): 1+3 = (1, 3): 4
• For (1, 4): creates pair (1, 4): 1+4 = (1, 4): 5
• For (2, 3): creates pair (2, 3): 2+3 = (2, 3): 5
• For (2, 4): creates pair (2, 4): 2+4 = (2, 4): 6
• Returns: {(1, 3): 4, (1, 4): 5, (2, 3): 5, (2, 4): 6}

Example:
{(x, y): x+y for x in [1, 2] for y in [3, 4]}  # {(1, 3): 4, (1, 4): 5, (2, 3): 5, (2, 4): 6}
{(i, j): i*j for i in [1, 2] for j in [2, 3]}  # {(1, 2): 2, (1, 3): 3, (2, 2): 4, (2, 3): 6}

Common uses:
• Cartesian products: dict = {(x, y): f(x, y) for x in xs for y in ys}
• Coordinate mappings: mapping = {(i, j): value for i in range(n) for j in range(m)}
• Nested iteration
• Tuple keys

Example: {(x, y): x+y for x in [1, 2] for y in [3, 4]} returns {(1, 3): 4, (1, 4): 5, (2, 3): 5, (2, 4): 6} because the nested loops create all combinations of x and y, using tuples (x, y) as keys and x+y as values.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: y for x, y in zip([1, 2], [3, 4])}?`, 
    o: ["{1: 3, 2: 4}", "{1: 1, 2: 2}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with zip.",
    de: `Dictionary comprehensions can iterate over zipped iterables to create key-value pairs. {x: y for x, y in zip([1, 2], [3, 4])} returns {1: 3, 2: 4} because zip([1, 2], [3, 4]) pairs elements from both lists: (1, 3) and (2, 4), which are unpacked into x and y, creating dictionary pairs where x is the key and y is the value. This is a common pattern for creating dictionaries from two parallel lists.

Dictionary comprehension with zip:
• {x: y for x, y in zip([1, 2], [3, 4])} = {1: 3, 2: 4}
• zip([1, 2], [3, 4]) pairs: (1, 3), (2, 4)
• Unpacks into x, y
• Creates pairs: x: y
• Returns dictionary

How it works:
• zip([1, 2], [3, 4]) yields: (1, 3), (2, 4)
• Unpacks: x=1, y=3 and x=2, y=4
• For (1, 3): creates pair 1: 3
• For (2, 4): creates pair 2: 4
• Returns: {1: 3, 2: 4}

Example:
{x: y for x, y in zip([1, 2], [3, 4])}        # {1: 3, 2: 4}
{k: v for k, v in zip(['a', 'b'], [1, 2])}    # {'a': 1, 'b': 2}
{str(i): i*2 for i, j in zip([1, 2], [3, 4])} # {'1': 2, '2': 4} (using i)

Common uses:
• Creating from lists: dict = {k: v for k, v in zip(keys, values)}
• Pairing data: mapping = {x: y for x, y in zip(list1, list2)}
• Dictionary from parallel lists
• Zip-based creation

Example: {x: y for x, y in zip([1, 2], [3, 4])} returns {1: 3, 2: 4} because zip() pairs elements from both lists, and the comprehension creates dictionary pairs where the first element is the key and the second element is the value.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: x for x in []}?`, 
    o: ["{}", "[]", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with empty iterable.",
    de: `Dictionary comprehensions with empty iterables create empty dictionaries. {x: x for x in []} returns {} because when the iterable is empty, there are no elements to iterate over, so no key-value pairs are created, resulting in an empty dictionary. This is consistent with how comprehensions work - if there's nothing to iterate over, the result is an empty collection of that type.

Dictionary comprehension with empty iterable:
• {x: x for x in []} = {} (empty dictionary)
• Empty iterable [] has no elements
• No iterations occur
• No pairs created
• Returns empty dictionary

How it works:
• Comprehension iterates over []
• Finds no elements
• No iterations occur
• No key-value pairs created
• Returns: {}

Example:
{x: x for x in []}              # {} (empty)
{x: x*2 for x in []}            # {} (empty)
{x: x for x in range(0)}        # {} (empty range)
{k: v for k, v in [].items()}   # {} (empty, if [] had items())

Common uses:
• Empty results: dict = {k: v for k, v in items if condition} (might be empty)
• Conditional creation: result = {x: f(x) for x in items if pred(x)}
• Empty dict creation
• Comprehension edge cases

Example: {x: x for x in []} returns {} because when the iterable is empty, there are no elements to iterate over, so no key-value pairs are created, resulting in an empty dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is {x: x*2 for x in [1, 2] if x > 0}?`, 
    o: ["{1: 2, 2: 4}", "{1: 1, 2: 2}", "Error", "None"], 
    c: 0, 
    e: "Dictionary comprehension with condition (all pass).",
    de: `Dictionary comprehensions with conditions filter elements before creating pairs. {x: x*2 for x in [1, 2] if x > 0} returns {1: 2, 2: 4} because the if x > 0 condition checks each element, and since both 1 and 2 are greater than 0, both pass the filter and pairs are created. The condition is evaluated before creating the pair, so only elements that satisfy the condition are included in the result.

Dictionary comprehension with condition:
• {x: x*2 for x in [1, 2] if x > 0} = {1: 2, 2: 4}
• if x > 0 filters elements
• Both 1 and 2 pass condition (both > 0)
• Creates pairs for both: 1: 2, 2: 4
• Returns filtered dictionary

How it works:
• Iterates through [1, 2]
• For x = 1: if 1 > 0 is True, creates pair 1: 1*2 = 1: 2
• For x = 2: if 2 > 0 is True, creates pair 2: 2*2 = 2: 4
• Both pass condition
• Returns: {1: 2, 2: 4}

Example:
{x: x*2 for x in [1, 2] if x > 0}        # {1: 2, 2: 4} (all pass)
{x: x*2 for x in [-1, 1, 2] if x > 0}   # {1: 2, 2: 4} (-1 filtered out)
{x: x**2 for x in [1, 2, 3] if x % 2 == 0} # {2: 4} (only even)

Common uses:
• Filtering and transforming: dict = {k: transform(v) for k, v in items if condition}
• Conditional creation: result = {x: f(x) for x in items if predicate(x)}
• Dictionary filtering
• Conditional dict creation

Example: {x: x*2 for x in [1, 2] if x > 0} returns {1: 2, 2: 4} because the if x > 0 condition filters elements, and since both 1 and 2 are greater than 0, both pass the filter and pairs are created with doubled values.
`
  }),
  
  // 61-70: Dictionary Operations and Comparisons
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2} == {'b': 2, 'a': 1}?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Dictionaries compare by content, order doesn't matter (Python 3.7+).",
    de: `Dictionaries are compared by content, not by insertion order. {'a': 1, 'b': 2} == {'b': 2, 'a': 1} returns True because both dictionaries contain the same key-value pairs: 'a': 1 and 'b': 2. The == operator checks if the dictionaries have the same keys and the same values for each key, regardless of the order in which the pairs were inserted (in Python 3.7+, dictionaries maintain insertion order, but equality comparison ignores order).

Dictionary equality:
• {'a': 1, 'b': 2} == {'b': 2, 'a': 1} = True
• == compares content (keys and values)
• Order doesn't matter for equality
• Same keys and same values = equal
• Returns True (equal)

How it works:
• {'a': 1, 'b': 2} has keys: 'a', 'b' with values: 1, 2
• {'b': 2, 'a': 1} has keys: 'a', 'b' with values: 1, 2
• Same keys: 'a', 'b' (order ignored)
• Same values: 1, 2 (matching keys)
• Returns: True (equal)

Example:
{'a': 1, 'b': 2} == {'b': 2, 'a': 1}  # True (same content)
{'a': 1} == {'b': 1}                  # False (different keys)
{'a': 1} == {'a': 2}                  # False (different values)

Common uses:
• Comparing dictionaries: if dict1 == dict2:
• Content equality: equal = (items1 == items2)
• Dictionary comparison
• Equality checking

Example: {'a': 1, 'b': 2} == {'b': 2, 'a': 1} returns True because both dictionaries contain the same key-value pairs, and equality comparison checks content regardless of order.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1} == {'a': 2}?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Dictionaries with different values are not equal.",
    de: `Dictionaries with different values for the same keys are not equal. {'a': 1} == {'a': 2} returns False because both dictionaries have the same key 'a', but they have different values: 1 vs 2. The == operator checks if all keys match and if all corresponding values are equal - if any value differs, the dictionaries are not equal.

Dictionary equality with different values:
• {'a': 1} == {'a': 2} = False
• Both have key 'a'
• Values differ: 1 vs 2
• Different values = not equal
• Returns False (not equal)

How it works:
• {'a': 1} has key 'a' with value 1
• {'a': 2} has key 'a' with value 2
• Same keys: 'a' (matches)
• Different values: 1 vs 2 (mismatch)
• Returns: False (not equal)

Example:
{'a': 1} == {'a': 2}                  # False (different values)
{'a': 1, 'b': 2} == {'a': 1, 'b': 3} # False (different values)
{'a': 1} == {'a': 1}                  # True (same values)

Common uses:
• Comparing dictionaries: if dict1 == dict2:
• Value checking: equal = (items1 == items2)
• Dictionary comparison
• Equality validation

Example: {'a': 1} == {'a': 2} returns False because both dictionaries have the same key 'a' but different values (1 vs 2), so they are not equal.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1} == {'a': 1, 'b': 2}?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Dictionaries with different keys are not equal.",
    de: `Dictionaries with different sets of keys are not equal. {'a': 1} == {'a': 1, 'b': 2} returns False because the first dictionary has only key 'a', while the second dictionary has keys 'a' and 'b'. The == operator checks if both dictionaries have exactly the same keys - if one dictionary has keys that the other doesn't have, they are not equal, even if the common keys have the same values.

Dictionary equality with different keys:
• {'a': 1} == {'a': 1, 'b': 2} = False
• First dict has keys: 'a'
• Second dict has keys: 'a', 'b'
• Different key sets = not equal
• Returns False (not equal)

How it works:
• {'a': 1} has keys: 'a' (one key)
• {'a': 1, 'b': 2} has keys: 'a', 'b' (two keys)
• Key sets differ: {'a'} vs {'a', 'b'}
• Different key sets (even if common keys match)
• Returns: False (not equal)

Example:
{'a': 1} == {'a': 1, 'b': 2}         # False (different keys)
{'a': 1, 'b': 2} == {'a': 1}         # False (different keys)
{'a': 1} == {'a': 1}                 # True (same keys and values)

Common uses:
• Comparing dictionaries: if dict1 == dict2:
• Key checking: equal = (items1 == items2)
• Dictionary comparison
• Equality validation

Example: {'a': 1} == {'a': 1, 'b': 2} returns False because the dictionaries have different sets of keys (one has only 'a', the other has 'a' and 'b'), so they are not equal.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1} != {'a': 2}?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "!= checks if dictionaries are different.",
    de: `The != operator checks if two dictionaries are different. {'a': 1} != {'a': 2} returns True because != is the negation of == - it returns True when the dictionaries are not equal. Since {'a': 1} and {'a': 2} have the same key 'a' but different values (1 vs 2), they are not equal, so != returns True. This is useful for checking if dictionaries differ.

!= operator with dictionaries:
• {'a': 1} != {'a': 2} = True
• != checks if dictionaries differ
• Same key 'a', different values: 1 vs 2
• Different values = not equal
• Returns True (not equal)

How it works:
• {'a': 1} has key 'a' with value 1
• {'a': 2} has key 'a' with value 2
• Same keys: 'a' (matches)
• Different values: 1 vs 2 (mismatch)
• Not equal, so != returns: True

Example:
{'a': 1} != {'a': 2}                 # True (different values)
{'a': 1} != {'a': 1}                 # False (same values)
{'a': 1} != {'b': 1}                 # True (different keys)

Common uses:
• Checking differences: if dict1 != dict2:
• Difference detection: different = (items1 != items2)
• Dictionary comparison
• Inequality checking

Example: {'a': 1} != {'a': 2} returns True because != checks if dictionaries are different, and since {'a': 1} and {'a': 2} have the same key but different values, they are not equal, so != returns True.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1} is {'a': 1}?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Different dict objects, even with same content.",
    de: `The is operator checks if two variables reference the same object, not if they have the same content. {'a': 1} is {'a': 1} returns False because each dictionary literal creates a new dictionary object, so even though both dictionaries have the same content, they are different objects in memory. The is operator checks object identity (same memory address), while == checks value equality (same content).

is operator with dictionaries:
• {'a': 1} is {'a': 1} = False
• is checks object identity (same object)
• Each dict literal creates new object
• Different objects (even if same content)
• Returns False (different objects)

How it works:
• {'a': 1} creates new dictionary object A
• {'a': 1} creates new dictionary object B
• Objects A and B are different (different memory addresses)
• is checks if same object (same memory address)
• Different objects, so is returns: False

Example:
{'a': 1} is {'a': 1}                 # False (different objects)
{'a': 1} == {'a': 1}                 # True (same content)
a = {'a': 1}
b = a
a is b                                # True (same object)

Common uses:
• Checking object identity: if dict1 is dict2:
• Reference checking: same = (items1 is items2)
• Object identity
• Reference equality

Example: {'a': 1} is {'a': 1} returns False because each dictionary literal creates a new object, so even though both dictionaries have the same content, they are different objects, and is checks object identity, not content equality.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; d is d?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Same object is identical to itself.",
    de: `An object is always identical to itself. If d = {'a': 1} and then d is d, it returns True because d is d means "is d the same object as d", which is always true. The is operator checks if two variables reference the same object, and a variable always references itself, so d is d is always True for any object.

is operator with same variable:
• d = {'a': 1}; d is d = True
• is checks object identity (same object)
• d is d means "is d the same as d"
• Always True (object is identical to itself)
• Returns True (same object)

How it works:
• d = {'a': 1} assigns dictionary object to d
• d is d checks if d is the same object as d
• Same variable (same reference)
• Same object (same memory address)
• Returns: True (always true)

Example:
d = {'a': 1}
d is d                                # True (always true)
a = {'a': 1}
b = {'a': 1}
a is b                                # False (different objects)
a is a                                # True (always true)

Common uses:
• Checking self-identity: if obj is obj:
• Reference validation: same = (items is items)
• Self-identity check
• Always true for same variable

Example: If d = {'a': 1} and then d is d, it returns True because d is always the same object as d - an object is always identical to itself.
`
  }),
  (_i: number) => ({ 
    q: `What is bool({})?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Empty dictionary is falsy.",
    de: `Empty dictionaries are falsy in boolean contexts. bool({}) returns False because an empty dictionary has no key-value pairs, so it evaluates to False when used in a boolean context. This is consistent with Python's truthiness rules - empty collections (empty list, empty tuple, empty set, empty dict) are falsy, while non-empty collections are truthy. This is useful for checking if a dictionary has any content.

bool() on empty dictionary:
• bool({}) = False (falsy)
• Empty dictionary has no pairs
• No content = falsy
• Returns False in boolean context
• Useful for checking if dict has content

How it works:
• bool() called with empty dictionary {}
• Checks if dictionary has content
• Finds no key-value pairs
• No content = falsy
• Returns: False

Example:
bool({})                              # False (falsy)
bool({'a': 1})                        # True (truthy)
if {}:                                # False (condition is False)
    print("not empty")

Common uses:
• Checking if empty: if dict: ... (falsy if empty)
• Validation: if not dict: return {}
• Empty check
• Truthiness check

Example: bool({}) returns False because empty dictionaries are falsy in boolean contexts - they have no content, so they evaluate to False.
`
  }),
  (_i: number) => ({ 
    q: `What is bool({'a': 1})?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Non-empty dictionary is truthy.",
    de: `Non-empty dictionaries are truthy in boolean contexts. bool({'a': 1}) returns True because a non-empty dictionary has at least one key-value pair, so it evaluates to True when used in a boolean context. This is consistent with Python's truthiness rules - non-empty collections (non-empty list, non-empty tuple, non-empty set, non-empty dict) are truthy, while empty collections are falsy. This is useful for checking if a dictionary has any content.

bool() on non-empty dictionary:
• bool({'a': 1}) = True (truthy)
• Non-empty dictionary has pairs
• Has content = truthy
• Returns True in boolean context
• Useful for checking if dict has content

How it works:
• bool() called with non-empty dictionary {'a': 1}
• Checks if dictionary has content
• Finds at least one key-value pair: 'a': 1
• Has content = truthy
• Returns: True

Example:
bool({'a': 1})                        # True (truthy)
bool({})                              # False (falsy)
if {'a': 1}:                          # True (condition is True)
    print("not empty")

Common uses:
• Checking if not empty: if dict: ... (truthy if not empty)
• Validation: if dict: process(dict)
• Content check
• Truthiness check

Example: bool({'a': 1}) returns True because non-empty dictionaries are truthy in boolean contexts - they have content, so they evaluate to True.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2} + {'c': 3}?`, 
    o: ["TypeError", "{'a': 1, 'b': 2, 'c': 3}", "Error", "None"], 
    c: 0, 
    e: "Dictionaries don't support + operator (use | or update).",
    de: `Dictionaries don't support the + operator for concatenation. {'a': 1, 'b': 2} + {'c': 3} raises a TypeError because the + operator is not defined for dictionaries. To merge dictionaries, you need to use other methods like the | operator (Python 3.9+), the ** unpacking operator, the update() method, or the dict() constructor with unpacking. The + operator works for lists, tuples, and strings, but not for dictionaries.

+ operator with dictionaries:
• {'a': 1, 'b': 2} + {'c': 3} raises TypeError
• + operator not supported for dictionaries
• TypeError: unsupported operand type(s) for +: 'dict' and 'dict'
• Use | or update() or ** for merging
• Cannot concatenate dictionaries

How it works:
• {'a': 1, 'b': 2} + {'c': 3} attempts to add dictionaries
• Python looks for + operator implementation on dict
• Finds no + operator for dict type
• Raises TypeError
• Cannot perform operation

Example:
{'a': 1, 'b': 2} + {'c': 3}           # TypeError
{'a': 1, 'b': 2} | {'c': 3}           # {'a': 1, 'b': 2, 'c': 3} (works)
{**{'a': 1, 'b': 2}, **{'c': 3}}      # {'a': 1, 'b': 2, 'c': 3} (works)

Common uses:
• Merging dictionaries: use dict1 | dict2 (Python 3.9+)
• Merging: use {**dict1, **dict2}
• Merging: use dict1.update(dict2)
• Use appropriate method for merging

Example: {'a': 1, 'b': 2} + {'c': 3} raises a TypeError because dictionaries don't support the + operator - use the | operator, ** unpacking, or update() to merge dictionaries instead.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1} * 2?`, 
    o: ["TypeError", "{'a': 1, 'a': 1}", "Error", "None"], 
    c: 0, 
    e: "Dictionaries don't support * operator.",
    de: `Dictionaries don't support the * operator for repetition. {'a': 1} * 2 raises a TypeError because the * operator is not defined for dictionaries. The * operator works for lists, tuples, and strings (repeating them), but not for dictionaries. Dictionaries have unique keys, so repeating a dictionary wouldn't make sense - you can't have duplicate keys in a dictionary.

* operator with dictionaries:
• {'a': 1} * 2 raises TypeError
• * operator not supported for dictionaries
• TypeError: unsupported operand type(s) for *: 'dict' and 'int'
• Cannot repeat dictionaries (unique keys requirement)
• Use other methods for duplicating

How it works:
• {'a': 1} * 2 attempts to multiply dictionary
• Python looks for * operator implementation on dict
• Finds no * operator for dict type
• Raises TypeError
• Cannot perform operation

Example:
{'a': 1} * 2                          # TypeError
[1, 2] * 2                            # [1, 2, 1, 2] (works for lists)
{'a': 1, 'b': 2} * 3                  # TypeError
dict({'a': 1} * 2)                    # TypeError (still fails)

Common uses:
• Copying dictionaries: use dict.copy() or dict(dict)
• Merging dictionaries: use dict1 | dict2 or {**dict1, **dict2}
• Don't use * for dictionaries
• Use appropriate methods

Example: {'a': 1} * 2 raises a TypeError because dictionaries don't support the * operator - dictionaries have unique keys, so repetition doesn't make sense, and you should use copy() or dict() to create copies instead.
`
  }),
  
  // 71-80: Dictionary Views and Iteration
  (_i: number) => ({ 
    q: `What is d = {'a': 1, 'b': 2}; k = d.keys(); d['c'] = 3; list(k)?`, 
    o: ["['a', 'b', 'c']", "['a', 'b']", "Error", "None"], 
    c: 0, 
    e: "dict_keys view reflects changes to dict.",
    de: `Dictionary views are dynamic - they reflect changes to the dictionary. If d = {'a': 1, 'b': 2}, k = d.keys(), and then d['c'] = 3, list(k) returns ['a', 'b', 'c'] because the keys() view reflects changes to the dictionary. When you add a new key 'c', the view automatically includes it when you iterate or convert it to a list. Views are live connections to the dictionary - they show the current state of the dictionary, not a snapshot.

dict_keys view - dynamic:
• d = {'a': 1, 'b': 2}; k = d.keys(); d['c'] = 3; list(k) = ['a', 'b', 'c']
• keys() creates dynamic view
• View reflects changes to dictionary
• Adding 'c' updates view
• Returns current keys: ['a', 'b', 'c']

How it works:
• d = {'a': 1, 'b': 2} creates dictionary
• k = d.keys() creates view (not snapshot)
• d['c'] = 3 adds new key 'c'
• View automatically includes 'c' (dynamic)
• list(k) converts view: ['a', 'b', 'c']

Example:
d = {'a': 1, 'b': 2}
k = d.keys()           # dict_keys(['a', 'b'])
d['c'] = 3             # Adds 'c'
list(k)                # ['a', 'b', 'c'] (includes 'c')

Common uses:
• Dynamic views: k = dict.keys() (reflects changes)
• Live iteration: for key in dict.keys(): (always current)
• Dictionary monitoring
• View behavior awareness

Example: If d = {'a': 1, 'b': 2}, k = d.keys(), and then d['c'] = 3, list(k) returns ['a', 'b', 'c'] because the keys() view reflects changes to the dictionary, so it includes the newly added key 'c'.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; v = d.values(); d['b'] = 2; list(v)?`, 
    o: ["[1, 2]", "[1]", "Error", "None"], 
    c: 0, 
    e: "dict_values view reflects changes to dict.",
    de: `Dictionary views are dynamic - they reflect changes to the dictionary. If d = {'a': 1}, v = d.values(), and then d['b'] = 2, list(v) returns [1, 2] because the values() view reflects changes to the dictionary. When you add a new key-value pair 'b': 2, the view automatically includes the new value 2 when you iterate or convert it to a list. Views are live connections to the dictionary - they show the current state of the dictionary, not a snapshot.

dict_values view - dynamic:
• d = {'a': 1}; v = d.values(); d['b'] = 2; list(v) = [1, 2]
• values() creates dynamic view
• View reflects changes to dictionary
• Adding 'b': 2 updates view
• Returns current values: [1, 2]

How it works:
• d = {'a': 1} creates dictionary
• v = d.values() creates view (not snapshot)
• d['b'] = 2 adds new pair 'b': 2
• View automatically includes 2 (dynamic)
• list(v) converts view: [1, 2]

Example:
d = {'a': 1}
v = d.values()         # dict_values([1])
d['b'] = 2             # Adds 'b': 2
list(v)                # [1, 2] (includes 2)

Common uses:
• Dynamic views: v = dict.values() (reflects changes)
• Live iteration: for value in dict.values(): (always current)
• Dictionary monitoring
• View behavior awareness

Example: If d = {'a': 1}, v = d.values(), and then d['b'] = 2, list(v) returns [1, 2] because the values() view reflects changes to the dictionary, so it includes the newly added value 2.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {'a': 1}; i = d.items(); d['b'] = 2; list(i)?`, 
    o: ["[('a', 1), ('b', 2)]", "[('a', 1)]", "Error", "None"], 
    c: 0, 
    e: "dict_items view reflects changes to dict.",
    de: `Dictionary views are dynamic - they reflect changes to the dictionary. If d = {'a': 1}, i = d.items(), and then d['b'] = 2, list(i) returns [('a', 1), ('b', 2)] because the items() view reflects changes to the dictionary. When you add a new key-value pair 'b': 2, the view automatically includes the new pair ('b', 2) when you iterate or convert it to a list. Views are live connections to the dictionary - they show the current state of the dictionary, not a snapshot.

dict_items view - dynamic:
• d = {'a': 1}; i = d.items(); d['b'] = 2; list(i) = [('a', 1), ('b', 2)]
• items() creates dynamic view
• View reflects changes to dictionary
• Adding 'b': 2 updates view
• Returns current pairs: [('a', 1), ('b', 2)]

How it works:
• d = {'a': 1} creates dictionary
• i = d.items() creates view (not snapshot)
• d['b'] = 2 adds new pair 'b': 2
• View automatically includes ('b', 2) (dynamic)
• list(i) converts view: [('a', 1), ('b', 2)]

Example:
d = {'a': 1}
i = d.items()          # dict_items([('a', 1)])
d['b'] = 2             # Adds 'b': 2
list(i)                # [('a', 1), ('b', 2)] (includes ('b', 2))

Common uses:
• Dynamic views: i = dict.items() (reflects changes)
• Live iteration: for k, v in dict.items(): (always current)
• Dictionary monitoring
• View behavior awareness

Example: If d = {'a': 1}, i = d.items(), and then d['b'] = 2, list(i) returns [('a', 1), ('b', 2)] because the items() view reflects changes to the dictionary, so it includes the newly added pair ('b', 2).
`
  }),
  (_i: number) => ({ 
    q: `What is for k in {'a': 1, 'b': 2}: print(k)?`, 
    o: ["Prints 'a' then 'b'", "Prints 1 then 2", "Error", "None"], 
    c: 0, 
    e: "Iterating dict directly iterates over keys.",
    de: `Iterating over a dictionary directly iterates over its keys. for k in {'a': 1, 'b': 2}: print(k) prints 'a' then 'b' because when you iterate over a dictionary in a for loop, Python iterates over the keys, not the values or key-value pairs. This is equivalent to iterating over .keys() - iterating the dictionary directly is shorthand for iterating over its keys.

Iterating dictionary directly:
• for k in {'a': 1, 'b': 2}: print(k) prints 'a' then 'b'
• Iterating dict iterates over keys
• Prints keys: 'a', 'b'
• Not values or pairs
• Equivalent to for k in dict.keys():

How it works:
• for k in {'a': 1, 'b': 2} iterates over dictionary
• Python iterates over keys: 'a', 'b'
• First iteration: k = 'a', prints 'a'
• Second iteration: k = 'b', prints 'b'
• Prints: 'a' then 'b'

Example:
for k in {'a': 1, 'b': 2}:
    print(k)           # Prints: 'a' then 'b'
for k in {'a': 1, 'b': 2}.keys():
    print(k)           # Same: 'a' then 'b'

Common uses:
• Iterating keys: for key in dict: (shorthand)
• Key iteration: for k in items: (iterates keys)
• Dictionary key access
• Common iteration pattern

Example: for k in {'a': 1, 'b': 2}: print(k) prints 'a' then 'b' because iterating over a dictionary directly iterates over its keys, not its values or key-value pairs.
`
  }),
  (_i: number) => ({ 
    q: `What is for v in {'a': 1, 'b': 2}.values(): print(v)?`, 
    o: ["Prints 1 then 2", "Prints 'a' then 'b'", "Error", "None"], 
    c: 0, 
    e: "Iterating .values() iterates over values.",
    de: `Iterating over .values() iterates over the dictionary's values. for v in {'a': 1, 'b': 2}.values(): print(v) prints 1 then 2 because .values() returns a view of all values, and iterating over that view gives you the values, not the keys. This is how you iterate over values specifically - if you iterate the dictionary directly, you get keys, but if you iterate over .values(), you get values.

Iterating .values():
• for v in {'a': 1, 'b': 2}.values(): print(v) prints 1 then 2
• .values() returns view of values
• Iterating view gives values
• Prints values: 1, 2
• Not keys or pairs

How it works:
• {'a': 1, 'b': 2}.values() returns view: [1, 2]
• for v in view iterates over values
• First iteration: v = 1, prints 1
• Second iteration: v = 2, prints 2
• Prints: 1 then 2

Example:
for v in {'a': 1, 'b': 2}.values():
    print(v)           # Prints: 1 then 2
for v in {'x': 10, 'y': 20}.values():
    print(v)           # Prints: 10 then 20

Common uses:
• Iterating values: for value in dict.values():
• Value iteration: for v in items.values(): (iterates values)
• Dictionary value access
• Value-specific iteration

Example: for v in {'a': 1, 'b': 2}.values(): print(v) prints 1 then 2 because iterating over .values() iterates over the dictionary's values, not its keys or key-value pairs.
`
  }),
  (_i: number) => ({ 
    q: `What is for k, v in {'a': 1, 'b': 2}.items(): print(k, v)?`, 
    o: ["Prints 'a' 1 then 'b' 2", "Prints 1 'a' then 2 'b'", "Error", "None"], 
    c: 0, 
    e: "Iterating .items() unpacks key-value pairs.",
    de: `Iterating over .items() iterates over key-value pairs and unpacks them. for k, v in {'a': 1, 'b': 2}.items(): print(k, v) prints 'a' 1 then 'b' 2 because .items() returns a view of (key, value) tuples, and iterating with k, v unpacks each tuple, assigning the key to k and the value to v. This is how you iterate over both keys and values together - if you iterate the dictionary directly, you get keys, but if you iterate over .items() with unpacking, you get both keys and values.

Iterating .items() with unpacking:
• for k, v in {'a': 1, 'b': 2}.items(): print(k, v) prints 'a' 1 then 'b' 2
• .items() returns view of (key, value) tuples
• k, v unpacks each tuple
• k gets key, v gets value
• Prints keys and values together

How it works:
• {'a': 1, 'b': 2}.items() returns view: [('a', 1), ('b', 2)]
• for k, v in view unpacks each tuple
• First iteration: k='a', v=1, prints 'a' 1
• Second iteration: k='b', v=2, prints 'b' 2
• Prints: 'a' 1 then 'b' 2

Example:
for k, v in {'a': 1, 'b': 2}.items():
    print(k, v)        # Prints: 'a' 1 then 'b' 2
for key, value in {'x': 10, 'y': 20}.items():
    print(key, value)  # Prints: 'x' 10 then 'y' 20

Common uses:
• Iterating pairs: for k, v in dict.items():
• Key-value iteration: for key, value in items.items(): (iterates pairs)
• Dictionary pair access
• Both keys and values together

Example: for k, v in {'a': 1, 'b': 2}.items(): print(k, v) prints 'a' 1 then 'b' 2 because iterating over .items() with unpacking iterates over key-value pairs, assigning the key to k and the value to v.
`
  }),
  (_i: number) => ({ 
    q: `What is list({'a': 1, 'b': 2})?`, 
    o: ["['a', 'b']", "[1, 2]", "Error", "None"], 
    c: 0, 
    e: "list() on dict converts keys to list.",
    de: `The list() function converts a dictionary to a list of its keys. list({'a': 1, 'b': 2}) returns ['a', 'b'] because list() iterates over the dictionary, which iterates over keys, and collects those keys into a list. This is equivalent to list(dict.keys()) - when you call list() on a dictionary directly, it creates a list of the keys, not the values or key-value pairs.

list() on dictionary:
• list({'a': 1, 'b': 2}) = ['a', 'b']
• list() iterates over dictionary
• Dictionary iteration gives keys
• Collects keys into list
• Returns list of keys

How it works:
• list() called with {'a': 1, 'b': 2}
• Iterates over dictionary (keys: 'a', 'b')
• Collects keys: 'a', 'b'
• Returns new list: ['a', 'b']
• Same as list(dict.keys())

Example:
list({'a': 1, 'b': 2})                # ['a', 'b'] (keys)
list({'a': 1, 'b': 2}.keys())         # ['a', 'b'] (same)
list({'x': 10, 'y': 20})              # ['x', 'y'] (keys)

Common uses:
• Getting key list: key_list = list(dict)
• Converting keys: keys = list(items)
• Key list creation
• Dictionary key extraction

Example: list({'a': 1, 'b': 2}) returns ['a', 'b'] because list() iterates over the dictionary, which iterates over keys, and collects those keys into a list.
`
  }),
  (_i: number) => ({ 
    q: `What is tuple({'a': 1, 'b': 2})?`, 
    o: ["('a', 'b')", "(1, 2)", "Error", "None"], 
    c: 0, 
    e: "tuple() on dict converts keys to tuple.",
    de: `The tuple() function converts a dictionary to a tuple of its keys. tuple({'a': 1, 'b': 2}) returns ('a', 'b') because tuple() iterates over the dictionary, which iterates over keys, and collects those keys into a tuple. This is equivalent to tuple(dict.keys()) - when you call tuple() on a dictionary directly, it creates a tuple of the keys, not the values or key-value pairs.

tuple() on dictionary:
• tuple({'a': 1, 'b': 2}) = ('a', 'b')
• tuple() iterates over dictionary
• Dictionary iteration gives keys
• Collects keys into tuple
• Returns tuple of keys

How it works:
• tuple() called with {'a': 1, 'b': 2}
• Iterates over dictionary (keys: 'a', 'b')
• Collects keys: 'a', 'b'
• Returns new tuple: ('a', 'b')
• Same as tuple(dict.keys())

Example:
tuple({'a': 1, 'b': 2})               # ('a', 'b') (keys)
tuple({'a': 1, 'b': 2}.keys())        # ('a', 'b') (same)
tuple({'x': 10, 'y': 20})             # ('x', 'y') (keys)

Common uses:
• Getting key tuple: key_tuple = tuple(dict)
• Converting keys: keys = tuple(items)
• Key tuple creation
• Dictionary key extraction

Example: tuple({'a': 1, 'b': 2}) returns ('a', 'b') because tuple() iterates over the dictionary, which iterates over keys, and collects those keys into a tuple.
`
  }),
  (_i: number) => ({ 
    q: `What is set({'a': 1, 'b': 2})?`, 
    o: ["{'a', 'b'}", "{1, 2}", "Error", "None"], 
    c: 0, 
    e: "set() on dict converts keys to set.",
    de: `The set() function converts a dictionary to a set of its keys. set({'a': 1, 'b': 2}) returns {'a', 'b'} because set() iterates over the dictionary, which iterates over keys, and collects those keys into a set. This is equivalent to set(dict.keys()) - when you call set() on a dictionary directly, it creates a set of the keys, not the values or key-value pairs.

set() on dictionary:
• set({'a': 1, 'b': 2}) = {'a', 'b'}
• set() iterates over dictionary
• Dictionary iteration gives keys
• Collects keys into set
• Returns set of keys

How it works:
• set() called with {'a': 1, 'b': 2}
• Iterates over dictionary (keys: 'a', 'b')
• Collects keys: 'a', 'b'
• Returns new set: {'a', 'b'}
• Same as set(dict.keys())

Example:
set({'a': 1, 'b': 2})                 # {'a', 'b'} (keys)
set({'a': 1, 'b': 2}.keys())          # {'a', 'b'} (same)
set({'x': 10, 'y': 20})               # {'x', 'y'} (keys)

Common uses:
• Getting key set: key_set = set(dict)
• Converting keys: keys = set(items)
• Key set creation
• Dictionary key extraction

Example: set({'a': 1, 'b': 2}) returns {'a', 'b'} because set() iterates over the dictionary, which iterates over keys, and collects those keys into a set.
`
  }),
  (_i: number) => ({ 
    q: `What is sorted({'c': 3, 'a': 1, 'b': 2})?`, 
    o: ["['a', 'b', 'c']", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "sorted() on dict sorts keys.",
    de: `The sorted() function sorts a dictionary by its keys and returns a list of sorted keys. sorted({'c': 3, 'a': 1, 'b': 2}) returns ['a', 'b', 'c'] because sorted() iterates over the dictionary, which iterates over keys, and sorts those keys. This is equivalent to sorted(dict.keys()) - when you call sorted() on a dictionary directly, it sorts the keys, not the values or key-value pairs.

sorted() on dictionary:
• sorted({'c': 3, 'a': 1, 'b': 2}) = ['a', 'b', 'c']
• sorted() iterates over dictionary
• Dictionary iteration gives keys
• Sorts keys alphabetically
• Returns sorted list of keys

How it works:
• sorted() called with {'c': 3, 'a': 1, 'b': 2}
• Iterates over dictionary (keys: 'c', 'a', 'b')
• Sorts keys: 'a' < 'b' < 'c'
• Returns sorted list: ['a', 'b', 'c']
• Same as sorted(dict.keys())

Example:
sorted({'c': 3, 'a': 1, 'b': 2})      # ['a', 'b', 'c'] (sorted keys)
sorted({'x': 10, 'a': 1, 'z': 20})    # ['a', 'x', 'z'] (sorted keys)
sorted({'3': 3, '1': 1, '2': 2})      # ['1', '2', '3'] (sorted keys)

Common uses:
• Sorting keys: sorted_keys = sorted(dict)
• Key sorting: keys = sorted(items)
• Key list sorting
• Dictionary key ordering

Example: sorted({'c': 3, 'a': 1, 'b': 2}) returns ['a', 'b', 'c'] because sorted() iterates over the dictionary, which iterates over keys, and sorts those keys alphabetically into a list.
`
  }),
  
  // 81-90: Dictionary Advanced Features
  (_i: number) => ({ 
    q: `What is {'a': 1}.fromkeys(['a', 'b'])?`, 
    o: ["{'a': None, 'b': None}", "{'a': 1}", "Error", "None"], 
    c: 0, 
    e: "fromkeys() creates dict with keys, values default to None.",
    de: `The fromkeys() method is a class method that creates a dictionary from an iterable of keys. {'a': 1}.fromkeys(['a', 'b']) returns {'a': None, 'b': None} because fromkeys() is a class method that ignores the instance dictionary and creates a new dictionary with the given keys. When no value is provided, all values default to None. This is useful for initializing dictionaries with a set of keys and default values.

fromkeys() method:
• {'a': 1}.fromkeys(['a', 'b']) = {'a': None, 'b': None}
• fromkeys() is class method (ignores instance)
• Creates new dictionary with given keys
• Values default to None if not provided
• Useful for initialization

How it works:
• fromkeys(['a', 'b']) called on {'a': 1}
• Ignores instance dictionary {'a': 1}
• Creates new dictionary with keys: 'a', 'b'
• Values default to None (not provided)
• Returns: {'a': None, 'b': None}

Example:
{'a': 1}.fromkeys(['a', 'b'])         # {'a': None, 'b': None}
dict.fromkeys(['a', 'b'])             # {'a': None, 'b': None} (same)
{'x': 10}.fromkeys(['x', 'y', 'z'])  # {'x': None, 'y': None, 'z': None}

Common uses:
• Initializing dictionaries: dict = dict.fromkeys(keys)
• Default values: data = dict.fromkeys(keys, default)
• Key initialization
• Dictionary creation

Example: {'a': 1}.fromkeys(['a', 'b']) returns {'a': None, 'b': None} because fromkeys() is a class method that creates a new dictionary with the given keys, and when no value is provided, all values default to None.
`
  }),
  (_i: number) => ({ 
    q: `What is dict.fromkeys(['a', 'b'], 0)?`, 
    o: ["{'a': 0, 'b': 0}", "{'a': None, 'b': None}", "Error", "None"], 
    c: 0, 
    e: "fromkeys() with value sets all values to that value.",
    de: `The fromkeys() method can take a second argument as a default value for all keys. dict.fromkeys(['a', 'b'], 0) returns {'a': 0, 'b': 0} because fromkeys() creates a new dictionary with the given keys, and when a value is provided, all keys are set to that value. This is useful for initializing dictionaries with a set of keys and the same default value for all keys.

fromkeys() with value:
• dict.fromkeys(['a', 'b'], 0) = {'a': 0, 'b': 0}
• fromkeys() creates new dictionary with keys
• Second argument sets value for all keys
• All keys get same value: 0
• Useful for initialization

How it works:
• fromkeys(['a', 'b'], 0) called on dict class
• Creates new dictionary with keys: 'a', 'b'
• Sets all values to 0 (second argument)
• Returns: {'a': 0, 'b': 0}

Example:
dict.fromkeys(['a', 'b'], 0)          # {'a': 0, 'b': 0}
dict.fromkeys(['x', 'y'], 'default')  # {'x': 'default', 'y': 'default'}
dict.fromkeys(['1', '2'], [])         # {'1': [], '2': []} (same list reference!)

Common uses:
• Initializing with defaults: dict = dict.fromkeys(keys, default)
• Default values: data = dict.fromkeys(keys, 0)
• Key initialization with values
• Dictionary creation with defaults

Example: dict.fromkeys(['a', 'b'], 0) returns {'a': 0, 'b': 0} because fromkeys() creates a new dictionary with the given keys, and when a value (0) is provided, all keys are set to that value.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.fromkeys(['c', 'd'])?`, 
    o: ["{'c': None, 'd': None}", "{'a': 1, 'b': 2}", "Error", "None"], 
    c: 0, 
    e: "fromkeys() is class method, creates new dict.",
    de: `The fromkeys() method is a class method that creates a new dictionary, ignoring the instance dictionary. {'a': 1, 'b': 2}.fromkeys(['c', 'd']) returns {'c': None, 'd': None} because fromkeys() is a class method that ignores the instance dictionary {'a': 1, 'b': 2} and creates a new dictionary with the given keys ['c', 'd']. The instance dictionary is not used or modified - fromkeys() always creates a new dictionary.

fromkeys() - class method:
• {'a': 1, 'b': 2}.fromkeys(['c', 'd']) = {'c': None, 'd': None}
• fromkeys() is class method (ignores instance)
• Creates new dictionary with given keys
• Instance dictionary {'a': 1, 'b': 2} not used
• Returns new dictionary

How it works:
• fromkeys(['c', 'd']) called on {'a': 1, 'b': 2}
• Ignores instance dictionary {'a': 1, 'b': 2}
• Creates new dictionary with keys: 'c', 'd'
• Values default to None (not provided)
• Returns: {'c': None, 'd': None}

Example:
{'a': 1, 'b': 2}.fromkeys(['c', 'd']) # {'c': None, 'd': None} (new dict)
{'x': 10}.fromkeys(['a', 'b'])        # {'a': None, 'b': None} (new dict)
dict.fromkeys(['a', 'b'])             # {'a': None, 'b': None} (same)

Common uses:
• Creating new dictionaries: dict = dict.fromkeys(keys)
• Initialization: data = items.fromkeys(new_keys, default)
• Class method usage
• Dictionary creation

Example: {'a': 1, 'b': 2}.fromkeys(['c', 'd']) returns {'c': None, 'd': None} because fromkeys() is a class method that ignores the instance dictionary and creates a new dictionary with the given keys.
`
  }),
  (_i: number) => ({ 
    q: `What is max({'a': 1, 'b': 2, 'c': 3})?`, 
    o: ["'c'", "3", "Error", "None"], 
    c: 0, 
    e: "max() on dict returns max key.",
    de: `The max() function on a dictionary returns the maximum key. max({'a': 1, 'b': 2, 'c': 3}) returns 'c' because max() iterates over the dictionary, which iterates over keys, and returns the maximum key. Keys are compared using their natural ordering (strings are compared lexicographically, numbers are compared numerically). This is equivalent to max(dict.keys()) - when you call max() on a dictionary directly, it finds the maximum key, not the maximum value.

max() on dictionary:
• max({'a': 1, 'b': 2, 'c': 3}) = 'c'
• max() iterates over dictionary (keys)
• Compares keys: 'a' < 'b' < 'c'
• Returns maximum key: 'c'
• Not maximum value (value 3)

How it works:
• max() called with {'a': 1, 'b': 2, 'c': 3}
• Iterates over dictionary (keys: 'a', 'b', 'c')
• Compares keys: 'a' < 'b' < 'c' (lexicographic)
• Finds maximum key: 'c'
• Returns: 'c'

Example:
max({'a': 1, 'b': 2, 'c': 3})        # 'c' (max key)
max({'x': 10, 'a': 1, 'z': 20})      # 'z' (max key)
max({'1': 1, '2': 2, '3': 3})        # '3' (max key, string)

Common uses:
• Finding max key: max_key = max(dict)
• Key comparison: largest = max(items)
• Dictionary key ordering
• Maximum key finding

Example: max({'a': 1, 'b': 2, 'c': 3}) returns 'c' because max() iterates over the dictionary, which iterates over keys, and returns the maximum key 'c' (lexicographically largest).
`
  }),
  (_i: number) => ({ 
    q: `What is min({'a': 1, 'b': 2, 'c': 3})?`, 
    o: ["'a'", "1", "Error", "None"], 
    c: 0, 
    e: "min() on dict returns min key.",
    de: `The min() function on a dictionary returns the minimum key. min({'a': 1, 'b': 2, 'c': 3}) returns 'a' because min() iterates over the dictionary, which iterates over keys, and returns the minimum key. Keys are compared using their natural ordering (strings are compared lexicographically, numbers are compared numerically). This is equivalent to min(dict.keys()) - when you call min() on a dictionary directly, it finds the minimum key, not the minimum value.

min() on dictionary:
• min({'a': 1, 'b': 2, 'c': 3}) = 'a'
• min() iterates over dictionary (keys)
• Compares keys: 'a' < 'b' < 'c'
• Returns minimum key: 'a'
• Not minimum value (value 1)

How it works:
• min() called with {'a': 1, 'b': 2, 'c': 3}
• Iterates over dictionary (keys: 'a', 'b', 'c')
• Compares keys: 'a' < 'b' < 'c' (lexicographic)
• Finds minimum key: 'a'
• Returns: 'a'

Example:
min({'a': 1, 'b': 2, 'c': 3})        # 'a' (min key)
min({'x': 10, 'a': 1, 'z': 20})      # 'a' (min key)
min({'1': 1, '2': 2, '3': 3})        # '1' (min key, string)

Common uses:
• Finding min key: min_key = min(dict)
• Key comparison: smallest = min(items)
• Dictionary key ordering
• Minimum key finding

Example: min({'a': 1, 'b': 2, 'c': 3}) returns 'a' because min() iterates over the dictionary, which iterates over keys, and returns the minimum key 'a' (lexicographically smallest).
`
  }),
  (_i: number) => ({ 
    q: `What is max({'a': 1, 'b': 2, 'c': 3}.values())?`, 
    o: ["3", "'c'", "Error", "None"], 
    c: 0, 
    e: "max() on .values() returns max value.",
    de: `The max() function on .values() returns the maximum value. max({'a': 1, 'b': 2, 'c': 3}.values()) returns 3 because .values() returns a view of all values [1, 2, 3], and max() finds the maximum value. Values are compared using their natural ordering (numbers are compared numerically, strings are compared lexicographically). This is how you find the maximum value in a dictionary - if you call max() on the dictionary directly, you get the maximum key, but if you call max() on .values(), you get the maximum value.

max() on .values():
• max({'a': 1, 'b': 2, 'c': 3}.values()) = 3
• .values() returns view of values: [1, 2, 3]
• max() compares values: 1 < 2 < 3
• Returns maximum value: 3
• Not maximum key (key 'c')

How it works:
• {'a': 1, 'b': 2, 'c': 3}.values() returns view: [1, 2, 3]
• max() called with values view
• Compares values: 1 < 2 < 3 (numeric)
• Finds maximum value: 3
• Returns: 3

Example:
max({'a': 1, 'b': 2, 'c': 3}.values()) # 3 (max value)
max({'x': 10, 'y': 20}.values())       # 20 (max value)
max({'a': 'z', 'b': 'a'}.values())     # 'z' (max value, string)

Common uses:
• Finding max value: max_value = max(dict.values())
• Value comparison: largest = max(items.values())
• Dictionary value ordering
• Maximum value finding

Example: max({'a': 1, 'b': 2, 'c': 3}.values()) returns 3 because .values() returns a view of all values [1, 2, 3], and max() finds the maximum value, which is 3.
`
  }),
  (_i: number) => ({ 
    q: `What is sum({'a': 1, 'b': 2, 'c': 3}.values())?`, 
    o: ["6", "0", "Error", "None"], 
    c: 0, 
    e: "sum() on .values() adds all values.",
    de: `The sum() function on .values() adds all values in the dictionary. sum({'a': 1, 'b': 2, 'c': 3}.values()) returns 6 because .values() returns a view of all values [1, 2, 3], and sum() adds them: 1 + 2 + 3 = 6. This is how you sum all values in a dictionary - sum() works with any iterable of numbers, and .values() provides an iterable of values. If the dictionary is empty, sum() returns 0.

sum() on .values():
• sum({'a': 1, 'b': 2, 'c': 3}.values()) = 6
• .values() returns view of values: [1, 2, 3]
• sum() adds all values: 1 + 2 + 3
• Returns sum: 6
• Works with numeric values

How it works:
• {'a': 1, 'b': 2, 'c': 3}.values() returns view: [1, 2, 3]
• sum() called with values view
• Adds all values: 1 + 2 + 3
• Computes sum: 6
• Returns: 6

Example:
sum({'a': 1, 'b': 2, 'c': 3}.values()) # 6 (1 + 2 + 3)
sum({'x': 10, 'y': 20}.values())       # 30 (10 + 20)
sum({}.values())                        # 0 (empty, no values)

Common uses:
• Summing values: total = sum(dict.values())
• Value aggregation: sum = sum(items.values())
• Dictionary value summing
• Numeric value operations

Example: sum({'a': 1, 'b': 2, 'c': 3}.values()) returns 6 because .values() returns a view of all values [1, 2, 3], and sum() adds them together: 1 + 2 + 3 = 6.
`
  }),
  (_i: number) => ({ 
    q: `What is all({'a': 1, 'b': 0}.values())?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "all() checks if all values are truthy.",
    de: `The all() function on .values() checks if all values are truthy. all({'a': 1, 'b': 0}.values()) returns False because .values() returns a view of all values [1, 0], and all() checks if all values are truthy. Since 1 is truthy but 0 is falsy, all() returns False - it requires all values to be truthy. This is how you check if all values in a dictionary are truthy - all() returns True only if all values are truthy, otherwise it returns False.

all() on .values():
• all({'a': 1, 'b': 0}.values()) = False
• .values() returns view of values: [1, 0]
• all() checks if all values truthy
• 1 is truthy, 0 is falsy
• Not all truthy, returns False

How it works:
• {'a': 1, 'b': 0}.values() returns view: [1, 0]
• all() called with values view
• Checks each value: 1 (truthy), 0 (falsy)
• 1 is truthy, 0 is falsy
• Not all truthy, returns: False

Example:
all({'a': 1, 'b': 0}.values())        # False (0 is falsy)
all({'a': 1, 'b': 2}.values())        # True (all truthy)
all({'a': 0, 'b': 0}.values())        # False (all falsy)

Common uses:
• Checking all truthy: if all(dict.values()):
• Value validation: valid = all(items.values())
• Dictionary value checking
• Truthiness validation

Example: all({'a': 1, 'b': 0}.values()) returns False because .values() returns a view of all values [1, 0], and all() checks if all values are truthy - since 1 is truthy but 0 is falsy, all() returns False.
`
  }),
  (_i: number) => ({ 
    q: `What is any({'a': 0, 'b': 0}.values())?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "any() checks if any value is truthy.",
    de: `The any() function on .values() checks if any value is truthy. any({'a': 0, 'b': 0}.values()) returns False because .values() returns a view of all values [0, 0], and any() checks if any value is truthy. Since both 0 and 0 are falsy, any() returns False - it requires at least one truthy value. This is how you check if any value in a dictionary is truthy - any() returns True if at least one value is truthy, otherwise it returns False.

any() on .values():
• any({'a': 0, 'b': 0}.values()) = False
• .values() returns view of values: [0, 0]
• any() checks if any value truthy
• 0 is falsy, 0 is falsy
• No truthy values, returns False

How it works:
• {'a': 0, 'b': 0}.values() returns view: [0, 0]
• any() called with values view
• Checks each value: 0 (falsy), 0 (falsy)
• Both 0 and 0 are falsy
• No truthy values, returns: False

Example:
any({'a': 0, 'b': 0}.values())        # False (all falsy)
any({'a': 0, 'b': 1}.values())        # True (1 is truthy)
any({'a': 1, 'b': 2}.values())        # True (all truthy)

Common uses:
• Checking any truthy: if any(dict.values()):
• Value validation: has_truthy = any(items.values())
• Dictionary value checking
• Truthiness detection

Example: any({'a': 0, 'b': 0}.values()) returns False because .values() returns a view of all values [0, 0], and any() checks if any value is truthy - since both 0 and 0 are falsy, any() returns False.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.get('a') or {'a': 1, 'b': 2}.get('c')?`, 
    o: ["1", "None", "Error", "2"], 
    c: 0, 
    e: "or returns first truthy value, 1 is truthy.",
    de: `The or operator returns the first truthy value or the last value if all are falsy. {'a': 1, 'b': 2}.get('a') or {'a': 1, 'b': 2}.get('c') returns 1 because get('a') returns 1 (truthy), and or returns the first truthy value. Since 1 is truthy, or returns 1 without evaluating the second expression. This is a common pattern for providing fallback values - if the first value is truthy, use it, otherwise use the second value.

or operator with get():
• {'a': 1, 'b': 2}.get('a') or {'a': 1, 'b': 2}.get('c') = 1
• get('a') returns 1 (truthy)
• or returns first truthy value
• Returns 1 (without evaluating second get())
• Short-circuit evaluation

How it works:
• get('a') called on {'a': 1, 'b': 2}
• Returns 1 (key 'a' exists)
• or checks if 1 is truthy (it is)
• Returns 1 (first truthy value)
• Doesn't evaluate get('c') (short-circuit)

Example:
{'a': 1, 'b': 2}.get('a') or get('c')  # 1 (first truthy)
{'a': 0, 'b': 2}.get('a') or get('c')  # None (0 is falsy, 'c' not found)
{'a': 1}.get('c') or 0                 # 0 (None is falsy, uses 0)

Common uses:
• Fallback values: value = dict.get(key) or default
• Providing defaults: result = items.get(key) or fallback
• Default value patterns
• Short-circuit evaluation

Example: {'a': 1, 'b': 2}.get('a') or {'a': 1, 'b': 2}.get('c') returns 1 because get('a') returns 1 (truthy), and or returns the first truthy value, so it returns 1 without evaluating the second get().
`
  }),
  
  // 91-100: Dictionary Edge Cases and Special Features
  (_i: number) => ({ 
    q: `What is {1: 'a', 2: 'b', 3: 'c'}[1]?`, 
    o: ["'a'", "1", "Error", "None"], 
    c: 0, 
    e: "Integer keys work in dictionaries.",
    de: `Integer keys work in dictionaries. {1: 'a', 2: 'b', 3: 'c'}[1] returns 'a' because dictionaries can use integers as keys, and accessing [1] looks up the key 1 in the dictionary, which maps to the value 'a'. Dictionary keys can be any hashable type (immutable types like integers, strings, tuples), not just strings. This allows flexible key types for different use cases.

Integer keys in dictionaries:
• {1: 'a', 2: 'b', 3: 'c'}[1] = 'a'
• Integer keys work in dictionaries
• Key 1 maps to value 'a'
• Dictionaries support any hashable key type
• Returns value: 'a'

How it works:
• {1: 'a', 2: 'b', 3: 'c'} creates dictionary with integer keys
• [1] accesses key 1 in dictionary
• Finds mapping: 1 → 'a'
• Returns value: 'a'

Example:
{1: 'a', 2: 'b', 3: 'c'}[1]            # 'a' (integer key)
{10: 'x', 20: 'y'}[10]                # 'x' (integer key)
{0: 'zero', 1: 'one'}[0]              # 'zero' (integer key)

Common uses:
• Numeric keys: dict = {1: value1, 2: value2}
• ID-based dictionaries: items = {id: data for id, data in pairs}
• Integer key dictionaries
• Flexible key types

Example: {1: 'a', 2: 'b', 3: 'c'}[1] returns 'a' because dictionaries can use integers as keys, and accessing [1] looks up the key 1, which maps to the value 'a'.
`
  }),
  (_i: number) => ({ 
    q: `What is {(1, 2): 'a', (3, 4): 'b'}[(1, 2)]?`, 
    o: ["'a'", "(1, 2)", "Error", "None"], 
    c: 0, 
    e: "Tuple keys work in dictionaries (immutable).",
    de: `Tuple keys work in dictionaries because tuples are immutable and hashable. {(1, 2): 'a', (3, 4): 'b'}[(1, 2)] returns 'a' because dictionaries can use tuples as keys, and accessing [(1, 2)] looks up the tuple key (1, 2) in the dictionary, which maps to the value 'a'. Tuple keys are useful for composite keys or multi-dimensional indexing, as long as all tuple elements are hashable (immutable).

Tuple keys in dictionaries:
• {(1, 2): 'a', (3, 4): 'b'}[(1, 2)] = 'a'
• Tuple keys work in dictionaries (immutable)
• Key (1, 2) maps to value 'a'
• Tuples are hashable (can be keys)
• Returns value: 'a'

How it works:
• {(1, 2): 'a', (3, 4): 'b'} creates dictionary with tuple keys
• [(1, 2)] accesses tuple key (1, 2) in dictionary
• Finds mapping: (1, 2) → 'a'
• Returns value: 'a'

Example:
{(1, 2): 'a', (3, 4): 'b'}[(1, 2)]     # 'a' (tuple key)
{(1, 1): 'x', (2, 2): 'y'}[(1, 1)]    # 'x' (tuple key)
{('a', 1): 'z', ('b', 2): 'w'}[('a', 1)] # 'z' (tuple key)

Common uses:
• Composite keys: dict = {(x, y): value for x, y in pairs}
• Multi-dimensional indexing: items = {(row, col): data}
• Tuple key dictionaries
• Complex key structures

Example: {(1, 2): 'a', (3, 4): 'b'}[(1, 2)] returns 'a' because dictionaries can use tuples as keys (tuples are immutable and hashable), and accessing [(1, 2)] looks up the tuple key (1, 2), which maps to the value 'a'.
`
  }),
  (_i: number) => ({ 
    q: `What is {[1, 2]: 'a'}?`, 
    o: ["TypeError", "{'[1, 2]': 'a'}", "Error", "None"], 
    c: 0, 
    e: "List keys don't work (lists are mutable/unhashable).",
    de: `List keys don't work in dictionaries because lists are mutable and unhashable. {[1, 2]: 'a'} raises a TypeError because dictionary keys must be hashable (immutable), and lists are mutable, so they cannot be used as keys. Python requires keys to be hashable so they can be used in the dictionary's internal hash table. To use list-like data as keys, you need to convert them to tuples (which are immutable and hashable).

List keys in dictionaries:
• {[1, 2]: 'a'} raises TypeError
• Lists are mutable (cannot be keys)
• Dictionary keys must be hashable
• TypeError: unhashable type: 'list'
• Cannot use lists as keys

How it works:
• {[1, 2]: 'a'} attempts to create dictionary with list key
• Python tries to hash the list [1, 2]
• Lists are mutable (cannot be hashed)
• Raises TypeError
• Cannot use mutable types as keys

Example:
{[1, 2]: 'a'}                          # TypeError: unhashable type: 'list'
{[]: 'a'}                              # TypeError: unhashable type: 'list'
{tuple([1, 2]): 'a'}                  # {(1, 2): 'a'} (works with tuple)

Common uses:
• Understanding key requirements: keys must be hashable
• Converting to tuples: key = tuple(list)
• Key type validation
• Hashable types only

Example: {[1, 2]: 'a'} raises a TypeError because lists are mutable and unhashable, so they cannot be used as dictionary keys. Use tuples instead: {tuple([1, 2]): 'a'}.
`
  }),
  (_i: number) => ({ 
    q: `What is {{'a': 1}: 'b'}?`, 
    o: ["TypeError", "{'a': 1, 'b': 'b'}", "Error", "None"], 
    c: 0, 
    e: "Dict keys don't work (dicts are mutable/unhashable).",
    de: `Dictionary keys don't work in dictionaries because dictionaries themselves are mutable and unhashable. {{'a': 1}: 'b'} raises a TypeError because dictionary keys must be hashable (immutable), and dictionaries are mutable, so they cannot be used as keys. Python requires keys to be hashable so they can be used in the dictionary's internal hash table. To use dictionary-like data as keys, you need to convert them to immutable types (like tuples of key-value pairs).

Dict keys in dictionaries:
• {{'a': 1}: 'b'} raises TypeError
• Dictionaries are mutable (cannot be keys)
• Dictionary keys must be hashable
• TypeError: unhashable type: 'dict'
• Cannot use dictionaries as keys

How it works:
• {{'a': 1}: 'b'} attempts to create dictionary with dict key
• Python tries to hash the dict {'a': 1}
• Dictionaries are mutable (cannot be hashed)
• Raises TypeError
• Cannot use mutable types as keys

Example:
{{'a': 1}: 'b'}                        # TypeError: unhashable type: 'dict'
{{}: 'empty'}                          # TypeError: unhashable type: 'dict'
{tuple({'a': 1}.items()): 'b'}        # {(('a', 1),): 'b'} (works with tuple)

Common uses:
• Understanding key requirements: keys must be hashable
• Converting to tuples: key = tuple(dict.items())
• Key type validation
• Hashable types only

Example: {{'a': 1}: 'b'} raises a TypeError because dictionaries are mutable and unhashable, so they cannot be used as dictionary keys. Use tuples of items instead: {tuple({'a': 1}.items()): 'b'}.
`
  }),
  (_i: number) => ({ 
    q: `What is {None: 'a', True: 'b', False: 'c'}[None]?`, 
    o: ["'a'", "None", "Error", "'b'"], 
    c: 0, 
    e: "None, True, False can be dictionary keys.",
    de: `None, True, and False can be dictionary keys because they are hashable (immutable). {None: 'a', True: 'b', False: 'c'}[None] returns 'a' because None is a valid dictionary key, and accessing [None] looks up the key None in the dictionary, which maps to the value 'a'. None, True, and False are all hashable values (they have fixed identities), so they can be used as dictionary keys alongside other hashable types.

None, True, False as keys:
• {None: 'a', True: 'b', False: 'c'}[None] = 'a'
• None, True, False can be dictionary keys
• They are hashable (immutable)
• Key None maps to value 'a'
• Returns value: 'a'

How it works:
• {None: 'a', True: 'b', False: 'c'} creates dictionary with None/True/False keys
• [None] accesses key None in dictionary
• Finds mapping: None → 'a'
• Returns value: 'a'

Example:
{None: 'a', True: 'b', False: 'c'}[None]  # 'a' (None key)
{None: 'a', True: 'b', False: 'c'}[True]  # 'b' (True key)
{None: 'a', True: 'b', False: 'c'}[False] # 'c' (False key)

Common uses:
• Boolean/None keys: dict = {None: default, True: true_val, False: false_val}
• Special value keys: items = {None: value1, True: value2}
• Dictionary keys with special values
• Hashable value keys

Example: {None: 'a', True: 'b', False: 'c'}[None] returns 'a' because None, True, and False are all hashable and can be used as dictionary keys, and accessing [None] looks up the key None, which maps to the value 'a'.
`
  }),
  (_i: number) => ({ 
    q: `What is {1: 'a', 1.0: 'b'}[1]?`, 
    o: ["'b'", "'a'", "Error", "None"], 
    c: 0, 
    e: "1 and 1.0 are same key (hash equality).",
    de: `Integer 1 and float 1.0 are considered the same key in dictionaries because they hash to the same value. {1: 'a', 1.0: 'b'}[1] returns 'b' because 1 and 1.0 hash to the same value, so they are considered the same key. When you create a dictionary with both 1 and 1.0 as keys, the later value ('b') overwrites the earlier value ('a'), leaving only one key-value pair. When accessing [1], Python treats 1 and 1.0 as the same key, so it returns the value 'b'.

Hash equality - 1 and 1.0:
• {1: 'a', 1.0: 'b'}[1] = 'b'
• 1 and 1.0 hash to same value
• They are considered same key
• Later value ('b') overwrites earlier ('a')
• Returns: 'b'

How it works:
• {1: 'a', 1.0: 'b'} creates dictionary
• 1 and 1.0 hash to same value (same key)
• Later value 'b' overwrites 'a'
• Dictionary becomes {1: 'b'} (or {1.0: 'b'})
• [1] accesses same key, returns 'b'

Example:
{1: 'a', 1.0: 'b'}[1]                 # 'b' (same key)
{1: 'a', 1.0: 'b'}[1.0]               # 'b' (same key)
{2: 'x', 2.0: 'y'}                    # {2: 'y'} (same key)

Common uses:
• Understanding hash equality: 1 == 1.0 (hash same)
• Key equality: same hash = same key
• Numeric key behavior
• Hash-based key equality

Example: {1: 'a', 1.0: 'b'}[1] returns 'b' because 1 and 1.0 hash to the same value, so they are considered the same key in the dictionary, and the later value 'b' overwrites the earlier value 'a'.
`
  }),
  (_i: number) => ({ 
    q: `What is {1: 'a', 1.0: 'b'}?`, 
    o: ["{1: 'b'}", "{1: 'a', 1.0: 'b'}", "Error", "None"], 
    c: 0, 
    e: "1 and 1.0 are same key, later value overwrites.",
    de: `Integer 1 and float 1.0 are considered the same key in dictionaries because they hash to the same value. {1: 'a', 1.0: 'b'} returns {1: 'b'} because 1 and 1.0 hash to the same value, so they are considered the same key. When you create a dictionary with both 1 and 1.0 as keys, the later value ('b') overwrites the earlier value ('a'), leaving only one key-value pair. The dictionary representation shows 1 as the key (or 1.0, depending on which was used last), but both 1 and 1.0 access the same entry.

Hash equality - dictionary creation:
• {1: 'a', 1.0: 'b'} = {1: 'b'}
• 1 and 1.0 hash to same value (same key)
• Later value 'b' overwrites 'a'
• Dictionary has only one pair: {1: 'b'}
• Both 1 and 1.0 access same entry

How it works:
• {1: 'a', 1.0: 'b'} creates dictionary
• First sets 1: 'a'
• Then sets 1.0: 'b' (same key as 1)
• 'b' overwrites 'a'
• Dictionary becomes {1: 'b'} (or {1.0: 'b'})

Example:
{1: 'a', 1.0: 'b'}                    # {1: 'b'} (same key)
{2: 'x', 2.0: 'y'}                    # {2: 'y'} (same key)
{3: 'z', 3.0: 'w'}                    # {3: 'w'} (same key)

Common uses:
• Understanding hash equality: 1 == 1.0 (hash same)
• Key overwriting: later value wins
• Numeric key behavior
• Hash-based key equality

Example: {1: 'a', 1.0: 'b'} returns {1: 'b'} because 1 and 1.0 hash to the same value, so they are considered the same key, and the later value 'b' overwrites the earlier value 'a'.
`
  }),
  (_i: number) => ({ 
    q: `What is d = {}; d[1] = 'a'; d[1.0] = 'b'; d?`, 
    o: ["{1: 'b'}", "{1: 'a', 1.0: 'b'}", "Error", "None"], 
    c: 0, 
    e: "1 and 1.0 are same key, assignment overwrites.",
    de: `Integer 1 and float 1.0 are considered the same key in dictionaries because they hash to the same value. If d = {}, d[1] = 'a', and then d[1.0] = 'b', the dictionary d becomes {1: 'b'} because 1 and 1.0 hash to the same value, so they are considered the same key. When you assign d[1] = 'a', it sets the value to 'a', but when you assign d[1.0] = 'b', it overwrites the same key (since 1 and 1.0 are the same key), leaving only {1: 'b'}.

Hash equality - assignment:
• d = {}; d[1] = 'a'; d[1.0] = 'b'; d = {1: 'b'}
• 1 and 1.0 hash to same value (same key)
• d[1] = 'a' sets value to 'a'
• d[1.0] = 'b' overwrites same key to 'b'
• Dictionary has only one pair: {1: 'b'}

How it works:
• d = {} creates empty dictionary
• d[1] = 'a' sets key 1 to value 'a'
• d[1.0] = 'b' sets key 1.0 to value 'b'
• 1 and 1.0 are same key (same hash)
• 'b' overwrites 'a', d becomes {1: 'b'}

Example:
d = {}
d[1] = 'a'                             # d = {1: 'a'}
d[1.0] = 'b'                           # d = {1: 'b'} (overwrites)
d                                      # {1: 'b'}

Common uses:
• Understanding hash equality: 1 == 1.0 (hash same)
• Key assignment: later assignment wins
• Numeric key behavior
• Hash-based key equality

Example: If d = {}, d[1] = 'a', and then d[1.0] = 'b', the dictionary d becomes {1: 'b'} because 1 and 1.0 hash to the same value, so they are considered the same key, and the assignment d[1.0] = 'b' overwrites the value from d[1] = 'a'.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.pop('a', 'default')?`, 
    o: ["1", "'default'", "Error", "None"], 
    c: 0, 
    e: "pop() returns value if key exists, ignores default.",
    de: `The pop() method returns the actual value if the key exists, even if a default value is provided. {'a': 1, 'b': 2}.pop('a', 'default') returns 1 because pop() finds the key 'a' in the dictionary and returns its actual value (1), ignoring the default value ('default'). The default value is only used when the key doesn't exist - if the key exists, pop() returns the actual value associated with that key.

pop() with existing key:
• {'a': 1, 'b': 2}.pop('a', 'default') = 1
• pop(key, default) returns actual value if key exists
• Default value ignored when key found
• Returns value from dictionary
• Default only used if key missing

How it works:
• pop('a', 'default') called on {'a': 1, 'b': 2}
• Searches for key 'a' in dictionary
• Finds mapping: 'a' → 1
• Returns actual value: 1 (ignores default 'default')
• Dictionary modified: {'b': 2} (pair removed)

Example:
{'a': 1, 'b': 2}.pop('a', 'default')   # 1 (returns actual value)
{'a': 1, 'b': 2}.pop('b', 0)          # 2 (returns actual value)
{'a': 1, 'b': 2}.pop('c', 'default')   # 'default' (key not found)

Common uses:
• Removing pairs: value = dict.pop(key, default)
• Getting and removing: removed = items.pop(key, fallback)
• Safe removal with fallback
• Default handling

Example: {'a': 1, 'b': 2}.pop('a', 'default') returns 1 because pop() finds the key 'a' in the dictionary and returns its actual value (1), ignoring the default value ('default'), which is only used when the key doesn't exist.
`
  }),
  (_i: number) => ({ 
    q: `What is {'a': 1, 'b': 2}.pop('c', 'default')?`, 
    o: ["'default'", "None", "Error", "1"], 
    c: 0, 
    e: "pop() returns default if key doesn't exist.",
    de: `The pop() method returns the default value if the key doesn't exist and a default is provided. {'a': 1, 'b': 2}.pop('c', 'default') returns 'default' because pop() searches for the key 'c' in the dictionary, doesn't find it, and returns the default value ('default') without raising an error. Unlike pop() without a default, this version doesn't raise a KeyError - it just returns the default value. The dictionary remains unchanged because there was no pair to remove.

pop() with missing key:
• {'a': 1, 'b': 2}.pop('c', 'default') = 'default'
• pop(key, default) returns default if key not found
• No error raised (unlike pop() without default)
• Dictionary unchanged (no pair to remove)
• Returns default value

How it works:
• pop('c', 'default') called on {'a': 1, 'b': 2}
• Searches for key 'c' in dictionary
• Finds no match (key doesn't exist)
• Cannot remove non-existent pair
• Returns default value: 'default' (no error)
• Dictionary unchanged: {'a': 1, 'b': 2}

Example:
{'a': 1, 'b': 2}.pop('c', 'default')   # 'default' (not found, returns default)
{'a': 1, 'b': 2}.pop('c', 0)          # 0 (not found, returns default)
{'a': 1, 'b': 2}                      # {'a': 1, 'b': 2} (unchanged)

Common uses:
• Safe removal: value = dict.pop(key, default)
• Default handling: removed = items.pop(key, fallback)
• Error-free removal
• Safe pop with fallback

Example: {'a': 1, 'b': 2}.pop('c', 'default') returns 'default' because pop() searches for the key 'c' in the dictionary, doesn't find it, and returns the default value ('default') without raising an error, leaving the dictionary unchanged.
`
  }),
];

// --- LEVEL 7: DOLPHIN (Functions, Parameters, Return) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level7Patterns = [
  // 1-10: Function Definition and Basics
  (_i: number) => ({ 
    q: `What does def func(x): return x * 2 do?`, 
    o: ["Defines a function", "Calls a function", "Imports a module", "Error"], 
    c: 0, 
    e: "def defines a function.",
    de: `The def keyword defines a function in Python. def func(x): return x * 2 defines a function named func that takes one parameter x and returns x * 2. The def statement creates a function object and assigns it to the name func. This is function definition, not function calling - to call the function, you would use func(5) which would return 10. Functions are defined using def, followed by the function name, parameters in parentheses, a colon, and the function body.

def keyword - function definition:
• def func(x): return x * 2 defines a function
• def is the keyword for function definition
• func is the function name
• (x) is the parameter list
• return x * 2 is the function body
• Creates function object, doesn't execute it

How it works:
• def func(x): creates function definition
• Function name: func
• Parameter: x
• Body: return x * 2
• Function object created and assigned to name func
• To call: func(5) returns 10

Example:
def func(x): return x * 2  # Defines function
func(5)                    # 10 (calls function)
func(3)                    # 6 (calls function)

Common uses:
• Defining functions: def function_name(params): body
• Creating reusable code: def calculate(x): return x * 2
• Function definition
• Code organization

Example: def func(x): return x * 2 defines a function named func that takes parameter x and returns x * 2. This is function definition - the function is created but not executed until called.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): pass?`, 
    o: ["Defines empty function", "Calls function", "Error", "None"], 
    c: 0, 
    e: "Function with no parameters and pass statement.",
    de: `The def keyword with pass defines an empty function. def func(): pass defines a function named func with no parameters and an empty body (pass is a placeholder that does nothing). This creates a valid function that returns None when called. pass is used when you need syntactically valid code but don't want to execute anything - it's commonly used for placeholder functions, empty classes, or code that will be implemented later.

def with pass - empty function:
• def func(): pass defines empty function
• func is function name
• () means no parameters
• pass is placeholder (does nothing)
• Function returns None when called

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: pass (placeholder)
• Function object created
• When called: func() returns None

Example:
def func(): pass          # Defines empty function
func()                    # None (returns None)
def placeholder(): pass   # Placeholder for future code

Common uses:
• Placeholder functions: def func(): pass (to be implemented)
• Empty functions: def stub(): pass
• Syntax requirement: pass needed for empty body
• Function stubs

Example: def func(): pass defines an empty function named func with no parameters. The pass statement is a placeholder that does nothing, making this a valid function that returns None when called.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return?`, 
    o: ["Defines function returning None", "Error", "Defines function returning empty", "None"], 
    c: 0, 
    e: "return without value returns None.",
    de: `A return statement without a value returns None. def func(): return defines a function that explicitly returns None. When you use return without a value, Python returns None. This is equivalent to return None or having no return statement at all - all three result in the function returning None. Explicitly using return without a value can make it clear that the function intentionally returns None.

return without value:
• def func(): return defines function returning None
• return without value returns None
• Equivalent to return None
• Equivalent to no return statement
• Function returns None

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: return (no value)
• When called: func() returns None
• Explicit None return

Example:
def func(): return        # Returns None
func()                    # None
def func(): return None   # Same: None
def func(): pass          # Same: None (no return)

Common uses:
• Explicit None return: def func(): return
• Clear intent: return None explicitly
• Function termination
• None return pattern

Example: def func(): return defines a function that explicitly returns None. The return statement without a value returns None, making it clear that the function intentionally returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return 1, 2?`, 
    o: ["Defines function returning tuple", "Error", "Defines function returning two values", "None"], 
    c: 0, 
    e: "Multiple values in return create tuple.",
    de: `Returning multiple values in Python creates a tuple. def func(): return 1, 2 defines a function that returns a tuple (1, 2). When you write return 1, 2, Python automatically creates a tuple - the comma creates a tuple, not parentheses. This is Python's way of returning multiple values - you can unpack them when calling the function: a, b = func() assigns 1 to a and 2 to b.

Multiple return values:
• def func(): return 1, 2 defines function returning tuple
• return 1, 2 creates tuple (1, 2)
• Comma creates tuple (parentheses optional)
• Returns single tuple object
• Can be unpacked: a, b = func()

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: return 1, 2
• Comma creates tuple: (1, 2)
• When called: func() returns (1, 2)

Example:
def func(): return 1, 2   # Returns (1, 2)
func()                    # (1, 2) (tuple)
a, b = func()            # a = 1, b = 2 (unpacking)

Common uses:
• Returning multiple values: return x, y
• Tuple return: return (1, 2) (same as return 1, 2)
• Multiple value return
• Unpacking return values

Example: def func(): return 1, 2 defines a function that returns a tuple (1, 2). The comma creates a tuple, so return 1, 2 is equivalent to return (1, 2).
`
  }),
  (_i: number) => ({ 
    q: `What happens if a function has no return statement?`, 
    o: ["Returns None", "Error", "Returns 0", "Returns empty string"], 
    c: 0, 
    e: "Functions without return return None.",
    de: `Functions without a return statement automatically return None. If a function has no return statement, when it finishes executing, it implicitly returns None. This is Python's default behavior - every function returns a value, and if no return statement is executed, the function returns None. This is why functions without explicit return values can still be used in expressions - they return None, which is a valid value (though often not useful).

No return statement:
• Function without return returns None
• Implicit None return
• Default behavior in Python
• Every function returns a value
• None is returned if no return executed

How it works:
• Function executes body
• Reaches end of function
• No return statement encountered
• Implicitly returns None
• Function call evaluates to None

Example:
def func(): pass          # No return, returns None
func()                    # None
def func(): print("hi")   # No return, returns None
result = func()           # result = None

Common uses:
• Functions without return: def func(): body (returns None)
• Side-effect functions: def print_data(): print(x) (returns None)
• Implicit None return
• Default return behavior

Example: If a function has no return statement, it automatically returns None when it finishes executing. This is Python's default behavior - every function returns a value, and None is the default.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y): return x + y?`, 
    o: ["Defines function with two parameters", "Calls function", "Error", "None"], 
    c: 0, 
    e: "Function with multiple parameters.",
    de: `Functions can have multiple parameters. def func(x, y): return x + y defines a function named func that takes two parameters x and y and returns their sum. Parameters are listed in the parentheses separated by commas. When you call the function, you provide arguments for each parameter: func(1, 2) passes 1 to x and 2 to y, returning 3. Multiple parameters allow functions to work with multiple inputs.

Multiple parameters:
• def func(x, y): return x + y defines function with two parameters
• x and y are parameters
• Parameters separated by commas
• Function takes two arguments when called
• Returns sum of parameters

How it works:
• def func(x, y): creates function definition
• Function name: func
• Parameters: x, y
• Body: return x + y
• When called: func(1, 2) assigns 1 to x, 2 to y, returns 3

Example:
def func(x, y): return x + y  # Two parameters
func(1, 2)                    # 3 (1 + 2)
func(5, 10)                   # 15 (5 + 10)

Common uses:
• Multiple inputs: def calculate(x, y): return x + y
• Parameter lists: def process(a, b, c): body
• Multiple parameter functions
• Function parameters

Example: def func(x, y): return x + y defines a function with two parameters x and y that returns their sum. When called with func(1, 2), it returns 3.
`
  }),
  (_i: number) => ({ 
    q: `What is func(1, 2) if def func(x, y): return x + y?`, 
    o: ["3", "1", "2", "Error"], 
    c: 0, 
    e: "Function call with positional arguments.",
    de: `Calling a function with positional arguments passes values in order. If def func(x, y): return x + y, then func(1, 2) returns 3 because 1 is passed to the first parameter x and 2 is passed to the second parameter y, so the function returns 1 + 2 = 3. Positional arguments are matched to parameters by position - the first argument goes to the first parameter, the second argument goes to the second parameter, and so on.

Positional arguments:
• func(1, 2) with def func(x, y): return x + y returns 3
• 1 is passed to x (first parameter)
• 2 is passed to y (second parameter)
• Function returns x + y = 1 + 2 = 3
• Arguments matched by position

How it works:
• func(1, 2) calls function func
• First argument 1 assigned to first parameter x
• Second argument 2 assigned to second parameter y
• Function executes: return x + y
• Returns: 1 + 2 = 3

Example:
def func(x, y): return x + y
func(1, 2)                    # 3 (positional: 1→x, 2→y)
func(5, 10)                   # 15 (positional: 5→x, 10→y)

Common uses:
• Calling functions: result = func(arg1, arg2)
• Positional argument passing: func(1, 2, 3)
• Function invocation
• Argument passing

Example: If def func(x, y): return x + y, then func(1, 2) returns 3 because 1 is passed to x and 2 is passed to y (positional arguments), so the function returns 1 + 2 = 3.
`
  }),
  (_i: number) => ({ 
    q: `What is func(x=1, y=2) if def func(x, y): return x + y?`, 
    o: ["3", "1", "2", "Error"], 
    c: 0, 
    e: "Function call with keyword arguments.",
    de: `Calling a function with keyword arguments passes values by parameter name. If def func(x, y): return x + y, then func(x=1, y=2) returns 3 because x=1 explicitly assigns 1 to parameter x and y=2 explicitly assigns 2 to parameter y, so the function returns 1 + 2 = 3. Keyword arguments are matched by parameter name, not position, which makes function calls more readable and allows arguments to be passed in any order.

Keyword arguments:
• func(x=1, y=2) with def func(x, y): return x + y returns 3
• x=1 assigns 1 to parameter x
• y=2 assigns 2 to parameter y
• Function returns x + y = 1 + 2 = 3
• Arguments matched by name

How it works:
• func(x=1, y=2) calls function func
• x=1 assigns 1 to parameter x
• y=2 assigns 2 to parameter y
• Function executes: return x + y
• Returns: 1 + 2 = 3

Example:
def func(x, y): return x + y
func(x=1, y=2)               # 3 (keyword: x=1, y=2)
func(y=2, x=1)               # 3 (same, order doesn't matter)

Common uses:
• Calling functions: result = func(param1=value1, param2=value2)
• Keyword argument passing: func(x=1, y=2)
• Readable function calls
• Named argument passing

Example: If def func(x, y): return x + y, then func(x=1, y=2) returns 3 because x=1 assigns 1 to x and y=2 assigns 2 to y (keyword arguments), so the function returns 1 + 2 = 3.
`
  }),
  (_i: number) => ({ 
    q: `What is func(1, y=2) if def func(x, y): return x + y?`, 
    o: ["3", "1", "2", "Error"], 
    c: 0, 
    e: "Function call with mixed positional and keyword arguments.",
    de: `You can mix positional and keyword arguments in a function call. If def func(x, y): return x + y, then func(1, y=2) returns 3 because 1 is passed positionally to x and y=2 is passed as a keyword argument to y, so the function returns 1 + 2 = 3. Positional arguments must come before keyword arguments - you cannot have a keyword argument followed by a positional argument. This mixing allows flexibility in function calls.

Mixed arguments:
• func(1, y=2) with def func(x, y): return x + y returns 3
• 1 is positional argument (goes to x)
• y=2 is keyword argument (goes to y)
• Function returns x + y = 1 + 2 = 3
• Positional before keyword

How it works:
• func(1, y=2) calls function func
• 1 is positional, assigned to first parameter x
• y=2 is keyword, assigned to parameter y
• Function executes: return x + y
• Returns: 1 + 2 = 3

Example:
def func(x, y): return x + y
func(1, y=2)                 # 3 (mixed: 1→x, y=2)
func(x=1, 2)                 # SyntaxError (keyword before positional not allowed)

Common uses:
• Mixed calls: result = func(1, param2=value)
• Flexible argument passing: func(pos1, keyword=value)
• Positional and keyword mixing
• Function call flexibility

Example: If def func(x, y): return x + y, then func(1, y=2) returns 3 because 1 is passed positionally to x and y=2 is passed as a keyword argument to y, so the function returns 1 + 2 = 3.
`
  }),
  (_i: number) => ({ 
    q: `What is func() if def func(x=1): return x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Function call using default parameter value.",
    de: `Functions with default parameters can be called without providing arguments. If def func(x=1): return x, then func() returns 1 because x has a default value of 1, so when func() is called with no arguments, x uses its default value of 1, and the function returns 1. Default parameters allow functions to be called with fewer arguments - if an argument is not provided, the default value is used. This makes functions more flexible.

Default parameters:
• func() with def func(x=1): return x returns 1
• x has default value 1
• No argument provided for x
• x uses default value: 1
• Function returns 1

How it works:
• func() calls function func
• No argument provided for parameter x
• x has default value 1
• x uses default: x = 1
• Function executes: return x
• Returns: 1

Example:
def func(x=1): return x
func()                      # 1 (uses default x=1)
func(5)                     # 5 (overrides default)

Common uses:
• Optional parameters: def process(data, verbose=False):
• Default values: def calculate(x, y=0): return x + y
• Flexible function calls
• Default parameter functions

Example: If def func(x=1): return x, then func() returns 1 because x has a default value of 1, so when called with no arguments, x uses its default value and the function returns 1.
`
  }),
  
  // 11-20: Default Parameters
  (_i: number) => ({ 
    q: `What is def func(x=1): return x?`, 
    o: ["Defines function with default parameter", "Error", "Defines function with required parameter", "None"], 
    c: 0, 
    e: "Default parameter allows omitting argument.",
    de: `Default parameters allow functions to be called with fewer arguments. def func(x=1): return x defines a function with a default parameter x=1, which means if no argument is provided for x, it will use the value 1. This makes the parameter optional - you can call func() without arguments (uses default 1), or func(5) to override the default. Default parameters are defined using = in the parameter list.

Default parameters:
• def func(x=1): return x defines function with default parameter
• x=1 sets default value to 1
• Parameter x is optional
• Can call func() (uses x=1) or func(5) (uses x=5)
• Default allows omitting argument

How it works:
• def func(x=1): creates function definition
• Function name: func
• Parameter x has default value 1
• If no argument provided, x = 1
• If argument provided, x = argument value

Example:
def func(x=1): return x
func()                    # 1 (uses default x=1)
func(5)                    # 5 (overrides default)

Common uses:
• Optional parameters: def process(data, verbose=False):
• Default values: def calculate(x, y=0): return x + y
• Flexible function calls
• Default parameter functions

Example: def func(x=1): return x defines a function with a default parameter x=1, which means if called without arguments, x uses its default value of 1.
`
  }),
  (_i: number) => ({ 
    q: `What is func(2) if def func(x=1): return x?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Passing argument overrides default.",
    de: `Passing an argument to a function with a default parameter overrides the default. If def func(x=1): return x, then func(2) returns 2 because the argument 2 is passed to x, overriding the default value of 1. The default value is only used when no argument is provided - if an argument is provided, it takes precedence over the default.

Argument overrides default:
• func(2) with def func(x=1): return x returns 2
• Argument 2 passed to parameter x
• Overrides default value 1
• Function returns 2 (not default 1)
• Default only used if no argument provided

How it works:
• func(2) calls function func
• Argument 2 provided for parameter x
• x uses argument value 2 (not default 1)
• Function executes: return x
• Returns: 2

Example:
def func(x=1): return x
func(2)                    # 2 (overrides default x=1)
func(5)                    # 5 (overrides default x=1)
func()                      # 1 (uses default x=1)

Common uses:
• Overriding defaults: func(value) (overrides default)
• Flexible calls: func() or func(value)
• Argument precedence
• Default parameter behavior

Example: If def func(x=1): return x, then func(2) returns 2 because the argument 2 overrides the default value of 1, so x = 2 and the function returns 2.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y=2): return x + y?`, 
    o: ["Defines function with required and default parameter", "Error", "Defines function with two defaults", "None"], 
    c: 0, 
    e: "Required parameters must come before defaults.",
    de: `Required parameters must come before default parameters in the function definition. def func(x, y=2): return x + y defines a function with a required parameter x and a default parameter y=2. This is valid because the required parameter x comes before the default parameter y. You can call it with func(1) (uses default y=2) or func(1, 3) (overrides default y=2). This ordering is required by Python's syntax.

Required before default:
• def func(x, y=2): return x + y defines function correctly
• x is required parameter (no default)
• y is default parameter (y=2)
• Required parameters must come first
• Valid: required before default

How it works:
• def func(x, y=2): creates function definition
• Function name: func
• Parameter x is required (no default)
• Parameter y has default value 2
• Required parameter x comes before default parameter y

Example:
def func(x, y=2): return x + y
func(1)                    # 3 (uses default y=2: 1 + 2)
func(1, 3)                 # 4 (overrides default: 1 + 3)

Common uses:
• Mixed parameters: def process(data, verbose=False):
• Required and optional: def calculate(x, y=0): return x + y
• Parameter ordering
• Required before default

Example: def func(x, y=2): return x + y defines a function with a required parameter x and a default parameter y=2. The required parameter x comes before the default parameter y, which is correct.
`
  }),
  (_i: number) => ({ 
    q: `What is func(1) if def func(x, y=2): return x + y?`, 
    o: ["3", "1", "Error", "None"], 
    c: 0, 
    e: "Calling with one arg uses default for second.",
    de: `When calling a function with required and default parameters, you can omit arguments for default parameters. If def func(x, y=2): return x + y, then func(1) returns 3 because 1 is passed to the required parameter x, and y uses its default value of 2, so the function returns 1 + 2 = 3. You must provide arguments for all required parameters, but you can omit arguments for default parameters.

Using default for second parameter:
• func(1) with def func(x, y=2): return x + y returns 3
• 1 is passed to required parameter x
• y uses default value 2 (no argument provided)
• Function returns x + y = 1 + 2 = 3
• Default value used for y

How it works:
• func(1) calls function func
• Argument 1 provided for required parameter x
• No argument provided for default parameter y
• y uses default value: y = 2
• Function executes: return x + y
• Returns: 1 + 2 = 3

Example:
def func(x, y=2): return x + y
func(1)                    # 3 (uses default y=2: 1 + 2)
func(1, 5)                 # 6 (overrides default: 1 + 5)

Common uses:
• Omitting defaults: func(required) (uses defaults)
• Optional parameters: func(data) (uses defaults)
• Default parameter usage
• Flexible function calls

Example: If def func(x, y=2): return x + y, then func(1) returns 3 because 1 is passed to x and y uses its default value of 2, so the function returns 1 + 2 = 3.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x=1, y): return x + y?`, 
    o: ["SyntaxError", "Valid function", "Error", "None"], 
    c: 0, 
    e: "Default parameters must come after non-defaults.",
    de: `Default parameters must come after non-default parameters in the function definition. def func(x=1, y): return x + y raises a SyntaxError because x has a default value but y doesn't, and default parameters must come after non-default parameters. Python requires this ordering - required parameters (without defaults) must come first, followed by default parameters. This prevents ambiguity about which parameters get which arguments.

Default after required:
• def func(x=1, y): return x + y raises SyntaxError
• x has default value (x=1)
• y is required (no default)
• Default parameters must come after required
• SyntaxError: non-default argument follows default argument

How it works:
• def func(x=1, y): attempts to define function
• x has default value 1
• y is required (no default)
• Required parameter y comes after default parameter x
• Raises SyntaxError (invalid ordering)

Example:
def func(x=1, y): return x + y  # SyntaxError
def func(y, x=1): return x + y  # Valid (required before default)

Common uses:
• Understanding syntax: required parameters must come first
• Parameter ordering: required, then defaults
• Syntax error avoidance
• Function definition rules

Example: def func(x=1, y): return x + y raises a SyntaxError because default parameters must come after non-default parameters - required parameter y must come before default parameter x.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x=[]): x.append(1); return x?`, 
    o: ["Defines function with mutable default (problematic)", "Error", "Defines function with immutable default", "None"], 
    c: 0, 
    e: "Mutable defaults are shared across calls (common pitfall).",
    de: `Using a mutable object (like a list) as a default parameter is problematic because the default value is created once and shared across all function calls. def func(x=[]): x.append(1); return x defines a function with a mutable default parameter, which is a common pitfall in Python. The list [] is created once when the function is defined, and the same list object is reused for all calls. This means modifications to the list persist across calls, which is usually not what you want.

Mutable default parameter:
• def func(x=[]): x.append(1); return x defines function with mutable default
• Default value [] is created once (when function defined)
• Same list object reused for all calls
• Modifications persist across calls
• Common pitfall (usually not desired)

How it works:
• def func(x=[]): creates function definition
• Default value [] is created once (when function defined)
• Same list object shared across calls
• First call: x is [], appends 1, returns [1]
• Second call: x is [1] (same list!), appends 1, returns [1, 1]

Example:
def func(x=[]): x.append(1); return x
func()                      # [1] (first call)
func()                      # [1, 1] (second call, list persists!)
func()                      # [1, 1, 1] (third call, list grows!)

Common uses:
• Understanding pitfall: mutable defaults are shared
• Avoiding mutable defaults: use None instead
• Common Python mistake
• Default parameter behavior

Example: def func(x=[]): x.append(1); return x defines a function with a mutable default parameter. The list [] is created once and shared across all calls, so modifications persist, which is usually not desired.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x=None): x = x or []; x.append(1); return x?`, 
    o: ["Defines function with safe mutable default pattern", "Error", "Defines function with mutable default", "None"], 
    c: 0, 
    e: "Common pattern to avoid mutable default issues.",
    de: `Using None as a default and creating a new mutable object inside the function is a common pattern to avoid mutable default issues. def func(x=None): x = x or []; x.append(1); return x defines a function that safely handles mutable defaults. If x is None (default), x = x or [] creates a new list, ensuring each call gets its own list. This pattern prevents the shared mutable default problem - each call gets a fresh list instead of sharing one.

Safe mutable default pattern:
• def func(x=None): x = x or []; x.append(1); return x uses safe pattern
• Default is None (immutable)
• x = x or [] creates new list if x is None
• Each call gets its own list (not shared)
• Avoids mutable default pitfall

How it works:
• def func(x=None): creates function definition
• Default value None (immutable)
• x = x or [] creates new list if x is None
• First call: x is None, creates new [], appends 1, returns [1]
• Second call: x is None, creates new [], appends 1, returns [1] (fresh list!)

Example:
def func(x=None): x = x or []; x.append(1); return x
func()                      # [1] (first call, new list)
func()                      # [1] (second call, new list, not [1, 1]!)
func([10])                  # [10, 1] (uses provided list)

Common uses:
• Safe mutable defaults: def func(x=None): x = x or []
• Avoiding shared state: use None as default
• Common Python pattern
• Mutable default workaround

Example: def func(x=None): x = x or []; x.append(1); return x defines a function that safely handles mutable defaults by using None as the default and creating a new list inside the function if needed, avoiding the shared mutable default problem.
`
  }),
  (_i: number) => ({ 
    q: `What is func() then func() if def func(x=[]): x.append(1); return x?`, 
    o: ["[1] then [1, 1]", "[1] then [1]", "Error", "None"], 
    c: 0, 
    e: "Mutable default is shared, accumulates across calls.",
    de: `Mutable default parameters accumulate changes across function calls because the same object is reused. If def func(x=[]): x.append(1); return x, then func(); func() causes the second call to return [1, 1] because the default list [] is created once and shared across all calls. The first call appends 1, making the list [1], and the second call starts with [1] (same shared list) and appends 1 again, resulting in [1, 1].

Mutable default - accumulation:
• func(); func() with def func(x=[]): x.append(1); return x returns [1, 1]
• Default list [] is shared across calls
• First call: x is [], appends 1, returns [1]
• Second call: x is [1] (same list!), appends 1, returns [1, 1]
• List accumulates changes

How it works:
• def func(x=[]): creates function definition
• Default value [] is created once (when function defined)
• Same list object shared across calls
• First call: x is [], appends 1, returns [1]
• Second call: x is [1] (same list!), appends 1, returns [1, 1]

Example:
def func(x=[]): x.append(1); return x
func()                      # [1] (first call)
func()                      # [1, 1] (second call, list accumulated!)

Common uses:
• Understanding mutable defaults: accumulate changes
• Demonstrating pitfall: shared state
• Mutable default behavior
• Common Python mistake

Example: If def func(x=[]): x.append(1); return x, then func(); func() causes the second call to return [1, 1] because the default list [] is shared across calls, so the first call modifies it to [1], and the second call continues with [1] and appends 1 again.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x=1, y=2, z=3): return x, y, z?`, 
    o: ["Defines function with multiple defaults", "Error", "Defines function with required params", "None"], 
    c: 0, 
    e: "Function can have multiple default parameters.",
    de: `Functions can have multiple default parameters. def func(x=1, y=2, z=3): return x, y, z defines a function with three default parameters, each with its own default value. All parameters have defaults, so you can call the function with 0, 1, 2, or 3 arguments. If you provide arguments, they are assigned to parameters in order, starting with the first parameter. This allows flexible function calls with different numbers of arguments.

Multiple default parameters:
• def func(x=1, y=2, z=3): return x, y, z defines function with multiple defaults
• All three parameters have default values
• x defaults to 1, y defaults to 2, z defaults to 3
• Can call with 0, 1, 2, or 3 arguments
• Arguments assigned in order

How it works:
• def func(x=1, y=2, z=3): creates function definition
• Function name: func
• All parameters have defaults: x=1, y=2, z=3
• Arguments assigned to parameters in order
• Missing arguments use defaults

Example:
def func(x=1, y=2, z=3): return x, y, z
func()                      # (1, 2, 3) (all defaults)
func(10)                    # (10, 2, 3) (only x overridden)
func(10, 20)                # (10, 20, 3) (x and y overridden)

Common uses:
• Multiple optional parameters: def process(data, verbose=False, output=None):
• Flexible functions: def create(width=100, height=100, color='blue'):
• Multiple default parameters
• Flexible function calls

Example: def func(x=1, y=2, z=3): return x, y, z defines a function with multiple default parameters. All parameters have defaults, so you can call it with 0, 1, 2, or 3 arguments.
`
  }),
  (_i: number) => ({ 
    q: `What is func(10) if def func(x=1, y=2, z=3): return x, y, z?`, 
    o: ["(10, 2, 3)", "(10, 1, 2)", "Error", "None"], 
    c: 0, 
    e: "First argument goes to first parameter, rest use defaults.",
    de: `When calling a function with multiple default parameters, arguments are assigned to parameters in order, starting with the first parameter. If def func(x=1, y=2, z=3): return x, y, z, then func(10) returns (10, 2, 3) because the argument 10 is assigned to the first parameter x, and y and z use their default values of 2 and 3. Arguments are matched to parameters positionally, from left to right.

First argument to first parameter:
• func(10) with def func(x=1, y=2, z=3): return x, y, z returns (10, 2, 3)
• Argument 10 assigned to first parameter x
• y uses default value 2
• z uses default value 3
• Arguments assigned in order

How it works:
• func(10) calls function func
• Argument 10 provided
• Assigned to first parameter x: x = 10
• y uses default: y = 2
• z uses default: z = 3
• Function executes: return x, y, z
• Returns: (10, 2, 3)

Example:
def func(x=1, y=2, z=3): return x, y, z
func(10)                    # (10, 2, 3) (x=10, y=2, z=3)
func(10, 20)                # (10, 20, 3) (x=10, y=20, z=3)
func(10, 20, 30)            # (10, 20, 30) (all overridden)

Common uses:
• Positional argument assignment: func(arg1) (goes to first param)
• Flexible calls: func(value) or func(value1, value2)
• Argument matching
• Default parameter behavior

Example: If def func(x=1, y=2, z=3): return x, y, z, then func(10) returns (10, 2, 3) because 10 is assigned to x (first parameter), and y and z use their default values of 2 and 3.
`
  }),
  
  // 21-30: *args and **kwargs
  (_i: number) => ({ 
    q: `What is def func(*args): return args?`, 
    o: ["Defines function accepting variable positional arguments", "Error", "Defines function with required args", "None"], 
    c: 0, 
    e: "*args collects positional arguments into tuple.",
    de: `The *args syntax allows a function to accept a variable number of positional arguments. def func(*args): return args defines a function that collects all positional arguments into a tuple named args. The * before args tells Python to collect all extra positional arguments into a tuple. This allows the function to be called with any number of arguments, which are then accessible as a tuple inside the function.

*args parameter:
• def func(*args): return args defines function with *args
• *args collects variable positional arguments
• Collects all extra positional arguments into tuple
• Function can accept any number of arguments
• Arguments accessible as tuple: args

How it works:
• def func(*args): creates function definition
• Function name: func
• *args collects all positional arguments into tuple
• When called: func(1, 2, 3), args = (1, 2, 3)
• Returns tuple of arguments

Example:
def func(*args): return args
func(1, 2, 3)              # (1, 2, 3) (all arguments collected)
func(1)                     # (1,) (single argument)
func()                      # () (no arguments, empty tuple)

Common uses:
• Variable arguments: def process(*items): for item in items:
• Flexible functions: def sum_values(*numbers): return sum(numbers)
• Variable positional arguments
• Function flexibility

Example: def func(*args): return args defines a function that collects all positional arguments into a tuple named args, allowing the function to accept any number of arguments.
`
  }),
  (_i: number) => ({ 
    q: `What is func(1, 2, 3) if def func(*args): return args?`, 
    o: ["(1, 2, 3)", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "*args collects arguments into tuple.",
    de: `When calling a function with *args, all positional arguments are collected into a tuple. If def func(*args): return args, then func(1, 2, 3) returns (1, 2, 3) because *args collects all positional arguments (1, 2, 3) into a tuple named args. The function can accept any number of arguments, and they are all collected into the args tuple.

*args collection:
• func(1, 2, 3) with def func(*args): return args returns (1, 2, 3)
• Arguments 1, 2, 3 are positional
• *args collects all positional arguments into tuple
• args = (1, 2, 3) inside function
• Returns tuple: (1, 2, 3)

How it works:
• func(1, 2, 3) calls function func
• Arguments 1, 2, 3 are positional
• *args collects all arguments: args = (1, 2, 3)
• Function executes: return args
• Returns: (1, 2, 3)

Example:
def func(*args): return args
func(1, 2, 3)              # (1, 2, 3) (tuple of arguments)
func(1, 2, 3, 4, 5)        # (1, 2, 3, 4, 5) (tuple of arguments)
func('a', 'b')              # ('a', 'b') (tuple of arguments)

Common uses:
• Collecting arguments: def sum_values(*numbers): return sum(numbers)
• Variable arguments: def process(*items): for item in items:
• Flexible function calls
• Tuple collection

Example: If def func(*args): return args, then func(1, 2, 3) returns (1, 2, 3) because *args collects all positional arguments into a tuple named args.
`
  }),
  (_i: number) => ({ 
    q: `What is func() if def func(*args): return args?`, 
    o: ["()", "[]", "Error", "None"], 
    c: 0, 
    e: "*args is empty tuple if no arguments passed.",
    de: `When calling a function with *args but no arguments, args becomes an empty tuple. If def func(*args): return args, then func() returns () because *args collects positional arguments, and when no arguments are provided, it collects into an empty tuple. This is different from an empty list - *args always creates a tuple, even if it's empty.

*args with no arguments:
• func() with def func(*args): return args returns ()
• No arguments provided
• *args collects into empty tuple
• args = () inside function
• Returns empty tuple: ()

How it works:
• func() calls function func
• No arguments provided
• *args collects into empty tuple: args = ()
• Function executes: return args
• Returns: () (empty tuple)

Example:
def func(*args): return args
func()                      # () (empty tuple)
func(1)                     # (1,) (single-element tuple)
func(1, 2)                  # (1, 2) (tuple)

Common uses:
• Handling no arguments: if not args: return default
• Empty tuple check: if len(args) == 0:
• Variable argument handling
• Tuple collection

Example: If def func(*args): return args, then func() returns () because *args collects positional arguments into a tuple, and when no arguments are provided, it creates an empty tuple.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, *args): return x, args?`, 
    o: ["Defines function with required param and *args", "Error", "Defines function with only *args", "None"], 
    c: 0, 
    e: "Required parameters can come before *args.",
    de: `Required parameters can come before *args in a function definition. def func(x, *args): return x, args defines a function with a required parameter x followed by *args. The required parameter x gets the first argument, and *args collects all remaining positional arguments into a tuple. This allows functions to have both required parameters and variable positional arguments.

Required parameter before *args:
• def func(x, *args): return x, args defines function correctly
• x is required parameter (must be provided)
• *args collects remaining positional arguments
• Required parameters must come before *args
• Valid: required before *args

How it works:
• def func(x, *args): creates function definition
• Function name: func
• Parameter x is required (no default)
• *args collects remaining positional arguments
• Required parameter x comes before *args

Example:
def func(x, *args): return x, args
func(1, 2, 3)              # (1, (2, 3)) (x=1, args=(2, 3))
func(1)                     # (1, ()) (x=1, args=())
func(1, 2)                  # (1, (2,)) (x=1, args=(2,))

Common uses:
• Mixed parameters: def process(first, *rest): process(first); process(*rest)
• Required and variable: def calculate(base, *values): return base + sum(values)
• Parameter ordering
• Required before *args

Example: def func(x, *args): return x, args defines a function with a required parameter x that must come before *args, allowing the function to have both required and variable positional arguments.
`
  }),
  (_i: number) => ({ 
    q: `What is func(1, 2, 3) if def func(x, *args): return x, args?`, 
    o: ["(1, (2, 3))", "(1, 2, 3)", "Error", "None"], 
    c: 0, 
    e: "First arg goes to x, rest to *args.",
    de: `When calling a function with a required parameter and *args, the first argument goes to the required parameter and the rest go to *args. If def func(x, *args): return x, args, then func(1, 2, 3) returns (1, (2, 3)) because 1 is assigned to x (the required parameter), and 2, 3 are collected into *args as a tuple (2, 3). The function returns a tuple containing x and args.

Argument distribution:
• func(1, 2, 3) with def func(x, *args): return x, args returns (1, (2, 3))
• First argument 1 goes to required parameter x
• Remaining arguments 2, 3 go to *args
• args = (2, 3) (tuple)
• Returns tuple: (x, args) = (1, (2, 3))

How it works:
• func(1, 2, 3) calls function func
• First argument 1 assigned to required parameter x
• Remaining arguments 2, 3 collected into *args
• args = (2, 3) (tuple)
• Function executes: return x, args
• Returns: (1, (2, 3))

Example:
def func(x, *args): return x, args
func(1, 2, 3)              # (1, (2, 3)) (x=1, args=(2, 3))
func(10, 20, 30, 40)       # (10, (20, 30, 40)) (x=10, args=(20, 30, 40))
func(5)                     # (5, ()) (x=5, args=())

Common uses:
• Separating first from rest: def process(first, *rest): process(first); process(*rest)
• Required and variable: def calculate(base, *values): return base + sum(values)
• Argument distribution
• Parameter assignment

Example: If def func(x, *args): return x, args, then func(1, 2, 3) returns (1, (2, 3)) because 1 is assigned to x and 2, 3 are collected into *args as a tuple.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(**kwargs): return kwargs?`, 
    o: ["Defines function accepting variable keyword arguments", "Error", "Defines function with required kwargs", "None"], 
    c: 0, 
    e: "**kwargs collects keyword arguments into dict.",
    de: `The **kwargs syntax allows a function to accept a variable number of keyword arguments. def func(**kwargs): return kwargs defines a function that collects all keyword arguments into a dictionary named kwargs. The ** before kwargs tells Python to collect all extra keyword arguments into a dictionary. This allows the function to be called with any number of keyword arguments, which are then accessible as a dictionary inside the function.

**kwargs parameter:
• def func(**kwargs): return kwargs defines function with **kwargs
• **kwargs collects variable keyword arguments
• Collects all extra keyword arguments into dictionary
• Function can accept any number of keyword arguments
• Arguments accessible as dictionary: kwargs

How it works:
• def func(**kwargs): creates function definition
• Function name: func
• **kwargs collects all keyword arguments into dictionary
• When called: func(a=1, b=2), kwargs = {'a': 1, 'b': 2}
• Returns dictionary of arguments

Example:
def func(**kwargs): return kwargs
func(a=1, b=2)             # {'a': 1, 'b': 2} (all keyword args collected)
func(x=10, y=20)           # {'x': 10, 'y': 20} (all keyword args collected)
func()                      # {} (no keyword args, empty dict)

Common uses:
• Variable keyword arguments: def process(**options): use options
• Flexible functions: def create(**attributes): return object(**attributes)
• Variable keyword arguments
• Dictionary collection

Example: def func(**kwargs): return kwargs defines a function that collects all keyword arguments into a dictionary named kwargs, allowing the function to accept any number of keyword arguments.
`
  }),
  (_i: number) => ({ 
    q: `What is func(a=1, b=2) if def func(**kwargs): return kwargs?`, 
    o: ["{'a': 1, 'b': 2}", "(1, 2)", "Error", "None"], 
    c: 0, 
    e: "**kwargs collects keyword args into dictionary.",
    de: `When calling a function with **kwargs, all keyword arguments are collected into a dictionary. If def func(**kwargs): return kwargs, then func(a=1, b=2) returns {'a': 1, 'b': 2} because **kwargs collects all keyword arguments (a=1, b=2) into a dictionary named kwargs. The function can accept any number of keyword arguments, and they are all collected into the kwargs dictionary.

**kwargs collection:
• func(a=1, b=2) with def func(**kwargs): return kwargs returns {'a': 1, 'b': 2}
• Arguments a=1, b=2 are keyword arguments
• **kwargs collects all keyword arguments into dictionary
• kwargs = {'a': 1, 'b': 2} inside function
• Returns dictionary: {'a': 1, 'b': 2}

How it works:
• func(a=1, b=2) calls function func
• Arguments a=1, b=2 are keyword arguments
• **kwargs collects all keyword arguments: kwargs = {'a': 1, 'b': 2}
• Function executes: return kwargs
• Returns: {'a': 1, 'b': 2}

Example:
def func(**kwargs): return kwargs
func(a=1, b=2)             # {'a': 1, 'b': 2} (dictionary of keyword args)
func(x=10, y=20, z=30)     # {'x': 10, 'y': 20, 'z': 30} (dictionary)
func()                      # {} (no keyword args, empty dict)

Common uses:
• Collecting keyword args: def process(**options): use options['key']
• Variable keyword arguments: def create(**attributes): return object(**attributes)
• Dictionary collection
• Flexible function calls

Example: If def func(**kwargs): return kwargs, then func(a=1, b=2) returns {'a': 1, 'b': 2} because **kwargs collects all keyword arguments into a dictionary named kwargs.
`
  }),
  (_i: number) => ({ 
    q: `What is func() if def func(**kwargs): return kwargs?`, 
    o: ["{}", "()", "Error", "None"], 
    c: 0, 
    e: "**kwargs is empty dict if no keyword arguments passed.",
    de: `When calling a function with **kwargs but no keyword arguments, kwargs becomes an empty dictionary. If def func(**kwargs): return kwargs, then func() returns {} because **kwargs collects keyword arguments, and when no keyword arguments are provided, it collects into an empty dictionary. This is different from an empty tuple - **kwargs always creates a dictionary, even if it's empty.

**kwargs with no arguments:
• func() with def func(**kwargs): return kwargs returns {}
• No keyword arguments provided
• **kwargs collects into empty dictionary
• kwargs = {} inside function
• Returns empty dictionary: {}

How it works:
• func() calls function func
• No keyword arguments provided
• **kwargs collects into empty dictionary: kwargs = {}
• Function executes: return kwargs
• Returns: {} (empty dictionary)

Example:
def func(**kwargs): return kwargs
func()                      # {} (empty dictionary)
func(a=1)                   # {'a': 1} (single-key dictionary)
func(a=1, b=2)              # {'a': 1, 'b': 2} (dictionary)

Common uses:
• Handling no keyword args: if not kwargs: return default
• Empty dictionary check: if len(kwargs) == 0:
• Variable keyword argument handling
• Dictionary collection

Example: If def func(**kwargs): return kwargs, then func() returns {} because **kwargs collects keyword arguments into a dictionary, and when no keyword arguments are provided, it creates an empty dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, *args, **kwargs): return x, args, kwargs?`, 
    o: ["Defines function with all parameter types", "Error", "Defines function with only *args", "None"], 
    c: 0, 
    e: "Function can have required, *args, and **kwargs.",
    de: `Functions can have all parameter types together: required parameters, *args, and **kwargs. def func(x, *args, **kwargs): return x, args, kwargs defines a function with a required parameter x, variable positional arguments *args, and variable keyword arguments **kwargs. The order is important: required parameters must come first, followed by *args, followed by **kwargs. This allows maximum flexibility in function calls.

All parameter types:
• def func(x, *args, **kwargs): return x, args, kwargs defines function with all types
• x is required parameter
• *args collects remaining positional arguments into tuple
• **kwargs collects keyword arguments into dictionary
• Order: required, *args, **kwargs
• Maximum flexibility

How it works:
• def func(x, *args, **kwargs): creates function definition
• Function name: func
• Parameter x is required (no default)
• *args collects remaining positional arguments
• **kwargs collects keyword arguments
• Order: required, *args, **kwargs

Example:
def func(x, *args, **kwargs): return x, args, kwargs
func(1, 2, 3, a=4)         # (1, (2, 3), {'a': 4}) (all types)
func(1, a=2)                # (1, (), {'a': 2}) (required + kwargs)
func(1, 2, a=3)             # (1, (2,), {'a': 3}) (all types)

Common uses:
• Maximum flexibility: def process(required, *args, **kwargs): handle all
• Wrapper functions: def wrapper(func, *args, **kwargs): return func(*args, **kwargs)
• All parameter types
• Function flexibility

Example: def func(x, *args, **kwargs): return x, args, kwargs defines a function with all parameter types, allowing maximum flexibility with required, variable positional, and variable keyword arguments.
`
  }),
  (_i: number) => ({ 
    q: `What is func(1, 2, 3, a=4) if def func(x, *args, **kwargs): return x, args, kwargs?`, 
    o: ["(1, (2, 3), {'a': 4})", "(1, 2, 3, {'a': 4})", "Error", "None"], 
    c: 0, 
    e: "Arguments distributed: first to x, rest to *args, keywords to **kwargs.",
    de: `When calling a function with all parameter types, arguments are distributed appropriately. If def func(x, *args, **kwargs): return x, args, kwargs, then func(1, 2, 3, a=4) returns (1, (2, 3), {'a': 4}) because 1 is assigned to x (the required parameter), 2 and 3 are collected into *args as (2, 3), and a=4 is collected into **kwargs as {'a': 4}. Positional arguments go to required parameters and *args, keyword arguments go to **kwargs.

Argument distribution:
• func(1, 2, 3, a=4) with def func(x, *args, **kwargs): return x, args, kwargs returns (1, (2, 3), {'a': 4})
• First argument 1 goes to required parameter x
• Remaining positional arguments 2, 3 go to *args
• Keyword argument a=4 goes to **kwargs
• Returns tuple: (x, args, kwargs) = (1, (2, 3), {'a': 4})

How it works:
• func(1, 2, 3, a=4) calls function func
• First argument 1 assigned to required parameter x
• Remaining positional arguments 2, 3 collected into *args: args = (2, 3)
• Keyword argument a=4 collected into **kwargs: kwargs = {'a': 4}
• Function executes: return x, args, kwargs
• Returns: (1, (2, 3), {'a': 4})

Example:
def func(x, *args, **kwargs): return x, args, kwargs
func(1, 2, 3, a=4)         # (1, (2, 3), {'a': 4})
func(10, 20, x=30)          # TypeError (x already assigned positionally!)
func(10, 20, y=30)          # (10, (20,), {'y': 30})

Common uses:
• Argument distribution: def process(required, *args, **kwargs): distribute
• Wrapper functions: def wrapper(func, *args, **kwargs): return func(*args, **kwargs)
• Flexible argument handling
• Parameter assignment

Example: If def func(x, *args, **kwargs): return x, args, kwargs, then func(1, 2, 3, a=4) returns (1, (2, 3), {'a': 4}) because 1 goes to x, 2 and 3 go to *args, and a=4 goes to **kwargs.
`
  }),
  
  // 31-40: Lambda Functions
  (_i: number) => ({ 
    q: `What is lambda x: x * 2?`, 
    o: ["Anonymous function", "Named function", "Error", "Variable"], 
    c: 0, 
    e: "lambda creates anonymous function.",
    de: `Lambda creates an anonymous function (a function without a name). lambda x: x * 2 creates an anonymous function that takes parameter x and returns x * 2. Lambda functions are concise one-line functions defined using the lambda keyword, followed by parameters (x), a colon (:), and an expression (x * 2). Lambda functions can be used wherever function objects are required, but they're limited to a single expression and cannot contain statements.

Lambda function:
• lambda x: x * 2 creates anonymous function
• lambda keyword creates function
• x is parameter
• x * 2 is expression (returned)
• Function has no name (anonymous)
• Single expression only

How it works:
• lambda x: x * 2 creates function object
• Function takes parameter x
• Returns x * 2 (expression evaluated)
• Function object created but not called
• Can be assigned: f = lambda x: x * 2

Example:
lambda x: x * 2              # Anonymous function object
(lambda x: x * 2)(5)         # 10 (called with 5)
f = lambda x: x * 2; f(5)    # 10 (assigned then called)

Common uses:
• Anonymous functions: lambda x: x * 2
• Callbacks: map(lambda x: x * 2, [1, 2, 3])
• Short functions: sorted(items, key=lambda x: x[1])
• Lambda functions
• One-line functions

Example: lambda x: x * 2 creates an anonymous function that takes parameter x and returns x * 2. Lambda functions are concise one-line functions without names.
`
  }),
  (_i: number) => ({ 
    q: `What is (lambda x: x * 2)(5)?`, 
    o: ["10", "5", "Error", "None"], 
    c: 0, 
    e: "Lambda function call with argument.",
    de: `Lambda functions can be called immediately by placing arguments in parentheses after the lambda expression. (lambda x: x * 2)(5) returns 10 because the lambda function lambda x: x * 2 is defined and immediately called with argument 5. The lambda function takes 5 as x, evaluates x * 2 (5 * 2), and returns 10. This is called an immediately invoked function expression (IIFE) pattern, though less common in Python than in JavaScript.

Lambda function call:
• (lambda x: x * 2)(5) returns 10
• Lambda function created: lambda x: x * 2
• Immediately called with argument: (5)
• x = 5, evaluates x * 2 = 5 * 2 = 10
• Returns 10

How it works:
• (lambda x: x * 2)(5) creates and calls function
• Lambda function defined: lambda x: x * 2
• Argument 5 passed to parameter x
• Expression evaluated: x * 2 = 5 * 2 = 10
• Returns 10

Example:
(lambda x: x * 2)(5)         # 10 (immediately called)
(lambda x: x ** 2)(4)        # 16 (immediately called)
(lambda x: x + 1)(10)        # 11 (immediately called)

Common uses:
• Immediate invocation: (lambda x: f(x))(value)
• One-time use: (lambda x: x * 2)(5)
• Lambda calls
• Anonymous function invocation

Example: (lambda x: x * 2)(5) returns 10 because the lambda function lambda x: x * 2 is immediately called with argument 5, so x = 5 and it returns 5 * 2 = 10.
`
  }),
  (_i: number) => ({ 
    q: `What is lambda: 42?`, 
    o: ["Anonymous function with no parameters", "Error", "Variable", "None"], 
    c: 0, 
    e: "Lambda can have no parameters.",
    de: `Lambda functions can have no parameters. lambda: 42 creates an anonymous function with no parameters that returns 42. When a lambda function has no parameters, you just use lambda followed by a colon (:) and the expression. This is useful for creating constant functions or functions that don't need input parameters. To call it, you use empty parentheses: (lambda: 42)().

Lambda with no parameters:
• lambda: 42 creates anonymous function with no parameters
• lambda keyword creates function
• No parameters (empty before colon)
• 42 is expression (returned)
• Function always returns 42

How it works:
• lambda: 42 creates function object
• Function takes no parameters
• Always returns 42 (expression evaluated)
• Function object created but not called
• Can be called: (lambda: 42)()

Example:
lambda: 42                   # Anonymous function with no params
(lambda: 42)()               # 42 (called with no args)
f = lambda: 42; f()          # 42 (assigned then called)

Common uses:
• Constant functions: lambda: default_value
• No-parameter functions: lambda: get_current_time()
• Lambda without parameters
• Constant function pattern

Example: lambda: 42 creates an anonymous function with no parameters that always returns 42. Lambda functions can have zero or more parameters.
`
  }),
  (_i: number) => ({ 
    q: `What is (lambda: 42)()?`, 
    o: ["42", "Error", "None", "0"], 
    c: 0, 
    e: "Lambda with no parameters called with empty parentheses.",
    de: `Lambda functions with no parameters are called with empty parentheses. (lambda: 42)() returns 42 because the lambda function lambda: 42 is immediately called with no arguments (empty parentheses ()). The lambda function has no parameters, so it doesn't expect any arguments when called. It simply evaluates the expression 42 and returns it.

Lambda call with no parameters:
• (lambda: 42)() returns 42
• Lambda function created: lambda: 42
• Immediately called with no arguments: ()
• Expression evaluated: 42
• Returns 42

How it works:
• (lambda: 42)() creates and calls function
• Lambda function defined: lambda: 42
• No arguments provided (empty parentheses)
• Expression evaluated: 42
• Returns 42

Example:
(lambda: 42)()               # 42 (called with no args)
(lambda: 'hello')()          # 'hello' (called with no args)
(lambda: [1, 2, 3])()        # [1, 2, 3] (called with no args)

Common uses:
• Immediate invocation: (lambda: value)()
• Constant functions: f = lambda: default; f()
• Lambda calls
• No-parameter function invocation

Example: (lambda: 42)() returns 42 because the lambda function lambda: 42 is immediately called with no arguments, so it evaluates and returns 42.
`
  }),
  (_i: number) => ({ 
    q: `What is lambda x, y: x + y?`, 
    o: ["Anonymous function with two parameters", "Error", "Variable", "None"], 
    c: 0, 
    e: "Lambda can have multiple parameters.",
    de: `Lambda functions can have multiple parameters separated by commas. lambda x, y: x + y creates an anonymous function with two parameters x and y that returns their sum x + y. Lambda functions can have any number of parameters, just like regular functions, but they're limited to a single expression. To call it, you provide arguments for all parameters: (lambda x, y: x + y)(3, 4).

Lambda with multiple parameters:
• lambda x, y: x + y creates anonymous function with two parameters
• lambda keyword creates function
• x, y are parameters (comma-separated)
• x + y is expression (returned)
• Function takes two arguments when called

How it works:
• lambda x, y: x + y creates function object
• Function takes parameters x and y
• Returns x + y (expression evaluated)
• Function object created but not called
• Can be called: (lambda x, y: x + y)(3, 4)

Example:
lambda x, y: x + y           # Anonymous function with two params
(lambda x, y: x + y)(3, 4)   # 7 (called with 3, 4)
(lambda a, b, c: a * b + c)(2, 3, 4) # 10 (three params)

Common uses:
• Multiple parameters: lambda x, y: x + y
• Two-argument functions: sorted(items, key=lambda x, y: (x[1], y[0]))
• Lambda with multiple params
• Multi-parameter functions

Example: lambda x, y: x + y creates an anonymous function with two parameters x and y that returns their sum. Lambda functions can have any number of parameters.
`
  }),
  (_i: number) => ({ 
    q: `What is (lambda x, y: x + y)(3, 4)?`, 
    o: ["7", "3", "4", "Error"], 
    c: 0, 
    e: "Lambda with multiple parameters.",
    de: `Lambda functions with multiple parameters are called with arguments in the same order. (lambda x, y: x + y)(3, 4) returns 7 because the lambda function lambda x, y: x + y is immediately called with arguments 3 and 4. The arguments are assigned to parameters in order: x = 3 and y = 4, then the expression x + y evaluates to 3 + 4 = 7, which is returned.

Lambda call with multiple parameters:
• (lambda x, y: x + y)(3, 4) returns 7
• Lambda function created: lambda x, y: x + y
• Immediately called with arguments: (3, 4)
• x = 3, y = 4 (assigned in order)
• Expression evaluated: x + y = 3 + 4 = 7

How it works:
• (lambda x, y: x + y)(3, 4) creates and calls function
• Lambda function defined: lambda x, y: x + y
• Arguments 3, 4 passed to parameters x, y
• x = 3, y = 4 (assigned in order)
• Expression evaluated: x + y = 3 + 4 = 7
• Returns 7

Example:
(lambda x, y: x + y)(3, 4)   # 7 (3 + 4)
(lambda x, y: x * y)(5, 6)   # 30 (5 * 6)
(lambda a, b: a ** b)(2, 3)  # 8 (2 ** 3)

Common uses:
• Immediate invocation: (lambda x, y: f(x, y))(a, b)
• Two-argument functions: (lambda x, y: x + y)(1, 2)
• Lambda calls
• Multi-parameter function invocation

Example: (lambda x, y: x + y)(3, 4) returns 7 because the lambda function lambda x, y: x + y is immediately called with arguments 3 and 4, so x = 3, y = 4, and it returns 3 + 4 = 7.
`
  }),
  (_i: number) => ({ 
    q: `What is f = lambda x: x**2; f(5)?`, 
    o: ["25", "5", "Error", "None"], 
    c: 0, 
    e: "Lambda can be assigned to variable.",
    de: `Lambda functions can be assigned to variables, making them essentially named functions. f = lambda x: x**2; f(5) returns 25 because the lambda function lambda x: x**2 is assigned to the variable f, and then f(5) calls the function with argument 5. When assigned to a variable, a lambda function works just like a regular function - you can call it multiple times, pass it as an argument, etc. However, def is generally preferred for named functions as it's more readable.

Lambda assigned to variable:
• f = lambda x: x**2; f(5) returns 25
• Lambda function created: lambda x: x**2
• Assigned to variable f
• f(5) calls function with argument 5
• Returns 25 (5 ** 2)

How it works:
• f = lambda x: x**2 creates function and assigns to f
• Variable f now contains function object
• f(5) calls function stored in f
• Argument 5 passed to parameter x
• Expression evaluated: x**2 = 5**2 = 25
• Returns 25

Example:
f = lambda x: x**2
f(5)                        # 25 (called with 5)
f(3)                        # 9 (called with 3)
f(10)                       # 100 (called with 10)

Common uses:
• Named lambda: f = lambda x: x**2 (less common, prefer def)
• Reusable lambda: func = lambda x: transform(x)
• Lambda assignment
• Function objects

Example: f = lambda x: x**2; f(5) returns 25 because the lambda function lambda x: x**2 is assigned to f, and then f(5) calls it with argument 5, returning 5**2 = 25.
`
  }),
  (_i: number) => ({ 
    q: `What is lambda x: x if x > 0 else 0?`, 
    o: ["Anonymous function with conditional", "Error", "Variable", "None"], 
    c: 0, 
    e: "Lambda can contain conditional expressions.",
    de: `Lambda functions can contain conditional expressions (ternary operators). lambda x: x if x > 0 else 0 creates an anonymous function that takes parameter x and returns x if x > 0, otherwise returns 0. Lambda functions can use if-else expressions (but not if-else statements) because they're limited to a single expression. The syntax is value_if_true if condition else value_if_false.

Lambda with conditional:
• lambda x: x if x > 0 else 0 creates anonymous function with conditional
• lambda keyword creates function
• x is parameter
• x if x > 0 else 0 is conditional expression
• Returns x if x > 0, else returns 0

How it works:
• lambda x: x if x > 0 else 0 creates function object
• Function takes parameter x
• Evaluates condition: x > 0
• If True: returns x
• If False: returns 0

Example:
lambda x: x if x > 0 else 0  # Conditional function
(lambda x: x if x > 0 else 0)(5)   # 5 (x > 0, returns x)
(lambda x: x if x > 0 else 0)(-5)  # 0 (x <= 0, returns 0)

Common uses:
• Conditional lambda: lambda x: x if condition else default
• Ternary in lambda: lambda x: 'big' if x > 10 else 'small'
• Conditional expressions
• Lambda with conditions

Example: lambda x: x if x > 0 else 0 creates an anonymous function with a conditional expression that returns x if x > 0, otherwise returns 0.
`
  }),
  (_i: number) => ({ 
    q: `What is (lambda x: x if x > 0 else 0)(-5)?`, 
    o: ["0", "-5", "Error", "None"], 
    c: 0, 
    e: "Lambda conditional expression evaluation.",
    de: `Lambda functions with conditional expressions evaluate the condition and return the appropriate value. (lambda x: x if x > 0 else 0)(-5) returns 0 because the lambda function lambda x: x if x > 0 else 0 is immediately called with argument -5. The condition x > 0 evaluates to False (since -5 is not greater than 0), so the else branch is taken, returning 0 instead of x.

Lambda conditional evaluation:
• (lambda x: x if x > 0 else 0)(-5) returns 0
• Lambda function created: lambda x: x if x > 0 else 0
• Immediately called with argument: (-5)
• x = -5, condition evaluated: -5 > 0 is False
• Else branch taken: returns 0 (not x)

How it works:
• (lambda x: x if x > 0 else 0)(-5) creates and calls function
• Lambda function defined: lambda x: x if x > 0 else 0
• Argument -5 passed to parameter x
• Condition evaluated: x > 0 → -5 > 0 → False
• Else branch executed: returns 0

Example:
(lambda x: x if x > 0 else 0)(-5)  # 0 (condition False, returns 0)
(lambda x: x if x > 0 else 0)(5)   # 5 (condition True, returns x)
(lambda x: x if x > 0 else 0)(0)   # 0 (condition False, returns 0)

Common uses:
• Conditional evaluation: (lambda x: x if condition else default)(value)
• Ternary in lambda: (lambda x: 'pos' if x > 0 else 'neg')(-5)
• Conditional expressions
• Lambda with conditions

Example: (lambda x: x if x > 0 else 0)(-5) returns 0 because the condition -5 > 0 is False, so the else branch is taken and 0 is returned.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between def and lambda?`, 
    o: ["def creates named function, lambda creates anonymous", "No difference", "lambda is faster", "def is deprecated"], 
    c: 0, 
    e: "def creates named function, lambda creates anonymous function.",
    de: `The key difference between def and lambda is that def creates a named function while lambda creates an anonymous function. def func(x): return x * 2 creates a function named func, while lambda x: x * 2 creates a function without a name. Additionally, def functions can contain multiple statements, while lambda functions are limited to a single expression. def is generally preferred for named functions, while lambda is useful for short, one-line functions used as arguments to other functions.

def vs lambda:
• def creates named function, lambda creates anonymous function
• def can have multiple statements, lambda limited to single expression
• def preferred for named functions, lambda for short inline functions
• def functions have names, lambda functions don't (unless assigned)
• Both create function objects

How it works:
• def func(x): return x * 2 creates function named 'func'
• lambda x: x * 2 creates anonymous function (no name)
• def can have: multiple statements, docstrings, annotations
• lambda can have: single expression only
• lambda often used as argument: map(lambda x: x*2, [1,2,3])

Example:
def func(x): return x * 2  # Named function 'func'
lambda x: x * 2            # Anonymous function (no name)
f = lambda x: x * 2        # Assigned to variable (essentially named)

Common uses:
• def: named functions, multiple statements: def process(x): ...; ...; return result
• lambda: short inline functions, single expression: map(lambda x: x*2, items)
• Function definition
• Lambda functions

Example: The difference is def creates a named function (e.g., def func(x): return x * 2 creates function 'func'), while lambda creates an anonymous function (e.g., lambda x: x * 2 creates a function without a name). def functions can contain multiple statements, while lambda functions are limited to a single expression.
`
  }),
  
  // 41-50: Return Values
  (_i: number) => ({ 
    q: `What is def func(): return 1?`, 
    o: ["Defines function returning 1", "Calls function", "Error", "None"], 
    c: 0, 
    e: "Function returns single value.",
    de: `Functions return values using the return statement. def func(): return 1 defines a function that returns the value 1 when called. The return statement immediately exits the function and sends back the specified value. Functions can return any type of value - numbers, strings, lists, dictionaries, objects, etc. If no return statement is executed, the function returns None implicitly.

Return statement:
• def func(): return 1 defines function returning 1
• return statement exits function
• Returns specified value: 1
• Function call evaluates to returned value
• Can return any type

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: return 1
• When called: func() returns 1

Example:
def func(): return 1
func()                      # 1 (returns 1)
result = func()             # result = 1
print(func())               # 1 (prints returned value)

Common uses:
• Returning values: def calculate(): return result
• Function results: def get_value(): return value
• Return statement
• Function return values

Example: def func(): return 1 defines a function that returns the value 1 when called. The return statement immediately exits the function and sends back the value.
`
  }),
  (_i: number) => ({ 
    q: `What is func() if def func(): return 1?`, 
    o: ["1", "None", "Error", "0"], 
    c: 0, 
    e: "Function call returns the value.",
    de: `Calling a function that returns a value evaluates to that value. If def func(): return 1, then func() returns 1 because calling the function executes the return statement, which exits the function and returns the value 1. The function call func() evaluates to the returned value, so it can be used in expressions, assigned to variables, or printed.

Function call returns value:
• func() with def func(): return 1 returns 1
• Function call evaluates to returned value
• return 1 executes when function called
• Function call becomes 1
• Can be used in expressions

How it works:
• func() calls function func
• Function executes: return 1
• return statement exits function
• Function call evaluates to returned value: 1
• Returns: 1

Example:
def func(): return 1
func()                      # 1 (returns 1)
result = func()             # result = 1
print(func())               # 1 (prints 1)
func() * 2                  # 2 (uses returned value: 1 * 2)

Common uses:
• Using return values: result = func()
• In expressions: total = calculate() + 10
• Return value usage
• Function call evaluation

Example: If def func(): return 1, then func() returns 1 because calling the function executes the return statement, which returns the value 1, and the function call evaluates to that value.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return 1, 2, 3?`, 
    o: ["Defines function returning tuple (1, 2, 3)", "Error", "Defines function returning three values", "None"], 
    c: 0, 
    e: "Multiple values in return create tuple.",
    de: `Returning multiple values in Python creates a tuple. def func(): return 1, 2, 3 defines a function that returns a tuple (1, 2, 3) because when you write return 1, 2, 3, Python automatically creates a tuple - the comma creates a tuple, not parentheses. This is Python's way of returning multiple values - you can unpack them when calling the function: a, b, c = func() assigns 1 to a, 2 to b, and 3 to c.

Multiple return values:
• def func(): return 1, 2, 3 defines function returning tuple
• return 1, 2, 3 creates tuple (1, 2, 3)
• Comma creates tuple (parentheses optional)
• Returns single tuple object
• Can be unpacked: a, b, c = func()

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: return 1, 2, 3
• Comma creates tuple: (1, 2, 3)
• When called: func() returns (1, 2, 3)

Example:
def func(): return 1, 2, 3
func()                      # (1, 2, 3) (returns tuple)
a, b, c = func()            # a=1, b=2, c=3 (unpacking)

Common uses:
• Returning multiple values: return x, y, z
• Tuple return: return (1, 2, 3) (same as return 1, 2, 3)
• Multiple value return
• Unpacking return values

Example: def func(): return 1, 2, 3 defines a function that returns a tuple (1, 2, 3). The comma creates a tuple, so return 1, 2, 3 is equivalent to return (1, 2, 3).
`
  }),
  (_i: number) => ({ 
    q: `What is func() if def func(): return 1, 2, 3?`, 
    o: ["(1, 2, 3)", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "Function returns tuple of values.",
    de: `Calling a function that returns multiple values returns a tuple. If def func(): return 1, 2, 3, then func() returns (1, 2, 3) because the comma in return 1, 2, 3 creates a tuple. The function call evaluates to a tuple containing all the returned values. You can unpack this tuple: a, b, c = func() assigns each value to a variable, or you can use it as a tuple.

Function returns tuple:
• func() with def func(): return 1, 2, 3 returns (1, 2, 3)
• Multiple values in return create tuple
• Function call evaluates to tuple
• Returns single tuple object
• Can be unpacked or used as tuple

How it works:
• func() calls function func
• Function executes: return 1, 2, 3
• Comma creates tuple: (1, 2, 3)
• return statement returns tuple
• Function call evaluates to: (1, 2, 3)

Example:
def func(): return 1, 2, 3
func()                      # (1, 2, 3) (returns tuple)
a, b, c = func()            # a=1, b=2, c=3 (unpacking)
result = func()             # result = (1, 2, 3) (tuple)

Common uses:
• Returning multiple values: return x, y, z (returns tuple)
• Tuple return: result = func() (result is tuple)
• Multiple value return
• Tuple unpacking

Example: If def func(): return 1, 2, 3, then func() returns (1, 2, 3) because returning multiple values creates a tuple, and the function call evaluates to that tuple.
`
  }),
  (_i: number) => ({ 
    q: `What is a, b = func() if def func(): return 1, 2?`, 
    o: ["a=1, b=2", "Error", "a=(1,2), b=None", "None"], 
    c: 0, 
    e: "Tuple unpacking from function return.",
    de: `You can unpack multiple return values using tuple unpacking. If def func(): return 1, 2, then a, b = func() assigns 1 to a and 2 to b because func() returns a tuple (1, 2), and the assignment a, b = (1, 2) unpacks the tuple, assigning each element to the corresponding variable. This is a common pattern for functions that return multiple values - you can unpack them directly into variables.

Tuple unpacking from return:
• a, b = func() with def func(): return 1, 2 assigns a=1, b=2
• func() returns tuple (1, 2)
• a, b = (1, 2) unpacks tuple
• First element 1 assigned to a
• Second element 2 assigned to b

How it works:
• func() calls function func
• Function executes: return 1, 2
• Returns tuple: (1, 2)
• a, b = (1, 2) unpacks tuple
• a = 1, b = 2 (assigned)

Example:
def func(): return 1, 2
a, b = func()               # a=1, b=2 (unpacking)
x, y, z = func()            # ValueError (not enough values to unpack)
result = func()             # result = (1, 2) (no unpacking)

Common uses:
• Unpacking return values: a, b = func()
• Multiple assignments: x, y, z = calculate()
• Tuple unpacking
• Multiple value return

Example: If def func(): return 1, 2, then a, b = func() assigns 1 to a and 2 to b because func() returns a tuple (1, 2), which is unpacked into the variables a and b.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return?`, 
    o: ["Defines function returning None", "Error", "Defines function with no return", "None"], 
    c: 0, 
    e: "return without value returns None.",
    de: `A return statement without a value returns None. def func(): return defines a function that explicitly returns None. When you use return without a value, Python returns None. This is equivalent to return None or having no return statement at all - all three result in the function returning None. Explicitly using return without a value can make it clear that the function intentionally returns None.

return without value:
• def func(): return defines function returning None
• return without value returns None
• Equivalent to return None
• Equivalent to no return statement
• Function returns None

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: return (no value)
• When called: func() returns None
• Explicit None return

Example:
def func(): return          # Returns None
func()                      # None
def func(): return None     # Same: None
def func(): pass            # Same: None (no return)

Common uses:
• Explicit None return: def func(): return
• Clear intent: return None explicitly
• Function termination
• None return pattern

Example: def func(): return defines a function that explicitly returns None. The return statement without a value returns None, making it clear that the function intentionally returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is func() if def func(): return?`, 
    o: ["None", "Error", "0", "()"], 
    c: 0, 
    e: "Function returns None when return has no value.",
    de: `Calling a function with a return statement that has no value returns None. If def func(): return, then func() returns None because the return statement without a value explicitly returns None. The function call evaluates to None, which is Python's null value. This is useful when you want to explicitly indicate that a function returns nothing meaningful.

return without value - call:
• func() with def func(): return returns None
• return without value returns None
• Function call evaluates to None
• None is Python's null value
• Explicit None return

How it works:
• func() calls function func
• Function executes: return (no value)
• return without value returns None
• Function call evaluates to None
• Returns: None

Example:
def func(): return
func()                      # None (returns None)
result = func()             # result = None
if func() is None:          # True (returns None)
    print("returned None")

Common uses:
• Explicit None return: def process(): return (returns None)
• None return: result = func() (result is None)
• Return value usage
• None return pattern

Example: If def func(): return, then func() returns None because the return statement without a value explicitly returns None, and the function call evaluates to that value.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): pass?`, 
    o: ["Defines function returning None", "Error", "Defines function with no return", "None"], 
    c: 0, 
    e: "Function without return statement returns None.",
    de: `Functions without a return statement automatically return None. def func(): pass defines a function with an empty body (pass is a placeholder), and when called, it returns None because no return statement is executed. This is Python's default behavior - every function returns a value, and if no return statement is executed, the function returns None implicitly. This is consistent with the behavior of functions with return or return None.

Function without return:
• def func(): pass defines function returning None
• No return statement in function
• Implicitly returns None
• Default behavior in Python
• Every function returns a value

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: pass (placeholder, does nothing)
• When called: func() executes pass, then returns None implicitly
• Returns: None

Example:
def func(): pass            # No return, returns None
func()                      # None (implicitly returns None)
def func(): print("hi")     # No return, returns None
result = func()             # result = None (implicit return)

Common uses:
• Functions without return: def func(): body (returns None)
• Side-effect functions: def print_data(): print(x) (returns None)
• Implicit None return
• Default return behavior

Example: def func(): pass defines a function without a return statement. When called, it implicitly returns None because no return statement is executed, which is Python's default behavior.
`
  }),
  (_i: number) => ({ 
    q: `What is func() if def func(): pass?`, 
    o: ["None", "Error", "0", "()"], 
    c: 0, 
    e: "Function with pass returns None.",
    de: `Calling a function with only pass returns None. If def func(): pass, then func() returns None because the function has no return statement, so it implicitly returns None when it finishes executing. The pass statement does nothing - it's just a placeholder for syntactically valid code. When the function reaches the end without encountering a return statement, Python automatically returns None.

Function with pass - call:
• func() with def func(): pass returns None
• pass does nothing (placeholder)
• No return statement executed
• Function implicitly returns None
• Returns None

How it works:
• func() calls function func
• Function executes: pass (does nothing)
• Reaches end of function
• No return statement encountered
• Implicitly returns None
• Returns: None

Example:
def func(): pass
func()                      # None (implicitly returns None)
result = func()             # result = None
if func() is None:          # True (returns None)
    print("returned None")

Common uses:
• Empty functions: def placeholder(): pass (returns None)
• Stub functions: def todo(): pass (returns None)
• Implicit None return
• Placeholder functions

Example: If def func(): pass, then func() returns None because the function has no return statement, so when it finishes executing (after doing nothing with pass), it implicitly returns None.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return [1, 2, 3]?`, 
    o: ["Defines function returning list", "Error", "Defines function returning tuple", "None"], 
    c: 0, 
    e: "Function can return any type, including list.",
    de: `Functions can return any type of value, including lists. def func(): return [1, 2, 3] defines a function that returns a list [1, 2, 3] when called. The return statement can return any Python object - numbers, strings, lists, tuples, dictionaries, sets, objects, None, etc. Functions are not restricted to returning specific types - they can return whatever type is appropriate for their purpose.

Returning any type:
• def func(): return [1, 2, 3] defines function returning list
• Functions can return any type
• return can return: numbers, strings, lists, tuples, dicts, objects, None
• List [1, 2, 3] is returned
• Function call evaluates to list

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: return [1, 2, 3]
• Returns list object: [1, 2, 3]
• When called: func() returns [1, 2, 3]

Example:
def func(): return [1, 2, 3]
func()                      # [1, 2, 3] (returns list)
def func(): return {'a': 1} # Returns dictionary
def func(): return "hello"   # Returns string
def func(): return None      # Returns None

Common uses:
• Returning collections: def get_list(): return [1, 2, 3]
• Returning objects: def create_object(): return MyClass()
• Return any type
• Flexible return values

Example: def func(): return [1, 2, 3] defines a function that returns a list [1, 2, 3]. Functions can return any type of value - numbers, strings, lists, dictionaries, objects, etc.
`
  }),
  
  // 51-60: Function Scope and Variables
  (_i: number) => ({ 
    q: `What is x = 1; def func(): return x; func()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Function can access global variable.",
    de: `Functions can access global variables (variables defined outside the function). If x = 1; def func(): return x; func(), then func() returns 1 because the function can read global variables. When a function references a variable that's not defined locally, Python looks in the outer scope (global scope) and finds x = 1, so it uses that value. This is called variable lookup - Python searches from local to global scope.

Global variable access:
• x = 1; def func(): return x; func() returns 1
• x = 1 defines global variable
• func() references x (not defined locally)
• Python looks in global scope, finds x = 1
• Returns global value: 1

How it works:
• x = 1 creates global variable x = 1
• def func(): creates function definition
• Function references x (not defined in function)
• Python searches from local to global scope
• Finds x = 1 in global scope
• Returns: 1

Example:
x = 1
def func(): return x
func()                      # 1 (accesses global x)
x = 10
func()                      # 10 (still accesses global x)

Common uses:
• Reading globals: def func(): return global_var
• Global access: def calculate(): return base * rate
• Variable lookup
• Global variable access

Example: If x = 1; def func(): return x; func(), then func() returns 1 because the function can access the global variable x, and Python finds x = 1 in the global scope.
`
  }),
  (_i: number) => ({ 
    q: `What is x = 1; def func(): x = 2; return x; func()?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Local assignment creates local variable.",
    de: `Assigning to a variable inside a function creates a local variable, even if a global variable with the same name exists. If x = 1; def func(): x = 2; return x; func(), then func() returns 2 because x = 2 inside the function creates a local variable x that shadows (hides) the global variable x. When the function references x, it uses the local variable x = 2, not the global x = 1. This is Python's scoping rule - assignment creates a local variable.

Local assignment:
• x = 1; def func(): x = 2; return x; func() returns 2
• x = 1 defines global variable
• x = 2 inside function creates local variable
• Local variable shadows global variable
• Function uses local x = 2
• Returns local value: 2

How it works:
• x = 1 creates global variable x = 1
• def func(): creates function definition
• x = 2 inside function creates local variable x = 2
• Local x shadows global x
• return x uses local x = 2
• Returns: 2

Example:
x = 1
def func(): x = 2; return x
func()                      # 2 (uses local x = 2)
x                           # 1 (global x unchanged)

Common uses:
• Local variables: def func(): x = value (creates local)
• Variable shadowing: local x shadows global x
• Local variable creation
• Function scoping

Example: If x = 1; def func(): x = 2; return x; func(), then func() returns 2 because assigning x = 2 inside the function creates a local variable x that shadows the global variable x, so the function uses the local x = 2.
`
  }),
  (_i: number) => ({ 
    q: `What is x = 1; def func(): x = 2; func(); x?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "Local assignment doesn't affect global variable.",
    de: `Assigning to a variable inside a function doesn't affect the global variable with the same name. If x = 1; def func(): x = 2; func(); x, then x returns 1 because assigning x = 2 inside the function creates a local variable x, which doesn't affect the global variable x. Local variables exist only within the function and don't modify global variables unless you use the global keyword. The global variable x remains 1.

Local doesn't affect global:
• x = 1; def func(): x = 2; func(); x returns 1
• x = 1 defines global variable x = 1
• x = 2 inside function creates local variable x = 2
• Local x doesn't affect global x
• Global x remains 1
• Returns: 1

How it works:
• x = 1 creates global variable x = 1
• def func(): creates function definition
• x = 2 inside function creates local variable x = 2
• func() executes (local x = 2, doesn't affect global)
• func() returns (local x destroyed)
• x evaluates global x = 1
• Returns: 1

Example:
x = 1
def func(): x = 2  # Creates local x = 2
func()                      # Local x = 2 (doesn't affect global)
x                           # 1 (global x unchanged)

Common uses:
• Understanding scope: local variables don't affect globals
• Variable independence: def func(): local = value (independent)
• Local vs global
• Variable scoping

Example: If x = 1; def func(): x = 2; func(); x, then x returns 1 because assigning x = 2 inside the function creates a local variable that doesn't affect the global variable x, which remains 1.
`
  }),
  (_i: number) => ({ 
    q: `What is x = 1; def func(): global x; x = 2; func(); x?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "global keyword allows modifying global variable.",
    de: `The global keyword allows a function to modify a global variable. If x = 1; def func(): global x; x = 2; func(); x, then x returns 2 because the global keyword tells Python that x inside the function refers to the global variable x, not a local variable. When you assign x = 2 inside the function, it modifies the global variable x, changing it from 1 to 2. Without the global keyword, assignment would create a local variable instead.

global keyword:
• x = 1; def func(): global x; x = 2; func(); x returns 2
• global x tells Python to use global variable x
• x = 2 inside function modifies global x
• Global x changed from 1 to 2
• Returns: 2

How it works:
• x = 1 creates global variable x = 1
• def func(): creates function definition
• global x tells Python x refers to global variable
• x = 2 inside function modifies global x
• func() executes (global x becomes 2)
• x evaluates global x = 2
• Returns: 2

Example:
x = 1
def func(): global x; x = 2  # Modifies global x
func()                      # Global x becomes 2
x                           # 2 (global x modified)

Common uses:
• Modifying globals: def func(): global var; var = new_value
• Global modification: def update(): global counter; counter += 1
• global keyword
• Global variable modification

Example: If x = 1; def func(): global x; x = 2; func(); x, then x returns 2 because the global keyword tells Python to use the global variable x, so assigning x = 2 inside the function modifies the global variable, changing it from 1 to 2.
`
  }),
  (_i: number) => ({ 
    q: `What is def outer(): x = 1; def inner(): return x; return inner(); outer()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Inner function can access outer function's variables (closure).",
    de: `Inner functions (nested functions) can access variables from outer functions. If def outer(): x = 1; def inner(): return x; return inner(); outer(), then outer() returns 1 because the inner function inner() can access the outer function's local variable x = 1. This is called a closure - the inner function "closes over" the outer function's variables, allowing it to access them even after the outer function has finished executing (if the inner function is returned).

Closure - inner accesses outer:
• def outer(): x = 1; def inner(): return x; return inner(); outer() returns 1
• outer() defines local variable x = 1
• inner() is defined inside outer()
• inner() can access outer()'s local variable x
• inner() returns x = 1
• outer() returns inner()'s result: 1

How it works:
• outer() creates function definition
• outer() defines local variable x = 1
• inner() is defined inside outer()
• inner() references x (not defined in inner())
• Python searches outer scope, finds x = 1 in outer()
• inner() returns x = 1
• outer() returns inner()'s result: 1

Example:
def outer():
    x = 1
    def inner(): return x
    return inner()
outer()                      # 1 (inner accesses outer's x)

Common uses:
• Nested functions: def outer(): x = value; def inner(): use x
• Closures: def factory(x): def inner(): return x; return inner
• Variable access
• Closure behavior

Example: If def outer(): x = 1; def inner(): return x; return inner(); outer(), then outer() returns 1 because the inner function inner() can access the outer function's local variable x = 1, which is called a closure.
`
  }),
  (_i: number) => ({ 
    q: `What is def outer(x): def inner(): return x; return inner; f = outer(5); f()?`, 
    o: ["5", "Error", "None", "0"], 
    c: 0, 
    e: "Closure captures outer function's parameter.",
    de: `Closures can capture outer function parameters, allowing the inner function to access them even after the outer function returns. If def outer(x): def inner(): return x; return inner; f = outer(5); f(), then f() returns 5 because outer(5) creates a closure where the inner function inner() captures the outer function's parameter x = 5. When inner is returned and assigned to f, it still "remembers" the value of x = 5, so calling f() returns 5. This is a powerful feature that allows functions to "remember" their environment.

Closure captures parameter:
• def outer(x): def inner(): return x; return inner; f = outer(5); f() returns 5
• outer(5) creates closure with x = 5
• inner() captures x = 5 from outer function
• inner returned and assigned to f
• f() calls inner(), which returns captured x = 5
• Returns: 5

How it works:
• outer(5) calls outer function with x = 5
• outer() defines inner() that references x
• inner() captures x = 5 from outer function
• outer() returns inner function object
• f = inner (inner function assigned to f)
• f() calls inner(), which returns captured x = 5
• Returns: 5

Example:
def outer(x): def inner(): return x; return inner
f = outer(5)                  # f is inner function that captured x = 5
f()                          # 5 (returns captured x = 5)
g = outer(10)                 # g is inner function that captured x = 10
g()                          # 10 (returns captured x = 10)

Common uses:
• Factory functions: def make_multiplier(n): return lambda x: x * n
• Closures: def create_closure(x): def inner(): return x; return inner
• Parameter capture
• Closure behavior

Example: If def outer(x): def inner(): return x; return inner; f = outer(5); f(), then f() returns 5 because the inner function inner() captures the outer function's parameter x = 5 in a closure, so when f() is called, it returns the captured value 5.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): x = 1; return x; func(); x?`, 
    o: ["NameError", "1", "Error", "None"], 
    c: 0, 
    e: "Local variable not accessible outside function.",
    de: `Local variables (variables defined inside a function) are not accessible outside the function. If def func(): x = 1; return x; func(); x, then x raises a NameError because x is a local variable defined inside func(), and local variables only exist within the function where they're defined. Once the function returns, local variables are destroyed and cannot be accessed from outside the function. This is Python's scoping rule - local variables have local scope only.

Local variable scope:
• def func(): x = 1; return x; func(); x raises NameError
• x = 1 inside function creates local variable x
• Local variables only exist inside function
• After func() returns, local x is destroyed
• x outside function raises NameError (x not defined)
• Error: NameError: name 'x' is not defined

How it works:
• def func(): creates function definition
• x = 1 inside function creates local variable x = 1
• func() executes: returns 1, local x destroyed
• x outside function tries to access x
• x not defined in global scope
• Raises NameError

Example:
def func(): x = 1; return x
func()                      # 1 (returns local x)
x                           # NameError: name 'x' is not defined

Common uses:
• Understanding scope: local variables not accessible outside
• Variable lifetime: local vars destroyed after function returns
• Local vs global
• Variable scoping

Example: If def func(): x = 1; return x; func(); x, then x raises a NameError because x is a local variable defined inside func(), and local variables are not accessible outside the function where they're defined.
`
  }),
  (_i: number) => ({ 
    q: `What is x = 1; def func(y): return x + y; func(2)?`, 
    o: ["3", "1", "2", "Error"], 
    c: 0, 
    e: "Function can access global and use parameter.",
    de: `Functions can access both global variables and function parameters. If x = 1; def func(y): return x + y; func(2), then func(2) returns 3 because the function accesses the global variable x = 1 and uses the parameter y = 2, returning x + y = 1 + 2 = 3. Functions can reference variables from different scopes - they can use global variables (like x) and function parameters (like y) in the same expression.

Global and parameter:
• x = 1; def func(y): return x + y; func(2) returns 3
• x = 1 defines global variable
• func(y) has parameter y
• func(2) passes y = 2
• return x + y uses global x = 1 and parameter y = 2
• Returns 1 + 2 = 3

How it works:
• x = 1 creates global variable x = 1
• def func(y): creates function with parameter y
• func(2) calls function with y = 2
• return x + y references global x = 1 and parameter y = 2
• Evaluates: 1 + 2 = 3
• Returns: 3

Example:
x = 1
def func(y): return x + y
func(2)                      # 3 (global x=1 + parameter y=2)
func(5)                      # 6 (global x=1 + parameter y=5)

Common uses:
• Using globals and parameters: def calculate(y): return global_var + y
• Mixed scope access: def process(param): return base + param
• Global and parameter access
• Variable scoping

Example: If x = 1; def func(y): return x + y; func(2), then func(2) returns 3 because the function accesses the global variable x = 1 and uses the parameter y = 2, returning 1 + 2 = 3.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): x = x + 1; return x; func()?`, 
    o: ["UnboundLocalError", "1", "Error", "None"], 
    c: 0, 
    e: "Assignment to x makes it local, can't read before assignment.",
    de: `Assigning to a variable inside a function makes it local, which prevents reading it before assignment. If def func(): x = x + 1; return x; func(), then func() raises an UnboundLocalError because x = x + 1 assigns to x, making it a local variable, but x is referenced on the right side (x + 1) before it's assigned, so Python raises an error. Python determines that x is local because of the assignment, but then tries to read x before it's been assigned a value, causing the error.

UnboundLocalError:
• def func(): x = x + 1; return x; func() raises UnboundLocalError
• x = x + 1 assigns to x (makes x local)
• Python determines x is local variable
• Tries to read x in x + 1 before assignment
• x not yet assigned (unbound)
• Raises UnboundLocalError

How it works:
• def func(): creates function definition
• x = x + 1 assigns to x (makes x local)
• Python determines x is local (because of assignment)
• Tries to evaluate x + 1 (reads x)
• x is local but not yet assigned
• Raises UnboundLocalError: local variable 'x' referenced before assignment

Example:
def func(): x = x + 1; return x
func()                      # UnboundLocalError
# Fix: def func(): global x; x = x + 1; return x

Common uses:
• Understanding error: assignment makes variable local
• Fixing error: use global keyword if modifying global
• Local variable binding
• UnboundLocalError

Example: If def func(): x = x + 1; return x; func(), then func() raises an UnboundLocalError because assigning x = x + 1 makes x local, but then x is referenced in x + 1 before it's assigned, so Python raises an error. To fix, use global x if you want to modify a global variable.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return len([1, 2, 3]); func()?`, 
    o: ["3", "Error", "None", "0"], 
    c: 0, 
    e: "Function can call built-in functions.",
    de: `Functions can call built-in functions just like any other code. If def func(): return len([1, 2, 3]); func(), then func() returns 3 because the function calls the built-in len() function with [1, 2, 3], which returns 3 (the length of the list). Functions have access to all built-in functions (like len, print, range, etc.) and can call them just like they can call other functions. Built-in functions are available in all scopes.

Built-in function call:
• def func(): return len([1, 2, 3]); func() returns 3
• Function can call built-in functions
• len([1, 2, 3]) called inside function
• len() returns 3 (length of list)
• Function returns 3

How it works:
• def func(): creates function definition
• Function name: func
• No parameters: ()
• Body: return len([1, 2, 3])
• len([1, 2, 3]) called, returns 3
• Function returns 3

Example:
def func(): return len([1, 2, 3])
func()                      # 3 (returns len result)
def func(): return sum([1, 2, 3])  # Returns 6
def func(): return max([1, 2, 3])  # Returns 3

Common uses:
• Built-in usage: def func(): return len(data)
• Function composition: def process(): return sorted(items)
• Built-in function access
• Function capabilities

Example: If def func(): return len([1, 2, 3]); func(), then func() returns 3 because the function calls the built-in len() function with [1, 2, 3], which returns 3, and the function returns that value.
`
  }),
  
  // 61-70: Recursion
  (_i: number) => ({ 
    q: `What is def fact(n): return 1 if n <= 1 else n * fact(n-1); fact(5)?`, 
    o: ["120", "5", "Error", "None"], 
    c: 0, 
    e: "Recursive function calls itself.",
    de: `A recursive function calls itself to solve a problem. If def fact(n): return 1 if n <= 1 else n * fact(n-1); fact(5), then fact(5) returns 120 because fact(5) calls fact(4), which calls fact(3), which calls fact(2), which calls fact(1), which returns 1 (base case). Then each call multiplies by n: 1 * 2 * 3 * 4 * 5 = 120. Recursion breaks a problem into smaller subproblems of the same type, with a base case that stops the recursion.

Recursive function:
• def fact(n): return 1 if n <= 1 else n * fact(n-1); fact(5) returns 120
• fact(5) calls fact(4), which calls fact(3), etc.
• Base case: n <= 1 returns 1 (stops recursion)
• Recursive case: n * fact(n-1) (calls itself)
• Evaluates: 5 * 4 * 3 * 2 * 1 = 120

How it works:
• fact(5) calls fact(4): 5 * fact(4)
• fact(4) calls fact(3): 4 * fact(3)
• fact(3) calls fact(2): 3 * fact(2)
• fact(2) calls fact(1): 2 * fact(1)
• fact(1) returns 1 (base case: n <= 1)
• Unwinds: 2 * 1 = 2, 3 * 2 = 6, 4 * 6 = 24, 5 * 24 = 120
• Returns: 120

Example:
def fact(n): return 1 if n <= 1 else n * fact(n-1)
fact(5)                      # 120 (5 * 4 * 3 * 2 * 1)
fact(3)                      # 6 (3 * 2 * 1)
fact(1)                      # 1 (base case)

Common uses:
• Recursive algorithms: def factorial(n): return base if condition else recursive
• Divide and conquer: def solve(problem): return solve(smaller_problem)
• Recursive functions
• Problem decomposition

Example: If def fact(n): return 1 if n <= 1 else n * fact(n-1); fact(5), then fact(5) returns 120 because the recursive function calls itself with decreasing values until it reaches the base case (n <= 1), then multiplies all values together: 5 * 4 * 3 * 2 * 1 = 120.
`
  }),
  (_i: number) => ({ 
    q: `What is def fib(n): return n if n < 2 else fib(n-1) + fib(n-2); fib(5)?`, 
    o: ["5", "8", "Error", "None"], 
    c: 0, 
    e: "Recursive Fibonacci function.",
    de: `The Fibonacci sequence is computed recursively where each number is the sum of the two preceding ones. If def fib(n): return n if n < 2 else fib(n-1) + fib(n-2); fib(5), then fib(5) returns 5 because fib(5) = fib(4) + fib(3), which expands further. The base case is n < 2, which returns n (fib(0) = 0, fib(1) = 1). The recursive case computes fib(n) = fib(n-1) + fib(n-2). Note: fib(5) actually returns 5 (the 5th Fibonacci number), not 8.

Recursive Fibonacci:
• def fib(n): return n if n < 2 else fib(n-1) + fib(n-2); fib(5) returns 5
• Base case: n < 2 returns n (fib(0) = 0, fib(1) = 1)
• Recursive case: fib(n-1) + fib(n-2) (sum of previous two)
• fib(5) = fib(4) + fib(3), expands recursively
• Evaluates: 0, 1, 1, 2, 3, 5

How it works:
• fib(5) calls fib(4) + fib(3)
• fib(4) calls fib(3) + fib(2)
• fib(3) calls fib(2) + fib(1)
• fib(2) calls fib(1) + fib(0) = 1 + 0 = 1
• Unwinds: fib(3) = 2, fib(4) = 3, fib(5) = 5
• Returns: 5

Example:
def fib(n): return n if n < 2 else fib(n-1) + fib(n-2)
fib(5)                      # 5 (5th Fibonacci number)
fib(6)                      # 8 (6th Fibonacci number)
fib(0)                      # 0 (base case)

Common uses:
• Recursive sequences: def fibonacci(n): return base if condition else recursive
• Mathematical sequences: fib(n) = fib(n-1) + fib(n-2)
• Recursive algorithms
• Fibonacci sequence

Example: If def fib(n): return n if n < 2 else fib(n-1) + fib(n-2); fib(5), then fib(5) returns 5 because the recursive Fibonacci function computes the 5th Fibonacci number (0, 1, 1, 2, 3, 5) by summing the previous two Fibonacci numbers.
`
  }),
  (_i: number) => ({ 
    q: `What is def count(n): return 0 if n <= 0 else 1 + count(n-1); count(5)?`, 
    o: ["5", "0", "Error", "None"], 
    c: 0, 
    e: "Recursive counting function.",
    de: `A recursive counting function counts from n down to 1. If def count(n): return 0 if n <= 0 else 1 + count(n-1); count(5), then count(5) returns 5 because count(5) = 1 + count(4) = 1 + (1 + count(3)) = ... = 1 + 1 + 1 + 1 + 1 + 0 = 5. The base case is n <= 0, which returns 0 (stops counting). The recursive case returns 1 plus the count of the next smaller number, effectively counting how many numbers from n down to 1.

Recursive counting:
• def count(n): return 0 if n <= 0 else 1 + count(n-1); count(5) returns 5
• Base case: n <= 0 returns 0 (stops counting)
• Recursive case: 1 + count(n-1) (adds 1 for each number)
• count(5) = 1 + count(4) = 1 + 1 + count(3) = ...
• Evaluates: 1 + 1 + 1 + 1 + 1 + 0 = 5

How it works:
• count(5) calls 1 + count(4)
• count(4) calls 1 + count(3)
• count(3) calls 1 + count(2)
• count(2) calls 1 + count(1)
• count(1) calls 1 + count(0)
• count(0) returns 0 (base case: n <= 0)
• Unwinds: 1 + 0 = 1, 1 + 1 = 2, 1 + 2 = 3, 1 + 3 = 4, 1 + 4 = 5
• Returns: 5

Example:
def count(n): return 0 if n <= 0 else 1 + count(n-1)
count(5)                     # 5 (counts 5 numbers)
count(10)                    # 10 (counts 10 numbers)
count(0)                     # 0 (base case)

Common uses:
• Recursive counting: def count(n): return base if condition else 1 + recursive
• Counting sequences: def count_down(n): return count(n)
• Recursive algorithms
• Counting functions

Example: If def count(n): return 0 if n <= 0 else 1 + count(n-1); count(5), then count(5) returns 5 because the recursive function counts from 5 down to 1, adding 1 for each number: 1 + 1 + 1 + 1 + 1 + 0 = 5.
`
  }),
  (_i: number) => ({ 
    q: `What is def sum_list(lst): return 0 if not lst else lst[0] + sum_list(lst[1:]); sum_list([1,2,3])?`, 
    o: ["6", "3", "Error", "None"], 
    c: 0, 
    e: "Recursive function summing list elements.",
    de: `A recursive function can sum list elements by adding the first element to the sum of the rest. If def sum_list(lst): return 0 if not lst else lst[0] + sum_list(lst[1:]); sum_list([1,2,3]), then sum_list([1,2,3]) returns 6 because sum_list([1,2,3]) = 1 + sum_list([2,3]) = 1 + (2 + sum_list([3])) = 1 + 2 + (3 + sum_list([])) = 1 + 2 + 3 + 0 = 6. The base case is an empty list, which returns 0. The recursive case adds the first element to the sum of the remaining list.

Recursive sum:
• def sum_list(lst): return 0 if not lst else lst[0] + sum_list(lst[1:]); sum_list([1,2,3]) returns 6
• Base case: not lst returns 0 (empty list)
• Recursive case: lst[0] + sum_list(lst[1:]) (first + sum of rest)
• sum_list([1,2,3]) = 1 + sum_list([2,3])
• Evaluates: 1 + 2 + 3 + 0 = 6

How it works:
• sum_list([1,2,3]) calls 1 + sum_list([2,3])
• sum_list([2,3]) calls 2 + sum_list([3])
• sum_list([3]) calls 3 + sum_list([])
• sum_list([]) returns 0 (base case: empty list)
• Unwinds: 3 + 0 = 3, 2 + 3 = 5, 1 + 5 = 6
• Returns: 6

Example:
def sum_list(lst): return 0 if not lst else lst[0] + sum_list(lst[1:])
sum_list([1,2,3])           # 6 (1 + 2 + 3)
sum_list([10, 20])          # 30 (10 + 20)
sum_list([])                # 0 (base case)

Common uses:
• Recursive sum: def sum_list(lst): return base if empty else first + recursive
• List processing: def process(lst): return process(lst[1:])
• Recursive algorithms
• List reduction

Example: If def sum_list(lst): return 0 if not lst else lst[0] + sum_list(lst[1:]); sum_list([1,2,3]), then sum_list([1,2,3]) returns 6 because the recursive function sums list elements by adding the first element to the sum of the rest: 1 + 2 + 3 = 6.
`
  }),
  (_i: number) => ({ 
    q: `What is def power(x, n): return 1 if n == 0 else x * power(x, n-1); power(2, 3)?`, 
    o: ["8", "6", "Error", "None"], 
    c: 0, 
    e: "Recursive power function.",
    de: `A recursive power function computes x raised to the power n by multiplying x by x raised to the power (n-1). If def power(x, n): return 1 if n == 0 else x * power(x, n-1); power(2, 3), then power(2, 3) returns 8 because power(2, 3) = 2 * power(2, 2) = 2 * (2 * power(2, 1)) = 2 * 2 * (2 * power(2, 0)) = 2 * 2 * 2 * 1 = 8. The base case is n == 0, which returns 1 (any number to the power 0 is 1). The recursive case multiplies x by power(x, n-1).

Recursive power:
• def power(x, n): return 1 if n == 0 else x * power(x, n-1); power(2, 3) returns 8
• Base case: n == 0 returns 1 (x^0 = 1)
• Recursive case: x * power(x, n-1) (multiply x by x^(n-1))
• power(2, 3) = 2 * power(2, 2) = 2 * 2 * power(2, 1) = 2 * 2 * 2 * 1
• Evaluates: 2 * 2 * 2 * 1 = 8

How it works:
• power(2, 3) calls 2 * power(2, 2)
• power(2, 2) calls 2 * power(2, 1)
• power(2, 1) calls 2 * power(2, 0)
• power(2, 0) returns 1 (base case: n == 0)
• Unwinds: 2 * 1 = 2, 2 * 2 = 4, 2 * 4 = 8
• Returns: 8

Example:
def power(x, n): return 1 if n == 0 else x * power(x, n-1)
power(2, 3)                  # 8 (2^3 = 8)
power(3, 2)                  # 9 (3^2 = 9)
power(5, 0)                  # 1 (base case: 5^0 = 1)

Common uses:
• Recursive power: def power(x, n): return base if condition else x * recursive
• Mathematical operations: x^n = x * x^(n-1)
• Recursive algorithms
• Power computation

Example: If def power(x, n): return 1 if n == 0 else x * power(x, n-1); power(2, 3), then power(2, 3) returns 8 because the recursive function computes x^n by multiplying x by x^(n-1) until reaching the base case (n == 0): 2 * 2 * 2 * 1 = 8.
`
  }),
  (_i: number) => ({ 
    q: `What happens if recursive function has no base case?`, 
    o: ["RecursionError (infinite recursion)", "Returns None", "Returns 0", "Error"], 
    c: 0, 
    e: "Missing base case causes infinite recursion.",
    de: `A recursive function without a base case causes infinite recursion, which eventually raises a RecursionError. If a recursive function has no base case (no condition that stops the recursion), it will call itself forever, each call creating a new function call on the call stack. Python has a recursion limit (usually around 1000), so after a certain number of recursive calls, Python raises a RecursionError to prevent stack overflow and program crash. Every recursive function must have a base case that stops the recursion.

Infinite recursion:
• Recursive function without base case causes infinite recursion
• Function calls itself forever
• Each call creates new function call on stack
• Stack grows until recursion limit reached
• Raises RecursionError (prevents stack overflow)

How it works:
• Recursive function calls itself
• No base case to stop recursion
• Function keeps calling itself: func() → func() → func() → ...
• Call stack grows: func() → func() → func() → ...
• Recursion limit reached (usually ~1000)
• Raises RecursionError: maximum recursion depth exceeded

Example:
def func(): return func()  # No base case!
func()                      # RecursionError (infinite recursion)
# Fix: def func(n): return n if n <= 0 else func(n-1)

Common uses:
• Understanding recursion: always need base case
• Preventing errors: ensure base case exists
• Recursion limits
• Stack overflow prevention

Example: A recursive function without a base case causes infinite recursion, which eventually raises a RecursionError because Python has a recursion limit to prevent stack overflow. Every recursive function must have a base case that stops the recursion.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return func(); func()?`, 
    o: ["RecursionError", "None", "Error", "0"], 
    c: 0, 
    e: "Infinite recursion without base case.",
    de: `A recursive function that calls itself without a base case causes infinite recursion. If def func(): return func(); func(), then func() raises a RecursionError because func() calls func(), which calls func(), which calls func(), etc., with no condition to stop. Each recursive call adds a new frame to the call stack. When the recursion limit is reached (usually around 1000), Python raises a RecursionError: maximum recursion depth exceeded. This is a common error when writing recursive functions without proper base cases.

Infinite recursion example:
• def func(): return func(); func() raises RecursionError
• func() calls func() (no base case)
• func() calls func() again (no base case)
• Continues forever: func() → func() → func() → ...
• Call stack grows until limit reached
• Raises RecursionError

How it works:
• func() calls function func
• Function executes: return func()
• Calls func() again (recursive call)
• func() calls func() again (recursive call)
• Continues: func() → func() → func() → ...
• Recursion limit reached (~1000)
• Raises RecursionError: maximum recursion depth exceeded

Example:
def func(): return func()  # No base case!
func()                      # RecursionError: maximum recursion depth exceeded
# Fix: def func(n): return n if n <= 0 else func(n-1)

Common uses:
• Understanding recursion errors: need base case
• Debugging recursion: check for base case
• Recursion limits
• Infinite recursion prevention

Example: If def func(): return func(); func(), then func() raises a RecursionError because the function calls itself infinitely without a base case to stop the recursion, eventually hitting Python's recursion limit.
`
  }),
  (_i: number) => ({ 
    q: `What is def reverse(s): return '' if not s else reverse(s[1:]) + s[0]; reverse('abc')?`, 
    o: ["'cba'", "'abc'", "Error", "None"], 
    c: 0, 
    e: "Recursive string reversal.",
    de: `A recursive function can reverse a string by taking the reverse of the rest and appending the first character. If def reverse(s): return '' if not s else reverse(s[1:]) + s[0]; reverse('abc'), then reverse('abc') returns 'cba' because reverse('abc') = reverse('bc') + 'a' = (reverse('c') + 'b') + 'a' = ((reverse('') + 'c') + 'b') + 'a' = ('' + 'c' + 'b') + 'a' = 'cba'. The base case is an empty string, which returns ''. The recursive case reverses the substring (s[1:]) and appends the first character (s[0]).

Recursive string reversal:
• def reverse(s): return '' if not s else reverse(s[1:]) + s[0]; reverse('abc') returns 'cba'
• Base case: not s returns '' (empty string)
• Recursive case: reverse(s[1:]) + s[0] (reverse rest + first char)
• reverse('abc') = reverse('bc') + 'a' = reverse('c') + 'b' + 'a' = ...
• Evaluates: '' + 'c' + 'b' + 'a' = 'cba'

How it works:
• reverse('abc') calls reverse('bc') + 'a'
• reverse('bc') calls reverse('c') + 'b'
• reverse('c') calls reverse('') + 'c'
• reverse('') returns '' (base case: empty string)
• Unwinds: '' + 'c' = 'c', 'c' + 'b' = 'cb', 'cb' + 'a' = 'cba'
• Returns: 'cba'

Example:
def reverse(s): return '' if not s else reverse(s[1:]) + s[0]
reverse('abc')               # 'cba' (reversed)
reverse('hello')             # 'olleh' (reversed)
reverse('')                  # '' (base case)

Common uses:
• Recursive reversal: def reverse(s): return base if empty else recursive + first
• String processing: def process(s): return process(s[1:]) + transform(s[0])
• Recursive algorithms
• String manipulation

Example: If def reverse(s): return '' if not s else reverse(s[1:]) + s[0]; reverse('abc'), then reverse('abc') returns 'cba' because the recursive function reverses the string by reversing the rest and appending the first character: '' + 'c' + 'b' + 'a' = 'cba'.
`
  }),
  (_i: number) => ({ 
    q: `What is def gcd(a, b): return a if b == 0 else gcd(b, a % b); gcd(48, 18)?`, 
    o: ["6", "48", "18", "Error"], 
    c: 0, 
    e: "Recursive greatest common divisor (Euclidean algorithm).",
    de: `The Euclidean algorithm computes the greatest common divisor (GCD) recursively. If def gcd(a, b): return a if b == 0 else gcd(b, a % b); gcd(48, 18), then gcd(48, 18) returns 6 because gcd(48, 18) = gcd(18, 48 % 18) = gcd(18, 12) = gcd(12, 18 % 12) = gcd(12, 6) = gcd(6, 12 % 6) = gcd(6, 0) = 6. The base case is b == 0, which returns a (the GCD). The recursive case computes gcd(b, a % b), where a % b is the remainder when a is divided by b.

Recursive GCD (Euclidean algorithm):
• def gcd(a, b): return a if b == 0 else gcd(b, a % b); gcd(48, 18) returns 6
• Base case: b == 0 returns a (GCD found)
• Recursive case: gcd(b, a % b) (GCD of b and remainder)
• gcd(48, 18) = gcd(18, 12) = gcd(12, 6) = gcd(6, 0) = 6
• Evaluates: GCD of 48 and 18 is 6

How it works:
• gcd(48, 18) calls gcd(18, 48 % 18) = gcd(18, 12)
• gcd(18, 12) calls gcd(12, 18 % 12) = gcd(12, 6)
• gcd(12, 6) calls gcd(6, 12 % 6) = gcd(6, 0)
• gcd(6, 0) returns 6 (base case: b == 0)
• Returns: 6

Example:
def gcd(a, b): return a if b == 0 else gcd(b, a % b)
gcd(48, 18)                 # 6 (GCD of 48 and 18)
gcd(100, 25)                # 25 (GCD of 100 and 25)
gcd(17, 13)                 # 1 (GCD of 17 and 13)

Common uses:
• Recursive GCD: def gcd(a, b): return a if b == 0 else gcd(b, a % b)
• Euclidean algorithm: GCD(a, b) = GCD(b, a % b)
• Recursive algorithms
• Mathematical algorithms

Example: If def gcd(a, b): return a if b == 0 else gcd(b, a % b); gcd(48, 18), then gcd(48, 18) returns 6 because the recursive Euclidean algorithm computes the GCD by repeatedly taking the GCD of b and the remainder (a % b) until b becomes 0, at which point a is the GCD.
`
  }),
  (_i: number) => ({ 
    q: `What is def length(lst): return 0 if not lst else 1 + length(lst[1:]); length([1,2,3])?`, 
    o: ["3", "0", "Error", "None"], 
    c: 0, 
    e: "Recursive function calculating list length.",
    de: `A recursive function can calculate list length by adding 1 for each element. If def length(lst): return 0 if not lst else 1 + length(lst[1:]); length([1,2,3]), then length([1,2,3]) returns 3 because length([1,2,3]) = 1 + length([2,3]) = 1 + (1 + length([3])) = 1 + 1 + (1 + length([])) = 1 + 1 + 1 + 0 = 3. The base case is an empty list, which returns 0 (length 0). The recursive case adds 1 for the first element and recursively computes the length of the rest of the list.

Recursive length:
• def length(lst): return 0 if not lst else 1 + length(lst[1:]); length([1,2,3]) returns 3
• Base case: not lst returns 0 (empty list length 0)
• Recursive case: 1 + length(lst[1:]) (add 1 for first, length of rest)
• length([1,2,3]) = 1 + length([2,3]) = 1 + 1 + length([3]) = 1 + 1 + 1 + 0
• Evaluates: 1 + 1 + 1 + 0 = 3

How it works:
• length([1,2,3]) calls 1 + length([2,3])
• length([2,3]) calls 1 + length([3])
• length([3]) calls 1 + length([])
• length([]) returns 0 (base case: empty list)
• Unwinds: 1 + 0 = 1, 1 + 1 = 2, 1 + 2 = 3
• Returns: 3

Example:
def length(lst): return 0 if not lst else 1 + length(lst[1:])
length([1,2,3])             # 3 (length of list)
length([10, 20, 30, 40])    # 4 (length of list)
length([])                  # 0 (base case)

Common uses:
• Recursive length: def length(lst): return base if empty else 1 + recursive
• List processing: def process(lst): return process(lst[1:])
• Recursive algorithms
• List reduction

Example: If def length(lst): return 0 if not lst else 1 + length(lst[1:]); length([1,2,3]), then length([1,2,3]) returns 3 because the recursive function counts list elements by adding 1 for the first element and recursively computing the length of the rest: 1 + 1 + 1 + 0 = 3.
`
  }),
  
  // 71-80: Higher-Order Functions
  (_i: number) => ({ 
    q: `What is def apply(func, x): return func(x); apply(lambda x: x*2, 5)?`, 
    o: ["10", "5", "Error", "None"], 
    c: 0, 
    e: "Function that takes another function as parameter.",
    de: `A higher-order function is a function that takes another function as a parameter. If def apply(func, x): return func(x); apply(lambda x: x*2, 5), then apply(lambda x: x*2, 5) returns 10 because apply() is a higher-order function that takes func (a function) as its first parameter and x (a value) as its second parameter, then calls func(x). In this case, it calls lambda x: x*2 with argument 5, which returns 5 * 2 = 10.

Higher-order function:
• def apply(func, x): return func(x); apply(lambda x: x*2, 5) returns 10
• apply() takes function func as parameter
• Takes value x as parameter
• Calls func(x) inside apply()
• Higher-order function (function that takes function)
• Returns result of func(x)

How it works:
• apply(lambda x: x*2, 5) calls function apply
• First argument: lambda x: x*2 (function object)
• Second argument: 5 (value)
• apply() calls func(x): (lambda x: x*2)(5)
• Lambda evaluates: 5 * 2 = 10
• Returns: 10

Example:
def apply(func, x): return func(x)
apply(lambda x: x*2, 5)     # 10 (applies function to value)
apply(lambda x: x**2, 3)    # 9 (applies function to value)
apply(len, 'hello')          # 5 (applies len to string)

Common uses:
• Higher-order functions: def apply(func, x): return func(x)
• Function application: def map(func, items): return [func(x) for x in items]
• Function as parameter
• Higher-order functions

Example: If def apply(func, x): return func(x); apply(lambda x: x*2, 5), then apply(lambda x: x*2, 5) returns 10 because apply() is a higher-order function that takes a function as a parameter and calls it with the value: (lambda x: x*2)(5) = 10.
`
  }),
  (_i: number) => ({ 
    q: `What is def make_multiplier(n): return lambda x: x * n; f = make_multiplier(3); f(4)?`, 
    o: ["12", "3", "4", "Error"], 
    c: 0, 
    e: "Function that returns a function (factory function).",
    de: `A factory function is a function that returns another function. If def make_multiplier(n): return lambda x: x * n; f = make_multiplier(3); f(4), then f(4) returns 12 because make_multiplier(3) returns a lambda function that captures the value n = 3 from the outer function, creating a closure. The returned function f multiplies its argument by 3, so f(4) returns 4 * 3 = 12. This is a common pattern for creating specialized functions.

Factory function:
• def make_multiplier(n): return lambda x: x * n; f = make_multiplier(3); f(4) returns 12
• make_multiplier(3) returns function that captures n = 3
• Returned function multiplies argument by 3
• f = make_multiplier(3) assigns returned function to f
• f(4) calls returned function with 4
• Returns: 4 * 3 = 12

How it works:
• make_multiplier(3) calls function make_multiplier
• Parameter n = 3
• Returns lambda x: x * n (captures n = 3)
• f = lambda x: x * 3 (assigned to f)
• f(4) calls lambda with x = 4
• Evaluates: 4 * 3 = 12
• Returns: 12

Example:
def make_multiplier(n): return lambda x: x * n
f = make_multiplier(3)      # f is lambda x: x * 3
f(4)                        # 12 (4 * 3)
g = make_multiplier(5)      # g is lambda x: x * 5
g(4)                        # 20 (4 * 5)

Common uses:
• Factory functions: def make_adder(n): return lambda x: x + n
• Function factories: def create_function(n): return lambda x: f(x, n)
• Closure creation
• Specialized functions

Example: If def make_multiplier(n): return lambda x: x * n; f = make_multiplier(3); f(4), then f(4) returns 12 because make_multiplier(3) returns a lambda function that captures n = 3 in a closure, creating a function that multiplies its argument by 3: 4 * 3 = 12.
`
  }),
  (_i: number) => ({ 
    q: `What is def compose(f, g): return lambda x: f(g(x)); compose(lambda x: x+1, lambda x: x*2)(3)?`, 
    o: ["7", "6", "8", "Error"], 
    c: 0, 
    e: "Function composition: f(g(x)).",
    de: `Function composition combines two functions into one. If def compose(f, g): return lambda x: f(g(x)); compose(lambda x: x+1, lambda x: x*2)(3), then compose(lambda x: x+1, lambda x: x*2)(3) returns 7 because compose() creates a new function that applies g first, then applies f to the result. So it evaluates g(3) = 3 * 2 = 6, then f(6) = 6 + 1 = 7. Function composition is a fundamental concept in functional programming: f(g(x)) means "apply g, then apply f to the result".

Function composition:
• def compose(f, g): return lambda x: f(g(x)); compose(lambda x: x+1, lambda x: x*2)(3) returns 7
• compose() combines two functions
• Returns new function: lambda x: f(g(x))
• Applies g first: g(x), then applies f: f(g(x))
• Evaluates: f(g(3)) = f(6) = 7

How it works:
• compose(lambda x: x+1, lambda x: x*2) creates composed function
• f = lambda x: x+1 (adds 1)
• g = lambda x: x*2 (multiplies by 2)
• compose() returns lambda x: f(g(x))
• compose(..., ...)(3) calls with x = 3
• Evaluates: g(3) = 3 * 2 = 6, then f(6) = 6 + 1 = 7
• Returns: 7

Example:
def compose(f, g): return lambda x: f(g(x))
compose(lambda x: x+1, lambda x: x*2)(3)  # 7 (f(g(3)) = f(6) = 7)
compose(lambda x: x*2, lambda x: x+1)(3)  # 8 (g(3) = 4, f(4) = 8)

Common uses:
• Function composition: def compose(f, g): return lambda x: f(g(x))
• Combining functions: result = compose(func1, func2)(value)
• Functional programming
• Function chaining

Example: If def compose(f, g): return lambda x: f(g(x)); compose(lambda x: x+1, lambda x: x*2)(3), then compose(...)(3) returns 7 because it applies g first (3 * 2 = 6), then applies f (6 + 1 = 7), so f(g(3)) = f(6) = 7.
`
  }),
  (_i: number) => ({ 
    q: `What is map(lambda x: x*2, [1, 2, 3])?`, 
    o: ["map object", "[2, 4, 6]", "Error", "None"], 
    c: 0, 
    e: "map() returns map object (iterator).",
    de: `The map() function returns a map object (iterator), not a list. map(lambda x: x*2, [1, 2, 3]) returns a map object because map() applies a function to each element of an iterable and returns an iterator that yields the results lazily. The map object is an iterator - it doesn't compute all values immediately, but yields them on-demand when you iterate. To get a list, you need to convert it with list().

map() returns iterator:
• map(lambda x: x*2, [1, 2, 3]) returns map object
• map() applies function to each element
• Returns iterator (lazy evaluation)
• Doesn't compute all values immediately
• Yields values on-demand

How it works:
• map(lambda x: x*2, [1, 2, 3]) creates map object
• map() applies lambda x: x*2 to each element
• Creates iterator that yields: 2, 4, 6
• Iterator doesn't compute until iterated
• Returns map object (iterator)

Example:
map(lambda x: x*2, [1, 2, 3])  # <map object> (iterator)
list(map(lambda x: x*2, [1, 2, 3])) # [2, 4, 6] (converted to list)
for x in map(lambda x: x*2, [1, 2, 3]):  # Iterates: 2, 4, 6
    print(x)

Common uses:
• Mapping: map(func, items) (returns iterator)
• Converting: list(map(func, items)) (converts to list)
• Lazy evaluation
• Iterator creation

Example: map(lambda x: x*2, [1, 2, 3]) returns a map object (iterator) because map() applies the function to each element and returns an iterator that yields results on-demand, not a list.
`
  }),
  (_i: number) => ({ 
    q: `What is list(map(lambda x: x*2, [1, 2, 3]))?`, 
    o: ["[2, 4, 6]", "map object", "Error", "None"], 
    c: 0, 
    e: "list() converts map object to list.",
    de: `The list() function converts a map object (iterator) to a list. list(map(lambda x: x*2, [1, 2, 3])) returns [2, 4, 6] because map() returns a map object that applies lambda x: x*2 to each element of [1, 2, 3], and list() consumes the iterator, collecting all values into a list. The map object yields 2, 4, 6 when iterated, and list() collects them into [2, 4, 6].

list() on map object:
• list(map(lambda x: x*2, [1, 2, 3])) returns [2, 4, 6]
• map() returns map object (iterator)
• list() consumes iterator
• Collects values into list
• Creates list: [2, 4, 6]

How it works:
• map(lambda x: x*2, [1, 2, 3]) creates map object
• map object yields: 2, 4, 6 (when iterated)
• list() iterates through map object
• Collects values: 2, 4, 6
• Returns new list: [2, 4, 6]

Example:
list(map(lambda x: x*2, [1, 2, 3]))  # [2, 4, 6] (converted to list)
list(map(lambda x: x**2, [1, 2, 3])) # [1, 4, 9] (converted to list)
list(map(str, [1, 2, 3]))            # ['1', '2', '3'] (converted to list)

Common uses:
• Converting map to list: list(map(func, items))
• Getting results: results = list(map(transform, data))
• Iterator consumption
• List creation

Example: list(map(lambda x: x*2, [1, 2, 3])) returns [2, 4, 6] because map() returns a map object that yields 2, 4, 6 when iterated, and list() consumes the iterator, collecting all values into a list.
`
  }),
  (_i: number) => ({ 
    q: `What is filter(lambda x: x > 2, [1, 2, 3, 4])?`, 
    o: ["filter object", "[3, 4]", "Error", "None"], 
    c: 0, 
    e: "filter() returns filter object (iterator).",
    de: `The filter() function returns a filter object (iterator), not a list. filter(lambda x: x > 2, [1, 2, 3, 4]) returns a filter object because filter() applies a predicate function to each element of an iterable and returns an iterator that yields only the elements for which the predicate is True. The filter object is an iterator - it doesn't compute all values immediately, but yields them on-demand when you iterate. To get a list, you need to convert it with list().

filter() returns iterator:
• filter(lambda x: x > 2, [1, 2, 3, 4]) returns filter object
• filter() applies predicate function to each element
• Returns iterator (lazy evaluation)
• Yields only elements where predicate is True
• Doesn't compute all values immediately

How it works:
• filter(lambda x: x > 2, [1, 2, 3, 4]) creates filter object
• filter() tests lambda x: x > 2 for each element
• Creates iterator that yields: 3, 4 (where condition is True)
• Iterator doesn't compute until iterated
• Returns filter object (iterator)

Example:
filter(lambda x: x > 2, [1, 2, 3, 4])  # <filter object> (iterator)
list(filter(lambda x: x > 2, [1, 2, 3, 4])) # [3, 4] (converted to list)
for x in filter(lambda x: x > 2, [1, 2, 3, 4]):  # Iterates: 3, 4
    print(x)

Common uses:
• Filtering: filter(predicate, items) (returns iterator)
• Converting: list(filter(predicate, items)) (converts to list)
• Lazy evaluation
• Iterator creation

Example: filter(lambda x: x > 2, [1, 2, 3, 4]) returns a filter object (iterator) because filter() applies the predicate function to each element and returns an iterator that yields only the elements where the predicate is True (3 and 4), not a list.
`
  }),
  (_i: number) => ({ 
    q: `What is list(filter(lambda x: x > 2, [1, 2, 3, 4]))?`, 
    o: ["[3, 4]", "filter object", "Error", "None"], 
    c: 0, 
    e: "list() converts filter object to list.",
    de: `The list() function converts a filter object (iterator) to a list. list(filter(lambda x: x > 2, [1, 2, 3, 4])) returns [3, 4] because filter() returns a filter object that applies lambda x: x > 2 to each element of [1, 2, 3, 4], and list() consumes the iterator, collecting only the elements where the predicate is True into a list. The filter object yields 3, 4 when iterated (only elements where x > 2 is True), and list() collects them into [3, 4].

list() on filter object:
• list(filter(lambda x: x > 2, [1, 2, 3, 4])) returns [3, 4]
• filter() returns filter object (iterator)
• list() consumes iterator
• Collects filtered values into list
• Creates list: [3, 4]

How it works:
• filter(lambda x: x > 2, [1, 2, 3, 4]) creates filter object
• filter object yields: 3, 4 (where x > 2 is True)
• list() iterates through filter object
• Collects values: 3, 4
• Returns new list: [3, 4]

Example:
list(filter(lambda x: x > 2, [1, 2, 3, 4]))  # [3, 4] (converted to list)
list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4])) # [2, 4] (converted to list)
list(filter(lambda x: len(x) > 3, ['a', 'ab', 'abc', 'abcd'])) # ['abcd'] (converted to list)

Common uses:
• Converting filter to list: list(filter(predicate, items))
• Getting filtered results: results = list(filter(condition, data))
• Iterator consumption
• List creation

Example: list(filter(lambda x: x > 2, [1, 2, 3, 4])) returns [3, 4] because filter() returns a filter object that yields only elements where x > 2 is True (3 and 4), and list() consumes the iterator, collecting them into a list.
`
  }),
  (_i: number) => ({ 
    q: `What is from functools import reduce; reduce(lambda x, y: x + y, [1, 2, 3, 4])?`, 
    o: ["10", "4", "Error", "None"], 
    c: 0, 
    e: "reduce() accumulates values using function.",
    de: `The reduce() function from functools accumulates values by applying a function cumulatively to elements. from functools import reduce; reduce(lambda x, y: x + y, [1, 2, 3, 4]) returns 10 because reduce() applies lambda x, y: x + y cumulatively: first it adds 1 + 2 = 3, then 3 + 3 = 6, then 6 + 4 = 10. reduce() takes a function and an iterable, and repeatedly applies the function to the accumulated result and the next element, reducing the iterable to a single value.

reduce() function:
• from functools import reduce; reduce(lambda x, y: x + y, [1, 2, 3, 4]) returns 10
• reduce() accumulates values using function
• Applies function cumulatively: (1+2) → 3, (3+3) → 6, (6+4) → 10
• Reduces iterable to single value
• Returns accumulated result: 10

How it works:
• reduce(lambda x, y: x + y, [1, 2, 3, 4]) starts with first two elements
• First: 1 + 2 = 3 (accumulated result)
• Second: 3 + 3 = 6 (accumulated result)
• Third: 6 + 4 = 10 (accumulated result)
• Returns: 10

Example:
from functools import reduce
reduce(lambda x, y: x + y, [1, 2, 3, 4])  # 10 (1+2+3+4)
reduce(lambda x, y: x * y, [1, 2, 3, 4])  # 24 (1*2*3*4)
reduce(lambda x, y: x if x > y else y, [1, 3, 2, 4]) # 4 (max)

Common uses:
• Accumulating values: reduce(func, items) (reduces to single value)
• Cumulative operations: reduce(lambda x, y: x + y, items)
• Functional reduction
• Iterable reduction

Example: from functools import reduce; reduce(lambda x, y: x + y, [1, 2, 3, 4]) returns 10 because reduce() applies the function cumulatively: (1+2) → 3, (3+3) → 6, (6+4) → 10, reducing the iterable to a single value.
`
  }),
  (_i: number) => ({ 
    q: `What is sorted([3, 1, 2], key=lambda x: -x)?`, 
    o: ["[3, 2, 1]", "[1, 2, 3]", "Error", "None"], 
    c: 0, 
    e: "sorted() with key function for custom sorting.",
    de: `The sorted() function can take a key parameter for custom sorting. sorted([3, 1, 2], key=lambda x: -x) returns [3, 2, 1] because the key function lambda x: -x transforms each element before comparison. Here, key=lambda x: -x negates each element, so comparisons use -3, -1, -2, which sorts as -3 < -1 < -2 (ascending by negated values), resulting in [3, 2, 1] in descending order. The key function doesn't change the elements in the result - it only affects the comparison order.

sorted() with key:
• sorted([3, 1, 2], key=lambda x: -x) returns [3, 2, 1]
• key parameter transforms elements for comparison
• lambda x: -x negates each element
• Sorts using negated values: -3 < -1 < -2
• Result: [3, 2, 1] (descending order)

How it works:
• sorted() called with [3, 1, 2], key=lambda x: -x
• Applies key function: -3, -1, -2 (negated)
• Compares using negated values: -3 < -1 < -2
• Sorts in descending order (because negated)
• Returns new list: [3, 2, 1]

Example:
sorted([3, 1, 2], key=lambda x: -x)  # [3, 2, 1] (descending)
sorted(['abc', 'a', 'ab'], key=len)  # ['a', 'ab', 'abc'] (by length)
sorted([1, 2, 3], key=lambda x: x**2) # [1, 2, 3] (squares: 1 < 4 < 9)

Common uses:
• Custom sorting: sorted(items, key=func)
• Descending sort: sorted(items, key=lambda x: -x)
• Transform-based sorting
• Flexible sorting criteria

Example: sorted([3, 1, 2], key=lambda x: -x) returns [3, 2, 1] because the key function negates each element for comparison, causing the list to be sorted in descending order (largest to smallest).
`
  }),
  (_i: number) => ({ 
    q: `What is max([1, 2, 3], key=lambda x: -x)?`, 
    o: ["1", "3", "Error", "None"], 
    c: 0, 
    e: "max() with key function finds element with max key value.",
    de: `The max() function can take a key parameter to find the element with the maximum transformed value. max([1, 2, 3], key=lambda x: -x) returns 1 because the key function lambda x: -x transforms each element before comparison. Here, key=lambda x: -x negates each element, so comparisons use -1, -2, -3, and max finds the element with the maximum negated value (which is -1, corresponding to element 1). The key function doesn't change the element returned - it only affects the comparison. Since max() returns the original element (not the transformed value), it returns 1.

max() with key:
• max([1, 2, 3], key=lambda x: -x) returns 1
• key parameter transforms elements for comparison
• lambda x: -x negates each element
• Compares using negated values: -1, -2, -3
• max finds maximum negated value: -1 (corresponds to element 1)
• Returns original element: 1

How it works:
• max() called with [1, 2, 3], key=lambda x: -x
• Applies key function: -1, -2, -3 (negated)
• Compares using negated values: -1 > -2 > -3
• max finds element with maximum negated value: -1
• -1 corresponds to original element 1
• Returns original element: 1

Example:
max([1, 2, 3], key=lambda x: -x)  # 1 (max negated value -1)
max(['abc', 'a', 'ab'], key=len)  # 'abc' (max length 3)
min([1, 2, 3], key=lambda x: -x)  # 3 (min negated value -3)

Common uses:
• Custom max: max(items, key=func)
• Transform-based max: max(items, key=lambda x: transform(x))
• Key-based selection
• Flexible comparison

Example: max([1, 2, 3], key=lambda x: -x) returns 1 because the key function negates each element for comparison, and max finds the element with the maximum negated value (-1, which corresponds to original element 1).
`
  }),
  
  // 81-90: Function Attributes and Documentation
  (_i: number) => ({ 
    q: `What is def func(): pass; func.__name__?`, 
    o: ["'func'", "None", "Error", "''"], 
    c: 0, 
    e: "__name__ attribute contains function name.",
    de: `Functions have a __name__ attribute that contains the function's name. If def func(): pass; func.__name__, then func.__name__ returns 'func' because __name__ is a special attribute that stores the function's name as a string. This attribute is automatically set when the function is defined using def. It's useful for debugging, introspection, or creating dynamic code that needs to know function names.

__name__ attribute:
• def func(): pass; func.__name__ returns 'func'
• __name__ contains function name as string
• Automatically set when function defined
• Returns function name: 'func'
• Useful for introspection

How it works:
• def func(): pass creates function definition
• Python automatically sets func.__name__ = 'func'
• __name__ attribute stores function name
• func.__name__ accesses attribute
• Returns: 'func'

Example:
def func(): pass
func.__name__                # 'func' (function name)
def my_function(): pass
my_function.__name__         # 'my_function' (function name)

Common uses:
• Introspection: print(func.__name__) (debugging)
• Dynamic code: code that uses function names
• Function attributes
• Function metadata

Example: If def func(): pass; func.__name__, then func.__name__ returns 'func' because __name__ is a special attribute that stores the function's name as a string, automatically set when the function is defined.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): \"\"\"doc\"\"\"; pass; func.__doc__?`, 
    o: ["'doc'", "None", "Error", "''"], 
    c: 0, 
    e: "__doc__ attribute contains docstring.",
    de: `Functions have a __doc__ attribute that contains the function's docstring (documentation string). If def func(): \"\"\"doc\"\"\"; pass; func.__doc__, then func.__doc__ returns 'doc' because __doc__ is a special attribute that stores the docstring - the string literal that appears as the first statement in the function body. Docstrings are used for documentation and are accessible via __doc__. If there's no docstring, __doc__ is None.

__doc__ attribute:
• def func(): \"\"\"doc\"\"\"; pass; func.__doc__ returns 'doc'
• __doc__ contains docstring (documentation string)
• Docstring is first statement in function body
• Returns docstring: 'doc'
• None if no docstring

How it works:
• def func(): \"\"\"doc\"\"\"; pass creates function definition
• \"\"\"doc\"\"\" is docstring (first statement)
• Python automatically sets func.__doc__ = 'doc'
• __doc__ attribute stores docstring
• func.__doc__ accesses attribute
• Returns: 'doc'

Example:
def func(): \"\"\"doc\"\"\"; pass
func.__doc__                # 'doc' (docstring)
def func(): \"\"\"This is a function.\"\"\"; pass
func.__doc__                # 'This is a function.' (docstring)

Common uses:
• Documentation: def func(): \"\"\"doc\"\"\"; print(func.__doc__)
• Introspection: help(func) uses __doc__
• Function documentation
• Docstring access

Example: If def func(): \"\"\"doc\"\"\"; pass; func.__doc__, then func.__doc__ returns 'doc' because __doc__ is a special attribute that stores the docstring - the documentation string that appears as the first statement in the function body.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): pass; func.__doc__?`, 
    o: ["None", "'func'", "Error", "''"], 
    c: 0, 
    e: "__doc__ is None if no docstring.",
    de: `The __doc__ attribute is None if a function has no docstring. If def func(): pass; func.__doc__, then func.__doc__ returns None because the function has no docstring - there's no string literal as the first statement in the function body. __doc__ only contains a value if a docstring is provided. If there's no docstring, __doc__ is None, not an empty string. This is the default state for functions without documentation.

__doc__ without docstring:
• def func(): pass; func.__doc__ returns None
• Function has no docstring
• __doc__ attribute is None (not empty string)
• Default state for functions without documentation
• Returns None

How it works:
• def func(): pass creates function definition
• No docstring in function body
• Python sets func.__doc__ = None (default)
• __doc__ attribute is None
• func.__doc__ accesses attribute
• Returns: None

Example:
def func(): pass
func.__doc__                # None (no docstring)
def func(): \"\"\"doc\"\"\"; pass
func.__doc__                # 'doc' (has docstring)
def func(): x = 1; return x
func.__doc__                # None (no docstring)

Common uses:
• Checking docstring: if func.__doc__: print(func.__doc__)
• Documentation check: has_doc = func.__doc__ is not None
• Function documentation
• Docstring checking

Example: If def func(): pass; func.__doc__, then func.__doc__ returns None because the function has no docstring, so __doc__ is None (the default state for functions without documentation).
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y=2): pass; func.__defaults__?`, 
    o: ["(2,)", "None", "Error", "()"], 
    c: 0, 
    e: "__defaults__ contains tuple of default values.",
    de: `Functions have a __defaults__ attribute that contains a tuple of default parameter values. If def func(x, y=2): pass; func.__defaults__, then func.__defaults__ returns (2,) because __defaults__ stores default parameter values in a tuple, ordered from left to right for parameters with defaults. Only parameters with default values are included, in the order they appear. In this case, y=2 has a default value, so __defaults__ = (2,).

__defaults__ attribute:
• def func(x, y=2): pass; func.__defaults__ returns (2,)
• __defaults__ contains tuple of default values
• Only parameters with defaults included
• Ordered from left to right
• Returns tuple: (2,)

How it works:
• def func(x, y=2): pass creates function definition
• Parameter x has no default (not in __defaults__)
• Parameter y has default value 2 (in __defaults__)
• Python sets func.__defaults__ = (2,)
• __defaults__ tuple contains: (2,)
• Returns: (2,)

Example:
def func(x, y=2): pass
func.__defaults__           # (2,) (only y has default)
def func(x, y=2, z=3): pass
func.__defaults__           # (2, 3) (y and z have defaults)
def func(x): pass
func.__defaults__           # None (no defaults)

Common uses:
• Introspection: print(func.__defaults__) (check defaults)
• Default values: defaults = func.__defaults__
• Function attributes
• Default parameter access

Example: If def func(x, y=2): pass; func.__defaults__, then func.__defaults__ returns (2,) because __defaults__ contains a tuple of default parameter values, and only y has a default value of 2.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(*args, **kwargs): pass; func.__code__?`, 
    o: ["Code object", "None", "Error", "()"], 
    c: 0, 
    e: "__code__ contains function's code object.",
    de: `Functions have a __code__ attribute that contains the function's code object. If def func(*args, **kwargs): pass; func.__code__, then func.__code__ returns a code object because __code__ is a special attribute that stores the compiled bytecode and other metadata about the function's code. The code object contains information like the number of arguments, variable names, constants, etc. It's an internal Python object used for execution and introspection.

__code__ attribute:
• def func(*args, **kwargs): pass; func.__code__ returns code object
• __code__ contains function's code object
• Code object stores compiled bytecode
• Contains metadata: arguments, variables, constants
• Internal Python object

How it works:
• def func(*args, **kwargs): pass creates function definition
• Python compiles function body to bytecode
• Creates code object with bytecode and metadata
• Python sets func.__code__ = code_object
• __code__ attribute stores code object
• func.__code__ accesses attribute
• Returns: code object

Example:
def func(*args, **kwargs): pass
func.__code__               # <code object> (code object)
func.__code__.co_argcount   # 0 (number of arguments)
func.__code__.co_varnames   # ('args', 'kwargs') (variable names)

Common uses:
• Introspection: func.__code__.co_varnames (variable names)
• Code inspection: func.__code__.co_consts (constants)
• Function internals
• Bytecode access

Example: If def func(*args, **kwargs): pass; func.__code__, then func.__code__ returns a code object because __code__ is a special attribute that stores the compiled bytecode and metadata about the function's code.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): pass; callable(func)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "callable() checks if object is callable.",
    de: `The callable() function checks if an object is callable (can be called like a function). If def func(): pass; callable(func), then callable(func) returns True because func is a function object, and functions are callable. callable() returns True for functions, methods, classes (which are callable to create instances), and any object that implements __call__. It returns False for non-callable objects like integers, strings, lists, etc.

callable() function:
• def func(): pass; callable(func) returns True
• callable() checks if object is callable
• Functions are callable
• Returns True for callable objects
• Returns False for non-callable objects

How it works:
• def func(): pass creates function object
• func is a function (callable)
• callable(func) checks if func is callable
• Functions are callable (can be called)
• Returns: True

Example:
def func(): pass
callable(func)              # True (functions are callable)
callable(5)                 # False (integers are not callable)
callable(str)               # True (classes are callable)

Common uses:
• Checking callable: if callable(obj): obj()
• Type checking: is_callable = callable(item)
• Callable check
• Object inspection

Example: If def func(): pass; callable(func), then callable(func) returns True because functions are callable objects - they can be called with parentheses like func().
`
  }),
  (_i: number) => ({ 
    q: `What is callable(5)?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Integer is not callable.",
    de: `Integers are not callable objects. callable(5) returns False because integers cannot be called like functions - you cannot use 5() to call an integer. callable() returns True only for objects that can be called (like functions, methods, classes), and returns False for non-callable objects like integers, strings, lists, dictionaries, etc. This is useful for checking if an object is a function before trying to call it.

callable() on integer:
• callable(5) returns False
• Integers are not callable
• Cannot call integer: 5() raises TypeError
• callable() returns False for non-callable objects
• Returns False

How it works:
• callable(5) checks if 5 is callable
• 5 is an integer (not callable)
• Integers cannot be called like functions
• Cannot use 5() (raises TypeError)
• Returns: False

Example:
callable(5)                 # False (integers not callable)
callable('hello')           # False (strings not callable)
callable([1, 2, 3])         # False (lists not callable)
callable(lambda x: x)       # True (functions callable)

Common uses:
• Type checking: if callable(obj): obj() else use obj
• Safe calling: callable(func) and func()
• Callable check
• Object inspection

Example: callable(5) returns False because integers are not callable objects - you cannot call an integer like a function, so callable() returns False for non-callable objects like integers.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): return 1; type(func)?`, 
    o: ["<class 'function'>", "<class 'type'>", "Error", "None"], 
    c: 0, 
    e: "Functions are of type function.",
    de: `The type() function returns the type of an object. If def func(): return 1; type(func), then type(func) returns <class 'function'> because func is a function object, and functions are of type function. The type() function returns the class/type of an object, and for functions, it returns the function class. This is useful for type checking or introspection to determine if an object is a function.

type() on function:
• def func(): return 1; type(func) returns <class 'function'>
• type() returns object's type
• Functions are of type function
• Returns function class
• Useful for type checking

How it works:
• def func(): return 1 creates function object
• func is a function object
• type(func) checks type of func
• Functions are of type function
• Returns: <class 'function'>

Example:
def func(): return 1
type(func)                  # <class 'function'> (function type)
type(5)                     # <class 'int'> (integer type)
type('hello')               # <class 'str'> (string type)

Common uses:
• Type checking: if type(obj) == type(lambda: None): ...
• Type inspection: print(type(func))
• Object type
• Type identification

Example: If def func(): return 1; type(func), then type(func) returns <class 'function'> because functions are of type function, and type() returns the class/type of the object.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): pass; hasattr(func, '__name__')?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "hasattr() checks if object has attribute.",
    de: `The hasattr() function checks if an object has a specific attribute. If def func(): pass; hasattr(func, '__name__'), then hasattr(func, '__name__') returns True because functions have a __name__ attribute. hasattr(obj, attr) returns True if the object has the attribute (whether it's defined or inherited), and False otherwise. It's useful for checking if an attribute exists before accessing it to avoid AttributeError.

hasattr() function:
• def func(): pass; hasattr(func, '__name__') returns True
• hasattr() checks if object has attribute
• Functions have __name__ attribute
• Returns True if attribute exists
• Returns False if attribute doesn't exist

How it works:
• def func(): pass creates function object
• Functions have __name__ attribute automatically
• hasattr(func, '__name__') checks if __name__ exists
• Attribute exists (functions have __name__)
• Returns: True

Example:
def func(): pass
hasattr(func, '__name__')   # True (functions have __name__)
hasattr(func, '__doc__')    # True (functions have __doc__)
hasattr(5, '__name__')      # False (integers don't have __name__)

Common uses:
• Attribute checking: if hasattr(obj, 'attr'): use obj.attr
• Safe access: hasattr(func, '__doc__') and func.__doc__
• Attribute existence
• Object inspection

Example: If def func(): pass; hasattr(func, '__name__'), then hasattr(func, '__name__') returns True because functions have a __name__ attribute, and hasattr() checks if an object has a specific attribute.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(): pass; func.attr = 'value'; func.attr?`, 
    o: ["'value'", "None", "Error", "''"], 
    c: 0, 
    e: "Functions can have custom attributes.",
    de: `Functions can have custom attributes assigned to them. If def func(): pass; func.attr = 'value'; func.attr, then func.attr returns 'value' because you can assign custom attributes to function objects just like any other Python object. Functions are objects, so they can have attributes. After assigning func.attr = 'value', the attribute 'attr' exists on the function object and can be accessed like any other attribute. This is useful for storing metadata or state associated with a function.

Custom function attributes:
• def func(): pass; func.attr = 'value'; func.attr returns 'value'
• Functions can have custom attributes
• Assignment: func.attr = 'value' creates attribute
• Access: func.attr retrieves attribute value
• Functions are objects (can have attributes)

How it works:
• def func(): pass creates function object
• func.attr = 'value' assigns custom attribute
• Attribute 'attr' created on function object
• func.attr accesses attribute
• Returns: 'value'

Example:
def func(): pass
func.attr = 'value'         # Assigns custom attribute
func.attr                   # 'value' (accesses attribute)
func.count = 0              # Assigns another attribute
func.count                  # 0 (accesses attribute)

Common uses:
• Storing metadata: func.metadata = {'author': 'Alice'}
• Function state: func.call_count = 0 (tracking)
• Custom attributes
• Function metadata

Example: If def func(): pass; func.attr = 'value'; func.attr, then func.attr returns 'value' because functions can have custom attributes assigned to them, and func.attr = 'value' creates the attribute, which can then be accessed.
`
  }),
  
  // 91-100: Advanced Function Features
  (_i: number) => ({ 
    q: `What is def func(x): return x; func.__annotations__?`, 
    o: ["{}", "None", "Error", "()"], 
    c: 0, 
    e: "__annotations__ contains type hints (empty if none).",
    de: `Functions have a __annotations__ attribute that contains type hints (type annotations). If def func(x): return x; func.__annotations__, then func.__annotations__ returns {} because the function has no type hints, so __annotations__ is an empty dictionary. Type hints are optional annotations that indicate the expected types of parameters and return values, written using : for parameters and -> for return types. If there are no type hints, __annotations__ is an empty dictionary.

__annotations__ without type hints:
• def func(x): return x; func.__annotations__ returns {}
• __annotations__ contains type hints as dictionary
• No type hints in function (empty dict)
• Default state: {} (empty dictionary)
• Returns: {}

How it works:
• def func(x): return x creates function definition
• No type hints provided (no : or ->)
• Python sets func.__annotations__ = {} (empty dict)
• __annotations__ attribute stores type hints
• func.__annotations__ accesses attribute
• Returns: {}

Example:
def func(x): return x
func.__annotations__       # {} (empty, no type hints)
def func(x: int): return x
func.__annotations__       # {'x': <class 'int'>} (has type hints)

Common uses:
• Type hints: def func(x: int) -> int: (has annotations)
• Type checking: def func(x): (no annotations, {} empty)
• Function annotations
• Type hint access

Example: If def func(x): return x; func.__annotations__, then func.__annotations__ returns {} because the function has no type hints, so __annotations__ is an empty dictionary (the default state).
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x: int) -> int: return x; func.__annotations__?`, 
    o: ["{'x': <class 'int'>, 'return': <class 'int'>}", "{}", "Error", "None"], 
    c: 0, 
    e: "__annotations__ contains type hints.",
    de: `Functions with type hints have them stored in __annotations__. If def func(x: int) -> int: return x; func.__annotations__, then func.__annotations__ returns {'x': <class 'int'>, 'return': <class 'int'>} because __annotations__ stores type hints as a dictionary where keys are parameter names (like 'x') or 'return' for the return type, and values are the type annotations. Type hints are optional but useful for documentation and type checking tools.

__annotations__ with type hints:
• def func(x: int) -> int: return x; func.__annotations__ returns {'x': <class 'int'>, 'return': <class 'int'>}
• __annotations__ contains type hints as dictionary
• 'x': <class 'int'> (parameter type hint)
• 'return': <class 'int'> (return type hint)
• Returns dictionary of annotations

How it works:
• def func(x: int) -> int: return x creates function definition
• x: int is parameter type hint
• -> int is return type hint
• Python sets func.__annotations__ = {'x': int, 'return': int}
• __annotations__ attribute stores type hints
• func.__annotations__ accesses attribute
• Returns: {'x': <class 'int'>, 'return': <class 'int'>}

Example:
def func(x: int) -> int: return x
func.__annotations__       # {'x': <class 'int'>, 'return': <class 'int'>}
def func(x: str, y: int) -> str: return x
func.__annotations__       # {'x': <class 'str'>, 'y': <class 'int'>, 'return': <class 'str'>}

Common uses:
• Type hints: def func(x: int) -> int: (annotations)
• Type checking: type hints for static analysis
• Function documentation
• Type hint access

Example: If def func(x: int) -> int: return x; func.__annotations__, then func.__annotations__ returns {'x': <class 'int'>, 'return': <class 'int'>} because __annotations__ stores type hints as a dictionary where 'x' maps to the parameter type and 'return' maps to the return type.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y): return x + y; func(1, 2, 3)?`, 
    o: ["TypeError", "6", "Error", "None"], 
    c: 0, 
    e: "Too many arguments raises TypeError.",
    de: `Calling a function with too many arguments raises a TypeError. If def func(x, y): return x + y; func(1, 2, 3), then func(1, 2, 3) raises a TypeError because the function expects 2 arguments (x and y), but 3 arguments (1, 2, 3) are provided. Python requires that the number of arguments matches the number of parameters (unless using *args or default parameters). Too many or too few arguments causes a TypeError.

Too many arguments:
• def func(x, y): return x + y; func(1, 2, 3) raises TypeError
• Function expects 2 arguments (x and y)
• 3 arguments provided (1, 2, 3)
• Too many arguments
• Raises TypeError: func() takes 2 positional arguments but 3 were given

How it works:
• func(1, 2, 3) calls function func
• Function expects 2 arguments (x, y)
• 3 arguments provided: 1, 2, 3
• First two arguments assigned: x=1, y=2
• Third argument 3 has no corresponding parameter
• Raises TypeError

Example:
def func(x, y): return x + y
func(1, 2, 3)              # TypeError: func() takes 2 positional arguments but 3 were given
func(1, 2)                 # 3 (correct number of arguments)

Common uses:
• Understanding errors: too many arguments raises TypeError
• Argument validation: ensure correct number of arguments
• Function calls
• Error handling

Example: If def func(x, y): return x + y; func(1, 2, 3), then func(1, 2, 3) raises a TypeError because the function expects 2 arguments but 3 are provided, causing an error.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y): return x + y; func(1)?`, 
    o: ["TypeError", "1", "Error", "None"], 
    c: 0, 
    e: "Too few arguments raises TypeError.",
    de: `Calling a function with too few arguments raises a TypeError. If def func(x, y): return x + y; func(1), then func(1) raises a TypeError because the function expects 2 arguments (x and y), but only 1 argument (1) is provided. Python requires that all required parameters (parameters without default values) receive arguments. Too few arguments means some required parameters are missing, causing a TypeError.

Too few arguments:
• def func(x, y): return x + y; func(1) raises TypeError
• Function expects 2 arguments (x and y)
• Only 1 argument provided (1)
• Too few arguments
• Raises TypeError: func() missing 1 required positional argument: 'y'

How it works:
• func(1) calls function func
• Function expects 2 arguments (x, y)
• Only 1 argument provided: 1
• First argument assigned: x=1
• Second parameter y has no argument
• Raises TypeError

Example:
def func(x, y): return x + y
func(1)                     # TypeError: func() missing 1 required positional argument: 'y'
func(1, 2)                  # 3 (correct number of arguments)

Common uses:
• Understanding errors: too few arguments raises TypeError
• Argument validation: ensure all required arguments provided
• Function calls
• Error handling

Example: If def func(x, y): return x + y; func(1), then func(1) raises a TypeError because the function expects 2 arguments but only 1 is provided, causing an error for the missing required parameter y.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y, z): return x + y + z; func(1, z=3, y=2)?`, 
    o: ["6", "Error", "None", "5"], 
    c: 0, 
    e: "Keyword arguments can be in any order after positional.",
    de: `Keyword arguments can be in any order after positional arguments. If def func(x, y, z): return x + y + z; func(1, z=3, y=2), then func(1, z=3, y=2) returns 6 because 1 is passed positionally to x, and z=3 and y=2 are keyword arguments that can be in any order. Keyword arguments don't need to match the parameter order - they're matched by name, not position. So z=3 and y=2 can be in any order as long as they come after positional arguments.

Keyword argument order:
• def func(x, y, z): return x + y + z; func(1, z=3, y=2) returns 6
• 1 is positional argument (goes to x)
• z=3 and y=2 are keyword arguments (order doesn't matter)
• Keyword arguments matched by name, not position
• Returns: 1 + 2 + 3 = 6

How it works:
• func(1, z=3, y=2) calls function func
• First argument 1 is positional, assigned to x: x=1
• z=3 is keyword argument, assigned to z: z=3
• y=2 is keyword argument, assigned to y: y=2
• Function executes: return x + y + z
• Returns: 1 + 2 + 3 = 6

Example:
def func(x, y, z): return x + y + z
func(1, z=3, y=2)          # 6 (keyword args in any order)
func(1, y=2, z=3)          # 6 (same, different order)
func(1, 2, 3)              # 6 (all positional)

Common uses:
• Flexible calls: func(pos1, keyword2=value2, keyword3=value3)
• Named arguments: func(value, param2=value2, param3=value3)
• Keyword argument flexibility
• Argument ordering

Example: If def func(x, y, z): return x + y + z; func(1, z=3, y=2), then func(1, z=3, y=2) returns 6 because keyword arguments can be in any order after positional arguments - they're matched by name, not position.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y, z): return x + y + z; func(1, 2, z=3)?`, 
    o: ["6", "Error", "None", "5"], 
    c: 0, 
    e: "Mixed positional and keyword arguments work.",
    de: `You can mix positional and keyword arguments in a function call. If def func(x, y, z): return x + y + z; func(1, 2, z=3), then func(1, 2, z=3) returns 6 because 1 and 2 are passed positionally to x and y, and z=3 is passed as a keyword argument to z. Positional arguments must come before keyword arguments - you cannot have a keyword argument followed by a positional argument. This mixing allows flexibility in function calls.

Mixed arguments:
• def func(x, y, z): return x + y + z; func(1, 2, z=3) returns 6
• 1, 2 are positional arguments (go to x, y)
• z=3 is keyword argument (goes to z)
• Positional before keyword
• Returns: 1 + 2 + 3 = 6

How it works:
• func(1, 2, z=3) calls function func
• First argument 1 is positional, assigned to x: x=1
• Second argument 2 is positional, assigned to y: y=2
• z=3 is keyword argument, assigned to z: z=3
• Function executes: return x + y + z
• Returns: 1 + 2 + 3 = 6

Example:
def func(x, y, z): return x + y + z
func(1, 2, z=3)            # 6 (mixed: pos1, pos2, keyword3)
func(1, z=3, y=2)          # 6 (mixed: pos1, keyword2, keyword3)
func(1, 2, 3)              # 6 (all positional)

Common uses:
• Flexible calls: func(pos1, pos2, keyword3=value)
• Mixed arguments: func(required1, keyword2=value2)
• Positional and keyword mixing
• Function call flexibility

Example: If def func(x, y, z): return x + y + z; func(1, 2, z=3), then func(1, 2, z=3) returns 6 because you can mix positional arguments (1, 2) and keyword arguments (z=3), with positional arguments coming first.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, y, z): return x + y + z; func(1, z=3, 2)?`, 
    o: ["SyntaxError", "6", "Error", "None"], 
    c: 0, 
    e: "Positional arguments cannot come after keyword arguments.",
    de: `Positional arguments cannot come after keyword arguments in a function call. If def func(x, y, z): return x + y + z; func(1, z=3, 2), then func(1, z=3, 2) raises a SyntaxError because the positional argument 2 comes after the keyword argument z=3. Python requires that all positional arguments come before keyword arguments - you cannot have a keyword argument followed by a positional argument. This prevents ambiguity about which parameters get which arguments.

Positional after keyword:
• def func(x, y, z): return x + y + z; func(1, z=3, 2) raises SyntaxError
• 1 is positional argument
• z=3 is keyword argument
• 2 is positional argument (comes after keyword)
• Invalid: positional after keyword
• Raises SyntaxError: positional argument follows keyword argument

How it works:
• func(1, z=3, 2) attempts to call function func
• First argument 1 is positional, assigned to x: x=1
• z=3 is keyword argument, assigned to z: z=3
• 2 is positional argument, but comes after keyword argument
• Invalid syntax (positional after keyword)
• Raises SyntaxError

Example:
def func(x, y, z): return x + y + z
func(1, z=3, 2)            # SyntaxError: positional argument follows keyword argument
func(1, 2, z=3)            # 6 (valid: positional before keyword)

Common uses:
• Understanding syntax: positional before keyword
• Argument ordering: all positional, then all keyword
• Syntax error avoidance
• Function call rules

Example: If def func(x, y, z): return x + y + z; func(1, z=3, 2), then func(1, z=3, 2) raises a SyntaxError because positional arguments cannot come after keyword arguments - all positional arguments must come first.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(*args, x): return args, x; func(1, 2, x=3)?`, 
    o: ["((1, 2), 3)", "Error", "None", "(1, 2, 3)"], 
    c: 0, 
    e: "Keyword-only parameter after *args.",
    de: `Parameters after *args are keyword-only - they can only be passed as keyword arguments. If def func(*args, x): return args, x; func(1, 2, x=3), then func(1, 2, x=3) returns ((1, 2), 3) because *args collects positional arguments (1, 2) into a tuple, and x must be passed as a keyword argument (x=3). Parameters after *args cannot be passed positionally - they're keyword-only parameters. This is enforced by Python's syntax: after *args, all following parameters must be keyword-only.

Keyword-only parameter after *args:
• def func(*args, x): return args, x; func(1, 2, x=3) returns ((1, 2), 3)
• *args collects positional arguments (1, 2)
• x is keyword-only parameter (after *args)
• x must be passed as keyword: x=3
• Returns tuple: (args, x) = ((1, 2), 3)

How it works:
• func(1, 2, x=3) calls function func
• Arguments 1, 2 are positional, collected into *args: args = (1, 2)
• x=3 is keyword argument, assigned to x: x=3
• Function executes: return args, x
• Returns: ((1, 2), 3)

Example:
def func(*args, x): return args, x
func(1, 2, x=3)            # ((1, 2), 3) (x must be keyword)
func(1, 2, 3)              # TypeError (x must be keyword)
func(x=3)                  # ((), 3) (args empty, x keyword)

Common uses:
• Keyword-only parameters: def func(*args, keyword_only): ...
• Forcing keywords: def process(*items, strict=True): ...
• Parameter restrictions
• Keyword-only enforcement

Example: If def func(*args, x): return args, x; func(1, 2, x=3), then func(1, 2, x=3) returns ((1, 2), 3) because *args collects positional arguments (1, 2), and x is a keyword-only parameter (must be passed as x=3) since it comes after *args.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, *, y): return x + y; func(1, y=2)?`, 
    o: ["3", "Error", "None", "1"], 
    c: 0, 
    e: "Parameters after * are keyword-only.",
    de: `Parameters after a bare * are keyword-only - they can only be passed as keyword arguments. If def func(x, *, y): return x + y; func(1, y=2), then func(1, y=2) returns 3 because x is passed positionally (1), and y is passed as a keyword argument (y=2) because it comes after the bare *. The bare * acts as a separator - all parameters after it must be keyword-only. This forces certain parameters to be passed by name, making function calls more explicit.

Keyword-only parameters:
• def func(x, *, y): return x + y; func(1, y=2) returns 3
• x is regular parameter (can be positional)
• * separates parameters
• y is keyword-only parameter (after *)
• y must be passed as keyword: y=2
• Returns: 1 + 2 = 3

How it works:
• func(1, y=2) calls function func
• Argument 1 is positional, assigned to x: x=1
• y=2 is keyword argument, assigned to y: y=2
• y must be keyword (comes after *)
• Function executes: return x + y
• Returns: 1 + 2 = 3

Example:
def func(x, *, y): return x + y
func(1, y=2)                # 3 (y must be keyword)
func(1, 2)                  # TypeError (y must be keyword)
func(x=1, y=2)              # 3 (both keyword, but y required keyword)

Common uses:
• Keyword-only parameters: def process(data, *, strict=True): ...
• Forcing keywords: def create(*, name, value): ... (all keyword-only)
• Parameter restrictions
• Keyword-only enforcement

Example: If def func(x, *, y): return x + y; func(1, y=2), then func(1, y=2) returns 3 because x is passed positionally (1), and y must be passed as a keyword argument (y=2) since it comes after the bare *, making it keyword-only.
`
  }),
  (_i: number) => ({ 
    q: `What is def func(x, /, y, *, z): return x + y + z; func(1, 2, z=3)?`, 
    o: ["6", "Error", "None", "5"], 
    c: 0, 
    e: "Parameters before / are positional-only, after * are keyword-only.",
    de: `Parameters before / are positional-only, and parameters after * are keyword-only. If def func(x, /, y, *, z): return x + y + z; func(1, 2, z=3), then func(1, 2, z=3) returns 6 because x is positional-only (must be passed positionally), y is regular (can be positional or keyword), and z is keyword-only (must be passed as keyword). The / separates positional-only parameters from regular parameters, and * separates regular parameters from keyword-only parameters. This gives fine-grained control over how parameters can be passed.

Positional-only and keyword-only:
• def func(x, /, y, *, z): return x + y + z; func(1, 2, z=3) returns 6
• x is positional-only (before /, must be positional)
• y is regular (between / and *, can be positional or keyword)
• z is keyword-only (after *, must be keyword)
• Returns: 1 + 2 + 3 = 6

How it works:
• func(1, 2, z=3) calls function func
• Argument 1 is positional, assigned to x: x=1 (positional-only)
• Argument 2 is positional, assigned to y: y=2 (regular, can be positional)
• z=3 is keyword argument, assigned to z: z=3 (keyword-only)
• Function executes: return x + y + z
• Returns: 1 + 2 + 3 = 6

Example:
def func(x, /, y, *, z): return x + y + z
func(1, 2, z=3)            # 6 (x positional-only, y regular, z keyword-only)
func(1, y=2, z=3)          # 6 (x positional-only, y keyword, z keyword-only)
func(x=1, 2, z=3)          # TypeError (x cannot be keyword)

Common uses:
• Positional-only: def process(data, /, options): ... (data positional-only)
• Keyword-only: def create(*, name, value): ... (all keyword-only)
• Parameter restrictions
• Fine-grained control

Example: If def func(x, /, y, *, z): return x + y + z; func(1, 2, z=3), then func(1, 2, z=3) returns 6 because x is positional-only (must be positional), y is regular (can be positional or keyword), and z is keyword-only (must be keyword), so 1 and 2 are passed positionally and z=3 is passed as a keyword.
`
  }),
];

// --- LEVEL 8: SHARK (Classes, Objects, Methods) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level8Patterns = [
  // 1-10: Class Definition and Basics
  (_i: number) => ({ 
    q: `What is class MyClass: pass?`, 
    o: ["Defines a class", "Creates an object", "Error", "Defines a function"], 
    c: 0, 
    e: "class defines a class.",
    de: `The class keyword defines a new class. If class MyClass: pass, then this defines a class named MyClass. The class statement creates a class object, which is a blueprint for creating instances (objects). The pass statement is a placeholder that does nothing - it's used when a class body is empty. Classes are fundamental to object-oriented programming in Python, allowing you to define custom types with attributes and methods.

Class definition:
• class MyClass: pass defines a class named MyClass
• class keyword creates class object
• MyClass is the class name
• pass is placeholder (empty body)
• Class is blueprint for creating instances

How it works:
• class MyClass: pass executes class statement
• Python creates class object named MyClass
• Class object stored in namespace
• Can be used to create instances: obj = MyClass()
• Returns: class definition (no return value, creates class)

Example:
class MyClass: pass          # Defines empty class
class Person: pass            # Defines another class
class Animal: pass           # Defines another class

Common uses:
• Class definition: class MyClass: pass (empty class)
• Blueprint: class defines structure for objects
• Object-oriented programming
• Custom types

Example: class MyClass: pass defines a class named MyClass because the class keyword creates a class object, which serves as a blueprint for creating instances (objects) of that class.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1?`, 
    o: ["Defines class with class attribute", "Creates object", "Error", "Defines function"], 
    c: 0, 
    e: "Attributes defined in class body are class attributes.",
    de: `Attributes defined in the class body (outside methods) are class attributes. If class MyClass: x = 1, then this defines a class MyClass with a class attribute x = 1. Class attributes are shared by all instances of the class - they belong to the class itself, not to individual instances. All instances can access class attributes, and modifying a class attribute affects all instances (unless an instance has its own attribute that shadows it).

Class attribute:
• class MyClass: x = 1 defines class with class attribute x = 1
• x = 1 is class attribute (defined in class body)
• Shared by all instances of MyClass
• Accessible via class: MyClass.x
• Accessible via instance: obj.x (if not shadowed)

How it works:
• class MyClass: x = 1 executes class statement
• x = 1 creates class attribute
• Attribute stored in class __dict__
• All instances share this attribute
• Returns: class definition (no return value, creates class)

Example:
class MyClass: x = 1         # Class attribute x = 1
MyClass.x                    # 1 (accessed via class)
obj = MyClass()
obj.x                        # 1 (accessed via instance)

Common uses:
• Class attributes: class MyClass: shared_value = 1
• Shared data: class Counter: count = 0 (shared counter)
• Class-level constants
• Shared state

Example: class MyClass: x = 1 defines a class with a class attribute x = 1 because attributes defined in the class body are class attributes, shared by all instances of the class.
`
  }),
  (_i: number) => ({ 
    q: `What is MyClass = class MyClass: pass?`, 
    o: ["SyntaxError", "Valid class definition", "Error", "None"], 
    c: 0, 
    e: "class statement doesn't use assignment operator.",
    de: `The class statement doesn't use the assignment operator. If MyClass = class MyClass: pass, then this raises a SyntaxError because the class statement has its own syntax - you don't use = to assign the class name. The correct syntax is class MyClass: pass, which automatically creates a variable MyClass in the current namespace. The class keyword itself handles the assignment - you don't need (and can't use) an explicit assignment operator.

Class statement syntax:
• MyClass = class MyClass: pass raises SyntaxError
• class statement doesn't use assignment operator
• Correct syntax: class MyClass: pass
• Class name automatically assigned to variable
• SyntaxError: invalid syntax

How it works:
• MyClass = class MyClass: pass attempts to use assignment
• class statement doesn't support assignment operator
• Python parser expects: class ClassName: body
• Encountered = before class keyword
• Raises SyntaxError: invalid syntax

Example:
class MyClass: pass          # Correct (no =)
MyClass = class MyClass: pass  # SyntaxError (invalid syntax)
# Correct: class MyClass: pass

Common uses:
• Understanding syntax: class statement doesn't use =
• Class definition: class MyClass: pass (correct syntax)
• Syntax errors
• Class statement rules

Example: MyClass = class MyClass: pass raises a SyntaxError because the class statement doesn't use the assignment operator - the class keyword automatically creates the variable with the class name.
`
  }),
  (_i: number) => ({ 
    q: `What is obj = MyClass() if class MyClass: pass?`, 
    o: ["Creates instance of MyClass", "Error", "Calls MyClass", "None"], 
    c: 0, 
    e: "Calling class creates instance (object).",
    de: `Calling a class (using parentheses) creates an instance (object) of that class. If class MyClass: pass, then obj = MyClass() creates an instance of MyClass and assigns it to obj. The parentheses () call the class, which triggers instance creation. Classes are callable - when you call them, they create and return a new instance. This is how objects are created in Python - by calling the class constructor.

Instance creation:
• obj = MyClass() creates instance of MyClass
• MyClass() calls class (creates instance)
• Instance is object of type MyClass
• Assigned to variable obj
• Returns: new instance object

How it works:
• MyClass() calls class MyClass
• Class is callable (can be called)
• Calling class creates new instance
• Instance object created and returned
• Assigned to obj
• Returns: instance object

Example:
class MyClass: pass
obj = MyClass()              # Creates instance
obj2 = MyClass()             # Creates another instance
obj is obj2                  # False (different instances)

Common uses:
• Creating objects: obj = MyClass() (instance creation)
• Object instantiation: instance = ClassName()
• Instance creation
• Object-oriented programming

Example: If class MyClass: pass, then obj = MyClass() creates an instance of MyClass because calling a class (using parentheses) creates and returns a new instance (object) of that class.
`
  }),
  (_i: number) => ({ 
    q: `What is type(MyClass()) if class MyClass: pass?`, 
    o: ["<class '__main__.MyClass'>", "<class 'type'>", "Error", "None"], 
    c: 0, 
    e: "type() returns class of instance.",
    de: `The type() function returns the class (type) of an object. If class MyClass: pass, then type(MyClass()) returns <class '__main__.MyClass'> because MyClass() creates an instance of MyClass, and type() returns the class that the instance belongs to. The output <class '__main__.MyClass'> shows that the instance is of type MyClass, where '__main__' is the module name (the current script).

type() on instance:
• type(MyClass()) returns <class '__main__.MyClass'>
• MyClass() creates instance
• type() returns class of instance
• Returns class object: <class '__main__.MyClass'>
• Shows instance belongs to MyClass class

How it works:
• MyClass() creates instance of MyClass
• type(instance) checks type of instance
• Instance belongs to MyClass class
• Returns class object: <class '__main__.MyClass'>
• '__main__' is module name (current script)

Example:
class MyClass: pass
type(MyClass())              # <class '__main__.MyClass'>
obj = MyClass()
type(obj)                    # <class '__main__.MyClass'>

Common uses:
• Type checking: if type(obj) == MyClass: ...
• Type inspection: print(type(instance))
• Object type
• Type identification

Example: If class MyClass: pass, then type(MyClass()) returns <class '__main__.MyClass'> because type() returns the class that an instance belongs to, and MyClass() creates an instance of MyClass.
`
  }),
  (_i: number) => ({ 
    q: `What is isinstance(MyClass(), MyClass) if class MyClass: pass?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "isinstance() checks if object is instance of class.",
    de: `The isinstance() function checks if an object is an instance of a class (or any of its subclasses). If class MyClass: pass, then isinstance(MyClass(), MyClass) returns True because MyClass() creates an instance of MyClass, and isinstance() checks if that instance is an instance of MyClass (which it is). isinstance() is the recommended way to check types in Python, as it also returns True for subclasses.

isinstance() check:
• isinstance(MyClass(), MyClass) returns True
• MyClass() creates instance of MyClass
• isinstance() checks if instance is of type MyClass
• Instance is of type MyClass
• Returns: True

How it works:
• MyClass() creates instance of MyClass
• isinstance(instance, MyClass) checks type
• Instance is indeed of type MyClass
• Returns: True

Example:
class MyClass: pass
obj = MyClass()
isinstance(obj, MyClass)     # True (obj is instance of MyClass)
isinstance(obj, object)     # True (all classes inherit from object)

Common uses:
• Type checking: if isinstance(obj, MyClass): ...
• Instance validation: isinstance(instance, Class)
• Type checking
• Object validation

Example: If class MyClass: pass, then isinstance(MyClass(), MyClass) returns True because isinstance() checks if an object is an instance of a class, and MyClass() creates an instance of MyClass.
`
  }),
  (_i: number) => ({ 
    q: `What is MyClass.__name__ if class MyClass: pass?`, 
    o: ["'MyClass'", "None", "Error", "''"], 
    c: 0, 
    e: "__name__ attribute contains class name.",
    de: `Classes have a __name__ attribute that contains the class name as a string. If class MyClass: pass, then MyClass.__name__ returns 'MyClass' because __name__ is a special attribute that stores the class's name. This attribute is automatically set when the class is defined. It's useful for introspection, debugging, or creating dynamic code that needs to know class names.

__name__ attribute:
• MyClass.__name__ returns 'MyClass'
• __name__ contains class name as string
• Automatically set when class defined
• Returns class name: 'MyClass'
• Useful for introspection

How it works:
• class MyClass: pass creates class definition
• Python automatically sets MyClass.__name__ = 'MyClass'
• __name__ attribute stores class name
• MyClass.__name__ accesses attribute
• Returns: 'MyClass'

Example:
class MyClass: pass
MyClass.__name__             # 'MyClass' (class name)
class Person: pass
Person.__name__              # 'Person' (class name)

Common uses:
• Introspection: print(MyClass.__name__) (debugging)
• Dynamic code: code that uses class names
• Class attributes
• Class metadata

Example: If class MyClass: pass, then MyClass.__name__ returns 'MyClass' because __name__ is a special attribute that stores the class's name as a string, automatically set when the class is defined.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; MyClass.__bases__?`, 
    o: ["(<class 'object'>,)", "()", "Error", "None"], 
    c: 0, 
    e: "__bases__ contains tuple of base classes (object by default).",
    de: `Classes have a __bases__ attribute that contains a tuple of base classes (parent classes). If class MyClass: pass, then MyClass.__bases__ returns (<class 'object'>,) because all classes in Python inherit from object by default. Even if you don't explicitly specify a parent class, Python automatically makes object the base class. __bases__ shows the inheritance hierarchy - which classes this class inherits from.

__bases__ attribute:
• MyClass.__bases__ returns (<class 'object'>,)
• __bases__ contains tuple of base classes
• All classes inherit from object by default
• Returns tuple: (<class 'object'>,)
• Shows inheritance hierarchy

How it works:
• class MyClass: pass creates class definition
• No explicit parent class specified
• Python automatically makes object the base class
• MyClass.__bases__ contains tuple of base classes
• Returns: (<class 'object'>,)

Example:
class MyClass: pass
MyClass.__bases__            # (<class 'object'>,) (default inheritance)
class Child(Parent): pass
Child.__bases__              # (<class '__main__.Parent'>,) (explicit inheritance)

Common uses:
• Inheritance inspection: print(MyClass.__bases__)
• Inheritance hierarchy: check parent classes
• Class attributes
• Inheritance information

Example: If class MyClass: pass, then MyClass.__bases__ returns (<class 'object'>,) because all classes in Python inherit from object by default, and __bases__ contains a tuple of the base classes.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; MyClass.__module__?`, 
    o: ["'__main__' or module name", "None", "Error", "''"], 
    c: 0, 
    e: "__module__ contains module where class is defined.",
    de: `Classes have a __module__ attribute that contains the name of the module where the class is defined. If class MyClass: pass, then MyClass.__module__ returns '__main__' (if defined in the main script) or the module name (if defined in an imported module). The __module__ attribute helps identify where a class was defined, which is useful for introspection and debugging.

__module__ attribute:
• MyClass.__module__ returns '__main__' or module name
• __module__ contains module name where class defined
• '__main__' if defined in main script
• Module name if defined in imported module
• Useful for introspection

How it works:
• class MyClass: pass creates class definition
• Python automatically sets MyClass.__module__ = '__main__' (or module name)
• __module__ attribute stores module name
• MyClass.__module__ accesses attribute
• Returns: '__main__' (or module name)

Example:
class MyClass: pass
MyClass.__module__           # '__main__' (if in main script)
# If in module.py: MyClass.__module__ would be 'module'

Common uses:
• Introspection: print(MyClass.__module__) (debugging)
• Module identification: check where class defined
• Class attributes
• Class metadata

Example: If class MyClass: pass, then MyClass.__module__ returns '__main__' (if defined in the main script) or the module name (if defined in an imported module) because __module__ contains the name of the module where the class is defined.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; callable(MyClass)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Classes are callable (used to create instances).",
    de: `Classes are callable objects - they can be called like functions. If class MyClass: pass, then callable(MyClass) returns True because classes are callable - you can call them with parentheses to create instances (e.g., MyClass()). The callable() function checks if an object can be called, and classes are callable because they can be called to create instances. This is how object creation works in Python - classes are callable constructors.

Classes are callable:
• callable(MyClass) returns True
• Classes are callable objects
• Can be called: MyClass() (creates instance)
• callable() checks if object can be called
• Returns: True

How it works:
• class MyClass: pass creates class object
• MyClass is a class (callable)
• callable(MyClass) checks if MyClass is callable
• Classes are callable (can be called to create instances)
• Returns: True

Example:
class MyClass: pass
callable(MyClass)            # True (classes are callable)
MyClass()                    # Creates instance (calling class)
callable(5)                 # False (integers not callable)

Common uses:
• Checking callable: if callable(obj): obj()
• Type checking: is_callable = callable(Class)
• Callable check
• Object inspection

Example: If class MyClass: pass, then callable(MyClass) returns True because classes are callable objects - they can be called with parentheses to create instances (objects).
`
  }),
  
  // 11-20: Instance Creation and __init__
  (_i: number) => ({ 
    q: `What is def __init__(self, x): self.x = x?`, 
    o: ["Constructor method", "Destructor method", "Error", "Regular method"], 
    c: 0, 
    e: "__init__ is the constructor.",
    de: `The __init__ method is the constructor - it's automatically called when an instance is created. If def __init__(self, x): self.x = x, then this defines a constructor that takes a parameter x and sets it as an instance attribute. The __init__ method is special - it's called automatically when you create an instance (e.g., MyClass(5)), and it's used to initialize instance attributes. The self parameter refers to the instance being created.

__init__ constructor:
• def __init__(self, x): self.x = x defines constructor
• __init__ is special method (constructor)
• Automatically called when instance created
• self refers to instance being created
• Sets instance attributes: self.x = x

How it works:
• __init__ is special method name
• Called automatically: MyClass(5) calls __init__(self, 5)
• self parameter is instance being created
• x parameter is argument passed: MyClass(5)
• Sets instance attribute: self.x = x
• Returns: None (constructors don't return values)

Example:
class MyClass:
    def __init__(self, x):
        self.x = x
obj = MyClass(5)              # Calls __init__(self, 5)
obj.x                         # 5 (instance attribute set)

Common uses:
• Constructor: def __init__(self, param): self.attr = param
• Initialization: def __init__(self): self.data = []
• Instance setup
• Object initialization

Example: def __init__(self, x): self.x = x defines a constructor because __init__ is the special method that's automatically called when an instance is created, used to initialize instance attributes.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); obj.x?`, 
    o: ["5", "None", "Error", "0"], 
    c: 0, 
    e: "__init__ sets instance attributes.",
    de: `The __init__ method sets instance attributes when an instance is created. If class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); obj.x, then obj.x returns 5 because MyClass(5) calls __init__(self, 5), which sets self.x = 5, creating an instance attribute x with value 5. The instance attribute can then be accessed via obj.x.

__init__ sets attributes:
• class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); obj.x returns 5
• MyClass(5) calls __init__(self, 5)
• __init__ sets self.x = 5 (instance attribute)
• obj.x accesses instance attribute
• Returns: 5

How it works:
• MyClass(5) creates instance and calls __init__(self, 5)
• __init__ executes: self.x = 5
• Instance attribute x = 5 created on instance
• obj.x accesses instance attribute
• Returns: 5

Example:
class MyClass:
    def __init__(self, x):
        self.x = x
obj = MyClass(5)              # Calls __init__(self, 5), sets obj.x = 5
obj.x                         # 5 (instance attribute)

Common uses:
• Setting attributes: def __init__(self, x): self.x = x
• Initialization: def __init__(self): self.data = []
• Instance setup
• Object initialization

Example: If class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); obj.x, then obj.x returns 5 because __init__ sets instance attributes when the instance is created, so self.x = 5 creates an instance attribute x with value 5.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self): pass; obj = MyClass()?`, 
    o: ["Creates instance", "Error", "Returns None", "None"], 
    c: 0, 
    e: "__init__ can have no parameters (except self).",
    de: `The __init__ method can have no parameters except self. If class MyClass: def __init__(self): pass; obj = MyClass(), then obj = MyClass() creates an instance because __init__ can be defined with only self (no other parameters). When you call MyClass() with no arguments, it calls __init__(self) with no additional arguments. The pass statement does nothing - it's just a placeholder for an empty method body.

__init__ with no parameters:
• class MyClass: def __init__(self): pass; obj = MyClass() creates instance
• __init__ has only self parameter (no other parameters)
• MyClass() calls __init__(self) with no arguments
• Instance created successfully
• Returns: instance object

How it works:
• MyClass() creates instance and calls __init__(self)
• __init__ executes: pass (does nothing)
• Instance created successfully
• Assigned to obj
• Returns: instance object

Example:
class MyClass:
    def __init__(self):
        pass
obj = MyClass()               # Calls __init__(self), creates instance
obj                           # <__main__.MyClass object>

Common uses:
• Empty constructor: def __init__(self): pass
• No initialization: def __init__(self): (empty body)
• Default initialization
• Simple constructors

Example: If class MyClass: def __init__(self): pass; obj = MyClass(), then obj = MyClass() creates an instance because __init__ can have no parameters except self, so MyClass() calls __init__(self) and creates the instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self, x, y): self.x = x; self.y = y; obj = MyClass(1, 2)?`, 
    o: ["Creates instance with x=1, y=2", "Error", "Returns None", "None"], 
    c: 0, 
    e: "__init__ can have multiple parameters.",
    de: `The __init__ method can have multiple parameters. If class MyClass: def __init__(self, x, y): self.x = x; self.y = y; obj = MyClass(1, 2), then obj = MyClass(1, 2) creates an instance with x=1, y=2 because __init__ can take multiple parameters. When you call MyClass(1, 2), it calls __init__(self, 1, 2), which sets self.x = 1 and self.y = 2, creating two instance attributes.

__init__ with multiple parameters:
• class MyClass: def __init__(self, x, y): self.x = x; self.y = y; obj = MyClass(1, 2) creates instance with x=1, y=2
• __init__ has parameters: self, x, y
• MyClass(1, 2) calls __init__(self, 1, 2)
• Sets self.x = 1, self.y = 2
• Returns: instance object

How it works:
• MyClass(1, 2) creates instance and calls __init__(self, 1, 2)
• __init__ executes: self.x = 1, self.y = 2
• Instance attributes x = 1, y = 2 created
• Instance created successfully
• Returns: instance object

Example:
class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y
obj = MyClass(1, 2)           # Calls __init__(self, 1, 2), sets obj.x = 1, obj.y = 2
obj.x                         # 1
obj.y                         # 2

Common uses:
• Multiple parameters: def __init__(self, x, y): self.x = x; self.y = y
• Initialization: def __init__(self, name, age): self.name = name; self.age = age
• Instance setup
• Object initialization

Example: If class MyClass: def __init__(self, x, y): self.x = x; self.y = y; obj = MyClass(1, 2), then obj = MyClass(1, 2) creates an instance with x=1, y=2 because __init__ can have multiple parameters, and MyClass(1, 2) calls __init__(self, 1, 2), which sets both instance attributes.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass()?`, 
    o: ["Creates instance with x=1", "Error", "Returns None", "None"], 
    c: 0, 
    e: "__init__ can have default parameters.",
    de: `The __init__ method can have default parameters. If class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass(), then obj = MyClass() creates an instance with x=1 because __init__ has a default parameter x=1. When you call MyClass() with no arguments, it uses the default value x=1, so __init__(self, 1) is called, which sets self.x = 1. Default parameters allow you to create instances without providing all arguments.

__init__ with default parameter:
• class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass() creates instance with x=1
• __init__ has default parameter: x=1
• MyClass() calls __init__(self, 1) (uses default)
• Sets self.x = 1
• Returns: instance object

How it works:
• MyClass() creates instance and calls __init__(self, 1) (default x=1)
• __init__ executes: self.x = 1
• Instance attribute x = 1 created
• Instance created successfully
• Returns: instance object

Example:
class MyClass:
    def __init__(self, x=1):
        self.x = x
obj = MyClass()               # Calls __init__(self, 1), sets obj.x = 1
obj.x                         # 1 (default value used)

Common uses:
• Default parameters: def __init__(self, x=1): self.x = x
• Optional initialization: def __init__(self, name='Unknown'): self.name = name
• Instance setup
• Flexible constructors

Example: If class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass(), then obj = MyClass() creates an instance with x=1 because __init__ has a default parameter x=1, so MyClass() uses the default value.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass(5)?`, 
    o: ["Creates instance with x=5", "Error", "Returns None", "None"], 
    c: 0, 
    e: "Passing argument overrides default in __init__.",
    de: `Passing an argument to __init__ overrides the default parameter value. If class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass(5), then obj = MyClass(5) creates an instance with x=5 because passing 5 as an argument overrides the default value x=1. When you call MyClass(5), it calls __init__(self, 5), which uses the provided argument 5 instead of the default value 1.

Argument overrides default:
• class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass(5) creates instance with x=5
• __init__ has default parameter: x=1
• MyClass(5) calls __init__(self, 5) (overrides default)
• Sets self.x = 5 (not 1)
• Returns: instance object

How it works:
• MyClass(5) creates instance and calls __init__(self, 5)
• Argument 5 overrides default x=1
• __init__ executes: self.x = 5
• Instance attribute x = 5 created
• Returns: instance object

Example:
class MyClass:
    def __init__(self, x=1):
        self.x = x
obj = MyClass(5)             # Calls __init__(self, 5), sets obj.x = 5
obj.x                         # 5 (argument overrides default)

Common uses:
• Overriding defaults: MyClass(5) (overrides default x=1)
• Flexible initialization: def __init__(self, name='Unknown'): self.name = name
• Instance setup
• Optional parameters

Example: If class MyClass: def __init__(self, x=1): self.x = x; obj = MyClass(5), then obj = MyClass(5) creates an instance with x=5 because passing 5 as an argument overrides the default parameter value x=1.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); obj.x = 5; obj.x?`, 
    o: ["5", "Error", "None", "0"], 
    c: 0, 
    e: "Instance attributes can be set after creation.",
    de: `Instance attributes can be set after an instance is created. If class MyClass: pass; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 5 because you can assign attributes to an instance after it's created. Python allows you to add new attributes to instances dynamically - you don't need to define them in the class or __init__ method. This is called dynamic attribute assignment.

Setting attributes after creation:
• class MyClass: pass; obj = MyClass(); obj.x = 5; obj.x returns 5
• obj = MyClass() creates instance
• obj.x = 5 assigns attribute to instance
• obj.x accesses attribute
• Returns: 5

How it works:
• MyClass() creates instance
• obj.x = 5 assigns attribute x = 5 to instance
• Attribute stored in instance __dict__
• obj.x accesses attribute
• Returns: 5

Example:
class MyClass: pass
obj = MyClass()               # Creates instance
obj.x = 5                    # Sets attribute after creation
obj.x                        # 5 (attribute accessible)

Common uses:
• Dynamic attributes: obj.attr = value (set after creation)
• Flexible objects: obj.data = [] (add attributes as needed)
• Instance attributes
• Dynamic assignment

Example: If class MyClass: pass; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 5 because instance attributes can be set after an instance is created, and obj.x = 5 assigns the attribute to the instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 is obj2?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Each instance is a separate object.",
    de: `Each call to a class creates a separate instance (object). If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 is obj2, then obj1 is obj2 returns False because obj1 and obj2 are different instances - each call to MyClass() creates a new, separate object. The is operator checks object identity (whether two variables refer to the same object), and since obj1 and obj2 are different instances, they are not the same object.

Different instances:
• obj1 is obj2 returns False
• obj1 = MyClass() creates first instance
• obj2 = MyClass() creates second instance (different object)
• Each instance is separate object
• is checks identity (same object)
• Returns: False

How it works:
• MyClass() creates first instance (obj1)
• MyClass() creates second instance (obj2)
• obj1 and obj2 are different objects
• obj1 is obj2 checks if same object
• Different objects, so returns: False

Example:
class MyClass: pass
obj1 = MyClass()             # Creates first instance
obj2 = MyClass()             # Creates second instance (different)
obj1 is obj2                 # False (different instances)

Common uses:
• Instance identity: obj1 is obj2 (check if same object)
• Object comparison: if obj1 is obj2: (identity check)
• Instance creation
• Object identity

Example: If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 is obj2, then obj1 is obj2 returns False because each call to MyClass() creates a separate instance, so obj1 and obj2 are different objects.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); hasattr(obj, 'x')?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "hasattr() checks if object has attribute.",
    de: `The hasattr() function checks if an object has a specific attribute. If class MyClass: pass; obj = MyClass(); hasattr(obj, 'x'), then hasattr(obj, 'x') returns False because obj doesn't have an attribute 'x' - it was created from an empty class with no attributes defined. hasattr() returns True if the object has the attribute (whether it's defined in the class, set in __init__, or added dynamically), and False otherwise.

hasattr() check:
• hasattr(obj, 'x') returns False
• obj = MyClass() creates instance
• obj has no attribute 'x'
• hasattr() checks if attribute exists
• Returns: False

How it works:
• MyClass() creates instance
• obj has no attributes (empty class)
• hasattr(obj, 'x') checks if 'x' exists
• Attribute doesn't exist
• Returns: False

Example:
class MyClass: pass
obj = MyClass()
hasattr(obj, 'x')            # False (no attribute 'x')
obj.x = 5
hasattr(obj, 'x')            # True (attribute 'x' exists)

Common uses:
• Attribute checking: if hasattr(obj, 'attr'): use obj.attr
• Safe access: hasattr(obj, 'method') and obj.method()
• Attribute existence
• Object inspection

Example: If class MyClass: pass; obj = MyClass(); hasattr(obj, 'x'), then hasattr(obj, 'x') returns False because obj doesn't have an attribute 'x', and hasattr() checks if an object has a specific attribute.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); hasattr(obj, 'x')?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "hasattr() returns True if attribute exists.",
    de: `The hasattr() function returns True if an object has a specific attribute. If class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); hasattr(obj, 'x'), then hasattr(obj, 'x') returns True because obj has an attribute 'x' that was set in __init__. When MyClass(5) is called, __init__(self, 5) sets self.x = 5, creating the instance attribute 'x', so hasattr() returns True.

hasattr() returns True:
• hasattr(obj, 'x') returns True
• obj = MyClass(5) creates instance with x=5
• __init__ sets self.x = 5 (attribute exists)
• hasattr() checks if attribute exists
• Returns: True

How it works:
• MyClass(5) creates instance and calls __init__(self, 5)
• __init__ sets self.x = 5 (creates attribute)
• obj has attribute 'x'
• hasattr(obj, 'x') checks if 'x' exists
• Attribute exists, so returns: True

Example:
class MyClass:
    def __init__(self, x):
        self.x = x
obj = MyClass(5)             # Sets obj.x = 5
hasattr(obj, 'x')            # True (attribute 'x' exists)

Common uses:
• Attribute checking: if hasattr(obj, 'attr'): use obj.attr
• Safe access: hasattr(obj, 'method') and obj.method()
• Attribute existence
• Object inspection

Example: If class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); hasattr(obj, 'x'), then hasattr(obj, 'x') returns True because obj has an attribute 'x' that was set in __init__, so hasattr() returns True when the attribute exists.
`
  }),
  
  // 21-30: Instance Methods and self
  (_i: number) => ({ 
    q: `What is self in a method?`, 
    o: ["Reference to instance", "Reference to class", "Error", "Variable name"], 
    c: 0, 
    e: "self refers to the instance.",
    de: `self is a reference to the instance (object) on which a method is called. In a method definition like def method(self):, self is the first parameter that refers to the instance. When you call obj.method(), Python automatically passes obj as the self argument. self allows methods to access and modify instance attributes and call other instance methods. It's a convention (not a keyword) - you could use any name, but self is universally used.

self parameter:
• self refers to the instance
• First parameter in instance methods
• Automatically passed when method called
• Allows access to instance attributes: self.x
• Convention (not keyword)

How it works:
• def method(self): defines instance method
• self is first parameter (refers to instance)
• obj.method() calls method, passes obj as self
• Method can access instance via self
• self.x accesses instance attribute x

Example:
class MyClass:
    def method(self):
        return self  # self is the instance
obj = MyClass()
obj.method() is obj  # True (self refers to obj)

Common uses:
• Instance access: def method(self): return self.x
• Instance modification: def method(self): self.x = 5
• Instance methods
• Object-oriented programming

Example: self in a method is a reference to the instance because when you call obj.method(), Python automatically passes obj as the self argument, allowing the method to access and modify the instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): return 1; obj = MyClass(); obj.method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Instance method called on object.",
    de: `Instance methods are called on instances (objects). If class MyClass: def method(self): return 1; obj = MyClass(); obj.method(), then obj.method() returns 1 because obj.method() calls the instance method method() on the instance obj. When you call a method on an instance, Python automatically passes the instance as the self argument. The method executes and returns its value (1 in this case).

Instance method call:
• obj.method() returns 1
• obj is instance of MyClass
• method() is instance method
• obj.method() calls method on instance
• Returns: 1

How it works:
• obj = MyClass() creates instance
• obj.method() calls method on instance
• Python passes obj as self argument
• Method executes: return 1
• Returns: 1

Example:
class MyClass:
    def method(self):
        return 1
obj = MyClass()
obj.method()                 # 1 (calls method on instance)

Common uses:
• Method calls: obj.method() (call on instance)
• Instance methods: def method(self): return value
• Object-oriented programming
• Method invocation

Example: If class MyClass: def method(self): return 1; obj = MyClass(); obj.method(), then obj.method() returns 1 because instance methods are called on instances, and obj.method() calls the method on the instance obj.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): return 1; MyClass.method(MyClass())?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Instance method can be called via class with instance as first arg.",
    de: `Instance methods can be called via the class by explicitly passing the instance as the first argument. If class MyClass: def method(self): return 1; MyClass.method(MyClass()), then MyClass.method(MyClass()) returns 1 because you can call an instance method through the class by passing the instance as the first argument. MyClass.method is the unbound method (function), and MyClass() creates an instance to pass as self. This is equivalent to obj = MyClass(); obj.method().

Calling via class:
• MyClass.method(MyClass()) returns 1
• MyClass.method is unbound method (function)
• MyClass() creates instance
• MyClass.method(instance) calls method with instance as self
• Returns: 1

How it works:
• MyClass.method accesses method via class (unbound)
• MyClass() creates instance
• MyClass.method(instance) calls method with instance as self
• Method executes: return 1
• Returns: 1

Example:
class MyClass:
    def method(self):
        return 1
MyClass.method(MyClass())    # 1 (calls via class with instance)
obj = MyClass()
obj.method()                 # 1 (same result, more common)

Common uses:
• Unbound method call: Class.method(instance)
• Method access: Class.method (gets unbound method)
• Instance methods
• Method invocation

Example: If class MyClass: def method(self): return 1; MyClass.method(MyClass()), then MyClass.method(MyClass()) returns 1 because instance methods can be called via the class by explicitly passing the instance as the first argument.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self, x): return x * 2; obj = MyClass(); obj.method(5)?`, 
    o: ["10", "5", "Error", "None"], 
    c: 0, 
    e: "Instance method with parameter.",
    de: `Instance methods can take parameters in addition to self. If class MyClass: def method(self, x): return x * 2; obj = MyClass(); obj.method(5), then obj.method(5) returns 10 because the method takes a parameter x, and when you call obj.method(5), the argument 5 is passed to x. The method then returns x * 2 = 5 * 2 = 10. Instance methods can have any number of parameters - self is always first, followed by any other parameters.

Instance method with parameter:
• obj.method(5) returns 10
• method(self, x) takes parameter x
• obj.method(5) passes 5 to x
• Method executes: return x * 2 = 5 * 2
• Returns: 10

How it works:
• obj.method(5) calls method on instance
• Python passes obj as self, 5 as x
• Method executes: return x * 2
• Evaluates: 5 * 2 = 10
• Returns: 10

Example:
class MyClass:
    def method(self, x):
        return x * 2
obj = MyClass()
obj.method(5)                # 10 (5 * 2)

Common uses:
• Method parameters: def method(self, x): return x * 2
• Multiple parameters: def method(self, x, y): return x + y
• Instance methods
• Method arguments

Example: If class MyClass: def method(self, x): return x * 2; obj = MyClass(); obj.method(5), then obj.method(5) returns 10 because instance methods can take parameters, and obj.method(5) passes 5 to x, so the method returns 5 * 2 = 10.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self, x): self.x = x; def get_x(self): return self.x; obj = MyClass(5); obj.get_x()?`, 
    o: ["5", "Error", "None", "0"], 
    c: 0, 
    e: "Method can access instance attributes via self.",
    de: `Methods can access instance attributes via self. If class MyClass: def __init__(self, x): self.x = x; def get_x(self): return self.x; obj = MyClass(5); obj.get_x(), then obj.get_x() returns 5 because the method get_x() accesses the instance attribute self.x. When MyClass(5) is called, __init__ sets self.x = 5, and when obj.get_x() is called, it returns self.x, which is 5. Methods use self to access instance attributes.

Method accesses instance attribute:
• obj.get_x() returns 5
• __init__ sets self.x = 5
• get_x() accesses self.x
• Returns instance attribute value
• Returns: 5

How it works:
• MyClass(5) calls __init__(self, 5)
• __init__ sets self.x = 5
• obj.get_x() calls method on instance
• Method accesses self.x (instance attribute)
• Returns: 5

Example:
class MyClass:
    def __init__(self, x):
        self.x = x
    def get_x(self):
        return self.x
obj = MyClass(5)             # Sets obj.x = 5
obj.get_x()                  # 5 (accesses self.x)

Common uses:
• Accessing attributes: def get_x(self): return self.x
• Getter methods: def get_value(self): return self.value
• Instance methods
• Attribute access

Example: If class MyClass: def __init__(self, x): self.x = x; def get_x(self): return self.x; obj = MyClass(5); obj.get_x(), then obj.get_x() returns 5 because methods can access instance attributes via self, and get_x() returns self.x, which is 5.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): return self; obj = MyClass(); obj.method() is obj?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "self in method refers to the instance.",
    de: `self in a method refers to the instance on which the method is called. If class MyClass: def method(self): return self; obj = MyClass(); obj.method() is obj, then obj.method() is obj returns True because self in the method refers to the instance obj. When you call obj.method(), Python passes obj as self, so return self returns obj, and obj.method() is obj checks if the returned value is the same object as obj, which it is.

self refers to instance:
• obj.method() is obj returns True
• obj.method() calls method on instance
• Python passes obj as self
• return self returns obj
• obj.method() is obj checks identity
• Returns: True

How it works:
• obj.method() calls method on instance
• Python passes obj as self argument
• Method executes: return self (returns obj)
• obj.method() is obj checks if same object
• Same object, so returns: True

Example:
class MyClass:
    def method(self):
        return self
obj = MyClass()
obj.method() is obj          # True (self is obj)

Common uses:
• Self reference: def method(self): return self
• Instance identity: self is the instance
• Instance methods
• Object identity

Example: If class MyClass: def method(self): return self; obj = MyClass(); obj.method() is obj, then obj.method() is obj returns True because self in a method refers to the instance on which the method is called, so self is obj.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self, other): return self.x + other.x; obj1 = MyClass(); obj1.x = 1; obj2 = MyClass(); obj2.x = 2; obj1.method(obj2)?`, 
    o: ["3", "1", "2", "Error"], 
    c: 0, 
    e: "Method can take another instance as parameter.",
    de: `Methods can take another instance as a parameter. If class MyClass: def method(self, other): return self.x + other.x; obj1 = MyClass(); obj1.x = 1; obj2 = MyClass(); obj2.x = 2; obj1.method(obj2), then obj1.method(obj2) returns 3 because the method takes another instance (other) as a parameter. When obj1.method(obj2) is called, self refers to obj1 and other refers to obj2, so it returns self.x + other.x = 1 + 2 = 3. This allows methods to interact with other instances of the same class.

Method with other instance:
• obj1.method(obj2) returns 3
• method(self, other) takes another instance
• obj1.method(obj2) passes obj2 as other
• self refers to obj1, other refers to obj2
• Returns self.x + other.x = 1 + 2 = 3

How it works:
• obj1.method(obj2) calls method on obj1
• Python passes obj1 as self, obj2 as other
• Method accesses self.x = 1, other.x = 2
• Method executes: return self.x + other.x
• Evaluates: 1 + 2 = 3
• Returns: 3

Example:
class MyClass:
    def method(self, other):
        return self.x + other.x
obj1 = MyClass(); obj1.x = 1
obj2 = MyClass(); obj2.x = 2
obj1.method(obj2)            # 3 (1 + 2)

Common uses:
• Instance interaction: def method(self, other): return self.x + other.x
• Comparison: def compare(self, other): return self.value > other.value
• Instance methods
• Object interaction

Example: If class MyClass: def method(self, other): return self.x + other.x; obj1 = MyClass(); obj1.x = 1; obj2 = MyClass(); obj2.x = 2; obj1.method(obj2), then obj1.method(obj2) returns 3 because methods can take another instance as a parameter, and self.x + other.x = 1 + 2 = 3.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): return 'instance'; obj = MyClass(); MyClass.method?`, 
    o: ["<function MyClass.method>", "Error", "None", "'instance'"], 
    c: 0, 
    e: "Accessing method via class returns function (unbound).",
    de: `Accessing a method via the class returns an unbound function. If class MyClass: def method(self): return 'instance'; obj = MyClass(); MyClass.method, then MyClass.method returns <function MyClass.method> because accessing a method through the class (not an instance) returns the unbound method (function). An unbound method is a function that hasn't been bound to a specific instance - you need to pass the instance as the first argument when calling it. This is different from accessing a method through an instance, which returns a bound method.

Unbound method:
• MyClass.method returns <function MyClass.method>
• Accessing via class returns unbound function
• Unbound method not tied to instance
• Must pass instance as first argument
• Returns: function object

How it works:
• MyClass.method accesses method via class
• Method not bound to instance
• Returns function object (unbound)
• Can be called: MyClass.method(instance)
• Returns: <function MyClass.method>

Example:
class MyClass:
    def method(self):
        return 'instance'
MyClass.method               # <function MyClass.method> (unbound)
obj = MyClass()
MyClass.method(obj)          # 'instance' (pass instance as argument)

Common uses:
• Unbound method: Class.method (function object)
• Method access: Class.method (gets function)
• Instance methods
• Method objects

Example: If class MyClass: def method(self): return 'instance'; obj = MyClass(); MyClass.method, then MyClass.method returns <function MyClass.method> because accessing a method via the class returns an unbound function (not bound to a specific instance).
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): return 'instance'; obj = MyClass(); obj.method?`, 
    o: ["<bound method MyClass.method>", "Error", "None", "'instance'"], 
    c: 0, 
    e: "Accessing method via instance returns bound method.",
    de: `Accessing a method via an instance returns a bound method. If class MyClass: def method(self): return 'instance'; obj = MyClass(); obj.method, then obj.method returns <bound method MyClass.method> because accessing a method through an instance returns a bound method - a method that's bound to that specific instance. When you call a bound method, Python automatically passes the instance as self. This is different from accessing a method through the class, which returns an unbound function.

Bound method:
• obj.method returns <bound method MyClass.method>
• Accessing via instance returns bound method
• Bound method tied to instance
• Automatically passes instance as self
• Returns: bound method object

How it works:
• obj.method accesses method via instance
• Method bound to instance obj
• Returns bound method object
• Can be called: obj.method() (no need to pass self)
• Returns: <bound method MyClass.method>

Example:
class MyClass:
    def method(self):
        return 'instance'
obj = MyClass()
obj.method                  # <bound method MyClass.method> (bound)
obj.method()                 # 'instance' (calls bound method)

Common uses:
• Bound method: obj.method (bound to instance)
• Method access: obj.method (gets bound method)
• Instance methods
• Method objects

Example: If class MyClass: def method(self): return 'instance'; obj = MyClass(); obj.method, then obj.method returns <bound method MyClass.method> because accessing a method via an instance returns a bound method (bound to that specific instance).
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self, x=1): return x; obj = MyClass(); obj.method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Instance method can have default parameters.",
    de: `Instance methods can have default parameters. If class MyClass: def method(self, x=1): return x; obj = MyClass(); obj.method(), then obj.method() returns 1 because the method has a default parameter x=1. When you call obj.method() with no arguments, it uses the default value x=1, so the method returns 1. Default parameters allow you to call methods without providing all arguments.

Instance method with default:
• obj.method() returns 1
• method(self, x=1) has default parameter
• obj.method() uses default x=1
• Method returns x = 1
• Returns: 1

How it works:
• obj.method() calls method on instance
• Python passes obj as self
• No argument provided for x, uses default x=1
• Method executes: return x
• Returns: 1

Example:
class MyClass:
    def method(self, x=1):
        return x
obj = MyClass()
obj.method()                # 1 (uses default x=1)
obj.method(5)                # 5 (overrides default)

Common uses:
• Default parameters: def method(self, x=1): return x
• Optional arguments: def method(self, name='Unknown'): return name
• Instance methods
• Method arguments

Example: If class MyClass: def method(self, x=1): return x; obj = MyClass(); obj.method(), then obj.method() returns 1 because instance methods can have default parameters, and obj.method() uses the default value x=1.
`
  }),
  
  // 31-40: Class Attributes vs Instance Attributes
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; MyClass.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Class attribute accessed via class.",
    de: `Class attributes can be accessed directly via the class. If class MyClass: x = 1; MyClass.x, then MyClass.x returns 1 because x = 1 is a class attribute (defined in the class body), and you can access it through the class name. Class attributes belong to the class itself, not to individual instances, so they can be accessed via the class name without creating an instance.

Class attribute via class:
• MyClass.x returns 1
• x = 1 is class attribute (defined in class body)
• Class attributes belong to class
• Accessible via class name: MyClass.x
• Returns: 1

How it works:
• class MyClass: x = 1 creates class with class attribute
• x = 1 stored in class __dict__
• MyClass.x accesses class attribute
• Returns class attribute value
• Returns: 1

Example:
class MyClass: x = 1
MyClass.x                    # 1 (accessed via class)
obj = MyClass()
obj.x                        # 1 (also accessible via instance)

Common uses:
• Class attributes: class MyClass: shared_value = 1
• Constants: class Config: MAX_SIZE = 100
• Class-level data
• Shared attributes

Example: If class MyClass: x = 1; MyClass.x, then MyClass.x returns 1 because class attributes can be accessed directly via the class name, and x = 1 is a class attribute.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj = MyClass(); obj.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Instance can access class attribute.",
    de: `Instances can access class attributes. If class MyClass: x = 1; obj = MyClass(); obj.x, then obj.x returns 1 because instances can access class attributes. When you access an attribute on an instance, Python first looks for an instance attribute. If it doesn't find one, it looks for a class attribute. Since obj doesn't have an instance attribute x, it accesses the class attribute x = 1.

Instance accesses class attribute:
• obj.x returns 1
• obj has no instance attribute x
• Python looks for class attribute x
• Finds class attribute x = 1
• Returns: 1

How it works:
• obj = MyClass() creates instance
• obj has no instance attribute x
• obj.x looks for attribute x
• Python searches: instance __dict__ (not found) → class __dict__ (found x = 1)
• Returns class attribute value: 1

Example:
class MyClass: x = 1
obj = MyClass()
obj.x                        # 1 (accesses class attribute)
MyClass.x                    # 1 (same value, accessed via class)

Common uses:
• Accessing class attributes: obj.class_attr (via instance)
• Shared data: all instances share class attributes
• Class-level constants
• Shared state

Example: If class MyClass: x = 1; obj = MyClass(); obj.x, then obj.x returns 1 because instances can access class attributes, and when obj doesn't have an instance attribute x, it accesses the class attribute x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj = MyClass(); obj.x = 2; MyClass.x?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "Setting instance attribute doesn't change class attribute.",
    de: `Setting an instance attribute doesn't change the class attribute. If class MyClass: x = 1; obj = MyClass(); obj.x = 2; MyClass.x, then MyClass.x returns 1 because obj.x = 2 creates an instance attribute x = 2 on obj, which shadows (hides) the class attribute, but it doesn't modify the class attribute itself. The class attribute MyClass.x remains 1. Instance attributes and class attributes are separate - modifying one doesn't affect the other.

Instance attribute doesn't change class attribute:
• MyClass.x returns 1
• obj.x = 2 creates instance attribute (doesn't change class attribute)
• Class attribute MyClass.x remains 1
• Instance attribute shadows class attribute
• Returns: 1

How it works:
• obj.x = 2 assigns instance attribute x = 2 to obj
• Instance attribute stored in obj.__dict__
• Class attribute MyClass.x remains in class __dict__
• Instance attribute shadows class attribute for obj
• MyClass.x still returns class attribute: 1

Example:
class MyClass: x = 1
obj = MyClass()
obj.x = 2                    # Creates instance attribute
MyClass.x                    # 1 (class attribute unchanged)
obj.x                        # 2 (instance attribute)

Common uses:
• Instance attributes: obj.attr = value (doesn't affect class)
• Shadowing: instance attribute hides class attribute
• Separate storage
• Attribute independence

Example: If class MyClass: x = 1; obj = MyClass(); obj.x = 2; MyClass.x, then MyClass.x returns 1 because setting an instance attribute doesn't change the class attribute - they are separate, and the class attribute remains 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj = MyClass(); obj.x = 2; obj.x?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Instance attribute shadows class attribute.",
    de: `Instance attributes shadow (hide) class attributes. If class MyClass: x = 1; obj = MyClass(); obj.x = 2; obj.x, then obj.x returns 2 because obj.x = 2 creates an instance attribute x = 2 on obj, which shadows the class attribute x = 1. When you access obj.x, Python first looks for an instance attribute, finds x = 2, and returns it without checking the class attribute. The instance attribute takes precedence over the class attribute.

Instance attribute shadows class:
• obj.x returns 2
• obj.x = 2 creates instance attribute x = 2
• Instance attribute shadows class attribute x = 1
• obj.x returns instance attribute (not class attribute)
• Returns: 2

How it works:
• obj.x = 2 assigns instance attribute x = 2 to obj
• Instance attribute stored in obj.__dict__
• obj.x looks for attribute x
• Python searches: instance __dict__ (finds x = 2) → returns 2
• Class attribute x = 1 is shadowed (not accessed)

Example:
class MyClass: x = 1
obj = MyClass()
obj.x = 2                    # Creates instance attribute (shadows class)
obj.x                        # 2 (instance attribute, not class attribute)
MyClass.x                    # 1 (class attribute unchanged)

Common uses:
• Shadowing: instance attribute hides class attribute
• Instance-specific values: obj.attr = value (overrides class)
• Attribute precedence
• Instance attributes

Example: If class MyClass: x = 1; obj = MyClass(); obj.x = 2; obj.x, then obj.x returns 2 because instance attributes shadow class attributes, and obj.x = 2 creates an instance attribute that takes precedence over the class attribute.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj1 = MyClass(); obj2 = MyClass(); obj1.x = 2; obj2.x?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "Instance attributes are independent per instance.",
    de: `Instance attributes are independent for each instance. If class MyClass: x = 1; obj1 = MyClass(); obj2 = MyClass(); obj1.x = 2; obj2.x, then obj2.x returns 1 because instance attributes are stored separately for each instance. Setting obj1.x = 2 only affects obj1 - it creates an instance attribute on obj1 that shadows the class attribute. obj2 still accesses the class attribute x = 1 because it doesn't have its own instance attribute x.

Instance attributes independent:
• obj2.x returns 1
• obj1.x = 2 only affects obj1
• obj2 has no instance attribute x
• obj2.x accesses class attribute x = 1
• Returns: 1

How it works:
• obj1.x = 2 creates instance attribute on obj1 only
• obj2 has no instance attribute x
• obj2.x looks for attribute x
• Python searches: obj2.__dict__ (not found) → class __dict__ (finds x = 1)
• Returns class attribute: 1

Example:
class MyClass: x = 1
obj1 = MyClass(); obj2 = MyClass()
obj1.x = 2                   # Only affects obj1
obj1.x                       # 2 (instance attribute)
obj2.x                       # 1 (class attribute)

Common uses:
• Independent instances: each instance has own attributes
• Instance-specific data: obj1.attr = value1, obj2.attr = value2
• Instance attributes
• Object independence

Example: If class MyClass: x = 1; obj1 = MyClass(); obj2 = MyClass(); obj1.x = 2; obj2.x, then obj2.x returns 1 because instance attributes are independent per instance, and obj1.x = 2 only affects obj1, so obj2 still accesses the class attribute x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = []; obj1 = MyClass(); obj2 = MyClass(); obj1.x.append(1); obj2.x?`, 
    o: ["[1]", "[]", "Error", "None"], 
    c: 0, 
    e: "Mutable class attributes are shared by all instances.",
    de: `Mutable class attributes (like lists) are shared by all instances. If class MyClass: x = []; obj1 = MyClass(); obj2 = MyClass(); obj1.x.append(1); obj2.x, then obj2.x returns [1] because x = [] is a mutable class attribute (a list), and all instances share the same list object. When obj1.x.append(1) modifies the list, it modifies the shared list, so obj2.x also sees the change. This is a common pitfall - mutable class attributes should typically be initialized in __init__ instead.

Mutable class attributes shared:
• obj2.x returns [1]
• x = [] is mutable class attribute (list)
• All instances share same list object
• obj1.x.append(1) modifies shared list
• obj2.x sees same modified list
• Returns: [1]

How it works:
• x = [] creates class attribute (list object)
• obj1 and obj2 both reference same list object
• obj1.x.append(1) modifies shared list
• obj2.x accesses same list object
• Returns: [1] (modified list)

Example:
class MyClass: x = []  # Mutable class attribute (shared!)
obj1 = MyClass(); obj2 = MyClass()
obj1.x.append(1)        # Modifies shared list
obj2.x                  # [1] (same list, modified)

Common uses:
• Understanding pitfalls: mutable class attributes shared
• Best practice: initialize mutable attributes in __init__
• Shared state
• Mutable attributes

Example: If class MyClass: x = []; obj1 = MyClass(); obj2 = MyClass(); obj1.x.append(1); obj2.x, then obj2.x returns [1] because mutable class attributes are shared by all instances, so modifying the list through one instance affects all instances.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; MyClass.x = 2; obj = MyClass(); obj.x?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Changing class attribute affects all instances (if not shadowed).",
    de: `Changing a class attribute affects all instances (if they don't have their own instance attribute shadowing it). If class MyClass: x = 1; MyClass.x = 2; obj = MyClass(); obj.x, then obj.x returns 2 because MyClass.x = 2 changes the class attribute, and since obj doesn't have an instance attribute x (it was just created), it accesses the class attribute, which is now 2. All instances that don't shadow the class attribute will see the new value.

Changing class attribute affects instances:
• obj.x returns 2
• MyClass.x = 2 changes class attribute
• obj has no instance attribute x (just created)
• obj.x accesses class attribute (now 2)
• Returns: 2

How it works:
• MyClass.x = 2 modifies class attribute
• obj = MyClass() creates new instance
• obj has no instance attribute x
• obj.x looks for attribute x
• Python searches: obj.__dict__ (not found) → class __dict__ (finds x = 2)
• Returns class attribute: 2

Example:
class MyClass: x = 1
MyClass.x = 2                # Changes class attribute
obj = MyClass()
obj.x                        # 2 (accesses class attribute)

Common uses:
• Changing class attributes: MyClass.attr = new_value
• Shared updates: change affects all instances (if not shadowed)
• Class-level modifications
• Attribute updates

Example: If class MyClass: x = 1; MyClass.x = 2; obj = MyClass(); obj.x, then obj.x returns 2 because changing a class attribute affects all instances that don't shadow it, and obj accesses the class attribute, which is now 2.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj = MyClass(); obj.x = 2; del obj.x; obj.x?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "Deleting instance attribute reveals class attribute.",
    de: `Deleting an instance attribute reveals (unhides) the class attribute. If class MyClass: x = 1; obj = MyClass(); obj.x = 2; del obj.x; obj.x, then obj.x returns 1 because del obj.x deletes the instance attribute x = 2, which was shadowing the class attribute. After deletion, obj no longer has an instance attribute x, so when you access obj.x, Python looks for the class attribute and finds x = 1.

Deleting instance attribute reveals class:
• obj.x returns 1
• del obj.x deletes instance attribute x = 2
• obj no longer has instance attribute x
• obj.x looks for attribute x
• Python finds class attribute x = 1
• Returns: 1

How it works:
• obj.x = 2 creates instance attribute (shadows class)
• del obj.x deletes instance attribute
• obj.__dict__ no longer has 'x'
• obj.x looks for attribute x
• Python searches: obj.__dict__ (not found) → class __dict__ (finds x = 1)
• Returns class attribute: 1

Example:
class MyClass: x = 1
obj = MyClass()
obj.x = 2                    # Creates instance attribute (shadows)
del obj.x                    # Deletes instance attribute
obj.x                        # 1 (now accesses class attribute)

Common uses:
• Revealing class attributes: del obj.attr (removes shadowing)
• Attribute deletion: del obj.attr (removes instance attribute)
• Attribute management
• Shadowing control

Example: If class MyClass: x = 1; obj = MyClass(); obj.x = 2; del obj.x; obj.x, then obj.x returns 1 because deleting an instance attribute reveals the class attribute, and after del obj.x, obj accesses the class attribute x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj = MyClass(); MyClass.x = 2; obj.x?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Changing class attribute affects instance (if not shadowed).",
    de: `Changing a class attribute affects instances that don't shadow it. If class MyClass: x = 1; obj = MyClass(); MyClass.x = 2; obj.x, then obj.x returns 2 because MyClass.x = 2 changes the class attribute, and since obj doesn't have an instance attribute x (it was just created), it accesses the class attribute, which is now 2. If obj had an instance attribute x that shadowed the class attribute, changing the class attribute wouldn't affect obj.x.

Changing class affects instance:
• obj.x returns 2
• MyClass.x = 2 changes class attribute
• obj has no instance attribute x (not shadowed)
• obj.x accesses class attribute (now 2)
• Returns: 2

How it works:
• obj = MyClass() creates instance (no instance attribute x)
• MyClass.x = 2 modifies class attribute
• obj.x looks for attribute x
• Python searches: obj.__dict__ (not found) → class __dict__ (finds x = 2)
• Returns class attribute: 2

Example:
class MyClass: x = 1
obj = MyClass()              # No instance attribute x
MyClass.x = 2                # Changes class attribute
obj.x                        # 2 (accesses class attribute)

Common uses:
• Class attribute updates: MyClass.attr = new_value
• Shared changes: affects instances (if not shadowed)
• Class-level modifications
• Attribute updates

Example: If class MyClass: x = 1; obj = MyClass(); MyClass.x = 2; obj.x, then obj.x returns 2 because changing a class attribute affects instances that don't shadow it, and obj accesses the class attribute, which is now 2.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj = MyClass(); obj.x = 2; MyClass.x = 3; obj.x?`, 
    o: ["2", "3", "Error", "None"], 
    c: 0, 
    e: "Instance attribute shadows class attribute, changes don't affect it.",
    de: `Instance attributes that shadow class attributes are independent - changing the class attribute doesn't affect them. If class MyClass: x = 1; obj = MyClass(); obj.x = 2; MyClass.x = 3; obj.x, then obj.x returns 2 because obj.x = 2 creates an instance attribute that shadows the class attribute. When you change MyClass.x = 3, it only affects the class attribute, not the instance attribute. Since obj has its own instance attribute x = 2, it continues to return 2, not the class attribute value 3.

Instance attribute independent:
• obj.x returns 2
• obj.x = 2 creates instance attribute (shadows class)
• MyClass.x = 3 changes class attribute (doesn't affect instance)
• obj.x returns instance attribute (not class attribute)
• Returns: 2

How it works:
• obj.x = 2 creates instance attribute x = 2
• Instance attribute shadows class attribute
• MyClass.x = 3 modifies class attribute (now 3)
• obj.x looks for attribute x
• Python searches: obj.__dict__ (finds x = 2) → returns 2
• Class attribute x = 3 is shadowed (not accessed)

Example:
class MyClass: x = 1
obj = MyClass()
obj.x = 2                    # Creates instance attribute (shadows)
MyClass.x = 3                # Changes class attribute
obj.x                        # 2 (instance attribute, not class attribute)
MyClass.x                    # 3 (class attribute)

Common uses:
• Shadowing: instance attribute hides class attribute
• Independent values: instance attribute independent of class
• Attribute precedence
• Instance attributes

Example: If class MyClass: x = 1; obj = MyClass(); obj.x = 2; MyClass.x = 3; obj.x, then obj.x returns 2 because instance attributes that shadow class attributes are independent, and changing the class attribute doesn't affect the instance attribute.
`
  }),
  
  // 41-50: Class Methods and Static Methods
  (_i: number) => ({ 
    q: `What is class MyClass: @classmethod; def method(cls): return cls; MyClass.method()?`, 
    o: ["<class '__main__.MyClass'>", "Error", "None", "MyClass"], 
    c: 0, 
    e: "@classmethod decorator, cls refers to class.",
    de: `The @classmethod decorator creates a class method that receives the class as the first argument. If class MyClass: @classmethod; def method(cls): return cls; MyClass.method(), then MyClass.method() returns <class '__main__.MyClass'> because @classmethod makes method() a class method, and cls refers to the class MyClass. When you call MyClass.method(), Python automatically passes MyClass as the cls argument, so return cls returns the class object.

@classmethod decorator:
• MyClass.method() returns <class '__main__.MyClass'>
• @classmethod decorator creates class method
• cls parameter refers to class (automatically passed)
• MyClass.method() passes MyClass as cls
• Returns: class object

How it works:
• @classmethod decorator modifies method
• method(cls) receives class as first argument
• MyClass.method() calls class method
• Python passes MyClass as cls argument
• Method executes: return cls
• Returns: <class '__main__.MyClass'>

Example:
class MyClass:
    @classmethod
    def method(cls):
        return cls
MyClass.method()             # <class '__main__.MyClass'> (cls is MyClass)

Common uses:
• Class methods: @classmethod def method(cls): return cls
• Factory methods: @classmethod def create(cls): return cls()
• Class-level operations
• Alternative constructors

Example: If class MyClass: @classmethod; def method(cls): return cls; MyClass.method(), then MyClass.method() returns <class '__main__.MyClass'> because @classmethod creates a class method that receives the class as the first argument (cls), and return cls returns the class object.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @classmethod; def method(cls): return cls; obj = MyClass(); obj.method()?`, 
    o: ["<class '__main__.MyClass'>", "Error", "None", "obj"], 
    c: 0, 
    e: "Class method called on instance still receives class.",
    de: `Class methods can be called on instances, but they still receive the class as the first argument, not the instance. If class MyClass: @classmethod; def method(cls): return cls; obj = MyClass(); obj.method(), then obj.method() returns <class '__main__.MyClass'> because even though you call the method on an instance (obj), @classmethod ensures that cls receives the class MyClass, not the instance obj. This is different from instance methods, which receive the instance as self.

Class method on instance:
• obj.method() returns <class '__main__.MyClass'>
• obj.method() calls class method on instance
• @classmethod ensures cls receives class (not instance)
• cls is MyClass (not obj)
• Returns: class object

How it works:
• obj.method() calls class method on instance
• @classmethod decorator ensures class passed as cls
• Python passes MyClass as cls (not obj)
• Method executes: return cls
• Returns: <class '__main__.MyClass'>

Example:
class MyClass:
    @classmethod
    def method(cls):
        return cls
obj = MyClass()
obj.method()                 # <class '__main__.MyClass'> (cls is class, not instance)
MyClass.method()             # <class '__main__.MyClass'> (same result)

Common uses:
• Class methods: can be called on instance or class
• Consistent behavior: obj.method() and Class.method() same
• Class-level operations
• Alternative constructors

Example: If class MyClass: @classmethod; def method(cls): return cls; obj = MyClass(); obj.method(), then obj.method() returns <class '__main__.MyClass'> because class methods called on instances still receive the class as the first argument, not the instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @staticmethod; def method(): return 1; MyClass.method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "@staticmethod doesn't require self or cls.",
    de: `The @staticmethod decorator creates a static method that doesn't require self or cls. If class MyClass: @staticmethod; def method(): return 1; MyClass.method(), then MyClass.method() returns 1 because @staticmethod makes method() a static method that doesn't receive self or cls - it's just a regular function that happens to be defined inside a class. Static methods are called like regular functions, but they're accessed through the class.

@staticmethod decorator:
• MyClass.method() returns 1
• @staticmethod decorator creates static method
• method() doesn't receive self or cls
• Called like regular function
• Returns: 1

How it works:
• @staticmethod decorator modifies method
• method() has no self or cls parameter
• MyClass.method() calls static method
• No automatic arguments passed
• Method executes: return 1
• Returns: 1

Example:
class MyClass:
    @staticmethod
    def method():
        return 1
MyClass.method()             # 1 (no self or cls needed)

Common uses:
• Static methods: @staticmethod def method(): return value
• Utility functions: @staticmethod def helper(): ...
• No instance/class needed
• Regular functions in class namespace

Example: If class MyClass: @staticmethod; def method(): return 1; MyClass.method(), then MyClass.method() returns 1 because @staticmethod creates a static method that doesn't require self or cls - it's just a regular function accessed through the class.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @staticmethod; def method(): return 1; obj = MyClass(); obj.method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Static method can be called on instance or class.",
    de: `Static methods can be called on both instances and classes. If class MyClass: @staticmethod; def method(): return 1; obj = MyClass(); obj.method(), then obj.method() returns 1 because static methods can be called on instances just like they can be called on classes. When you call a static method on an instance, it works the same way as calling it on the class - no instance or class is passed as an argument. Static methods are essentially regular functions that are accessed through the class namespace.

Static method on instance:
• obj.method() returns 1
• obj.method() calls static method on instance
• Static method doesn't receive instance or class
• Works same as MyClass.method()
• Returns: 1

How it works:
• obj.method() calls static method on instance
• @staticmethod ensures no automatic arguments
• No self or cls passed
• Method executes: return 1
• Returns: 1 (same as MyClass.method())

Example:
class MyClass:
    @staticmethod
    def method():
        return 1
obj = MyClass()
obj.method()                 # 1 (works on instance)
MyClass.method()             # 1 (works on class, same result)

Common uses:
• Static methods: can be called on instance or class
• Utility functions: @staticmethod def helper(): ...
• No instance/class needed
• Regular functions in class namespace

Example: If class MyClass: @staticmethod; def method(): return 1; obj = MyClass(); obj.method(), then obj.method() returns 1 because static methods can be called on instances or classes, and they work the same way in both cases.
`
  }),
  (_i: number) => ({ 
    q: `What is the difference between @classmethod and @staticmethod?`, 
    o: ["classmethod gets cls, staticmethod gets nothing", "No difference", "staticmethod is faster", "classmethod is deprecated"], 
    c: 0, 
    e: "classmethod receives class as first arg, staticmethod receives nothing.",
    de: `The key difference is that @classmethod receives the class as the first argument (cls), while @staticmethod receives nothing. @classmethod def method(cls): receives cls (the class) automatically, allowing it to access class attributes and create instances. @staticmethod def method(): receives no automatic arguments - it's just a regular function. Use @classmethod when you need access to the class, and @staticmethod when you don't need the class or instance.

Difference:
• @classmethod gets cls (class as first argument)
• @staticmethod gets nothing (no automatic arguments)
• classmethod can access class: cls.attr
• staticmethod is just a regular function
• Use classmethod for class operations, staticmethod for utilities

How it works:
• @classmethod: def method(cls): (cls is class, automatically passed)
• @staticmethod: def method(): (no automatic arguments)
• classmethod(cls): can use cls to access class attributes
• staticmethod(): just a regular function in class namespace

Example:
class MyClass:
    x = 1
    @classmethod
    def get_x(cls):
        return cls.x  # Can access class via cls
    @staticmethod
    def add(a, b):
        return a + b  # No cls or self needed

Common uses:
• @classmethod: factory methods, class-level operations
• @staticmethod: utility functions, no class/instance needed
• Method types
• Decorators

Example: The difference is that @classmethod receives the class as the first argument (cls), allowing access to class attributes, while @staticmethod receives nothing and is just a regular function in the class namespace.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; @classmethod; def get_x(cls): return cls.x; MyClass.get_x()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Class method can access class attributes via cls.",
    de: `Class methods can access class attributes via the cls parameter. If class MyClass: x = 1; @classmethod; def get_x(cls): return cls.x; MyClass.get_x(), then MyClass.get_x() returns 1 because the class method get_x() receives cls (the class MyClass) as the first argument, and cls.x accesses the class attribute x = 1. This is the main advantage of @classmethod - it allows methods to access and work with class-level data.

Class method accesses class attribute:
• MyClass.get_x() returns 1
• @classmethod makes get_x() a class method
• cls parameter receives MyClass (the class)
• cls.x accesses class attribute x = 1
• Returns: 1

How it works:
• MyClass.get_x() calls class method
• Python passes MyClass as cls argument
• Method executes: return cls.x
• cls.x accesses class attribute x = 1
• Returns: 1

Example:
class MyClass:
    x = 1
    @classmethod
    def get_x(cls):
        return cls.x  # Accesses class attribute via cls
MyClass.get_x()       # 1 (cls.x accesses class attribute)

Common uses:
• Accessing class attributes: @classmethod def get_attr(cls): return cls.attr
• Class-level operations: @classmethod def class_operation(cls): ...
• Class methods
• Class attribute access

Example: If class MyClass: x = 1; @classmethod; def get_x(cls): return cls.x; MyClass.get_x(), then MyClass.get_x() returns 1 because class methods can access class attributes via cls, and cls.x accesses the class attribute x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @classmethod; def create(cls): return cls(); obj = MyClass.create()?`, 
    o: ["Creates instance", "Error", "None", "MyClass"], 
    c: 0, 
    e: "Class method can be used as factory method.",
    de: `Class methods can be used as factory methods to create instances. If class MyClass: @classmethod; def create(cls): return cls(); obj = MyClass.create(), then MyClass.create() creates an instance because the class method create() receives cls (the class MyClass) as the first argument, and cls() calls the class constructor, creating a new instance. This is a common pattern for alternative constructors or factory methods that create instances in different ways.

Class method as factory:
• MyClass.create() creates instance
• @classmethod makes create() a class method
• cls parameter receives MyClass (the class)
• cls() calls class constructor (creates instance)
• Returns: instance object

How it works:
• MyClass.create() calls class method
• Python passes MyClass as cls argument
• Method executes: return cls()
• cls() calls MyClass() (creates instance)
• Returns: new instance object

Example:
class MyClass:
    @classmethod
    def create(cls):
        return cls()  # Creates instance using cls
obj = MyClass.create()  # Creates instance (factory method)

Common uses:
• Factory methods: @classmethod def create(cls): return cls()
• Alternative constructors: @classmethod def from_string(cls, s): ...
• Class methods
• Instance creation

Example: If class MyClass: @classmethod; def create(cls): return cls(); obj = MyClass.create(), then MyClass.create() creates an instance because class methods can be used as factory methods, and cls() calls the class constructor to create a new instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @staticmethod; def add(x, y): return x + y; MyClass.add(1, 2)?`, 
    o: ["3", "Error", "None", "0"], 
    c: 0, 
    e: "Static method can take regular parameters.",
    de: `Static methods can take regular parameters just like regular functions. If class MyClass: @staticmethod; def add(x, y): return x + y; MyClass.add(1, 2), then MyClass.add(1, 2) returns 3 because static methods are essentially regular functions - they can take any parameters you define. The @staticmethod decorator doesn't restrict what parameters the method can have - it just prevents self or cls from being automatically passed.

Static method with parameters:
• MyClass.add(1, 2) returns 3
• @staticmethod makes add() a static method
• add(x, y) takes regular parameters
• MyClass.add(1, 2) passes 1 and 2 to x and y
• Returns: 1 + 2 = 3

How it works:
• MyClass.add(1, 2) calls static method
• No self or cls automatically passed
• Arguments 1 and 2 passed to x and y
• Method executes: return x + y
• Evaluates: 1 + 2 = 3
• Returns: 3

Example:
class MyClass:
    @staticmethod
    def add(x, y):
        return x + y
MyClass.add(1, 2)            # 3 (regular parameters work)

Common uses:
• Static methods: @staticmethod def helper(x, y): return x + y
• Utility functions: @staticmethod def calculate(a, b): ...
• Regular parameters
• No self/cls needed

Example: If class MyClass: @staticmethod; def add(x, y): return x + y; MyClass.add(1, 2), then MyClass.add(1, 2) returns 3 because static methods can take regular parameters, and they work just like regular functions.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): return 1; @classmethod; def class_method(cls): return 2; MyClass.class_method()?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Class can have both instance and class methods.",
    de: `A class can have both instance methods and class methods. If class MyClass: def method(self): return 1; @classmethod; def class_method(cls): return 2; MyClass.class_method(), then MyClass.class_method() returns 2 because a class can define multiple types of methods. Instance methods (like method(self)) receive the instance as self, while class methods (like class_method(cls)) receive the class as cls. They coexist in the same class and can be called independently.

Both method types:
• MyClass.class_method() returns 2
• Class has instance method: method(self)
• Class has class method: class_method(cls)
• Both methods coexist in same class
• Returns: 2

How it works:
• class MyClass defines both method types
• method(self) is instance method (receives instance)
• class_method(cls) is class method (receives class)
• MyClass.class_method() calls class method
• Returns: 2

Example:
class MyClass:
    def method(self):
        return 1  # Instance method
    @classmethod
    def class_method(cls):
        return 2  # Class method
obj = MyClass()
obj.method()                 # 1 (instance method)
MyClass.class_method()       # 2 (class method)

Common uses:
• Multiple method types: instance methods and class methods
• Flexible design: different methods for different purposes
• Method types
• Class design

Example: If class MyClass: def method(self): return 1; @classmethod; def class_method(cls): return 2; MyClass.class_method(), then MyClass.class_method() returns 2 because a class can have both instance methods and class methods, and they coexist in the same class.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @staticmethod; def method(): return 'static'; obj = MyClass(); obj.method()?`, 
    o: ["'static'", "Error", "None", "'instance'"], 
    c: 0, 
    e: "Static method called on instance works same as on class.",
    de: `Static methods work the same whether called on an instance or the class. If class MyClass: @staticmethod; def method(): return 'static'; obj = MyClass(); obj.method(), then obj.method() returns 'static' because static methods don't receive self or cls, so calling them on an instance works exactly the same as calling them on the class. The instance is ignored - the static method is just a regular function accessed through the class namespace.

Static method on instance:
• obj.method() returns 'static'
• obj.method() calls static method on instance
• Static method doesn't use instance
• Works same as MyClass.method()
• Returns: 'static'

How it works:
• obj.method() calls static method on instance
• @staticmethod ensures no self or cls passed
• Instance obj is ignored
• Method executes: return 'static'
• Returns: 'static' (same as MyClass.method())

Example:
class MyClass:
    @staticmethod
    def method():
        return 'static'
obj = MyClass()
obj.method()                 # 'static' (works on instance)
MyClass.method()             # 'static' (works on class, same result)

Common uses:
• Static methods: work on instance or class
• Utility functions: @staticmethod def helper(): ...
• No instance/class needed
• Consistent behavior

Example: If class MyClass: @staticmethod; def method(): return 'static'; obj = MyClass(); obj.method(), then obj.method() returns 'static' because static methods called on instances work the same as when called on the class - the instance is ignored.
`
  }),
  
  // 51-60: Special Methods (Magic Methods)
  (_i: number) => ({ 
    q: `What is class MyClass: def __str__(self): return 'str'; obj = MyClass(); str(obj)?`, 
    o: ["'str'", "Error", "None", "'MyClass'"], 
    c: 0, 
    e: "__str__ defines string representation for str().",
    de: `The __str__ method defines the string representation of an object for str() and print(). If class MyClass: def __str__(self): return 'str'; obj = MyClass(); str(obj), then str(obj) returns 'str' because __str__ is a special method that's called when you use str() or print() on an object. It should return a human-readable string representation of the object.

__str__ method:
• str(obj) returns 'str'
• __str__ defines string representation
• Called by str() and print()
• Should return human-readable string
• Returns: 'str'

How it works:
• obj = MyClass() creates instance
• str(obj) calls __str__ method
• __str__ executes: return 'str'
• Returns string representation
• Returns: 'str'

Example:
class MyClass:
    def __str__(self):
        return 'str'
obj = MyClass()
str(obj)                     # 'str' (uses __str__)
print(obj)                   # str (uses __str__)

Common uses:
• String representation: def __str__(self): return 'readable string'
• User-friendly output: print(obj) uses __str__
• Special methods
• Object representation

Example: If class MyClass: def __str__(self): return 'str'; obj = MyClass(); str(obj), then str(obj) returns 'str' because __str__ defines the string representation for str() and print().
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __repr__(self): return 'repr'; obj = MyClass(); repr(obj)?`, 
    o: ["'repr'", "Error", "None", "'MyClass'"], 
    c: 0, 
    e: "__repr__ defines string representation for repr().",
    de: `The __repr__ method defines the "official" string representation of an object for repr(). If class MyClass: def __repr__(self): return 'repr'; obj = MyClass(); repr(obj), then repr(obj) returns 'repr' because __repr__ is a special method that's called when you use repr() on an object. It should return an unambiguous string representation that ideally could be used to recreate the object. If __str__ is not defined, __repr__ is used as a fallback.

__repr__ method:
• repr(obj) returns 'repr'
• __repr__ defines official string representation
• Called by repr()
• Should return unambiguous string
• Used as fallback if __str__ not defined
• Returns: 'repr'

How it works:
• obj = MyClass() creates instance
• repr(obj) calls __repr__ method
• __repr__ executes: return 'repr'
• Returns official string representation
• Returns: 'repr'

Example:
class MyClass:
    def __repr__(self):
        return 'repr'
obj = MyClass()
repr(obj)                    # 'repr' (uses __repr__)

Common uses:
• Official representation: def __repr__(self): return 'unambiguous string'
• Debugging: repr(obj) shows official representation
• Special methods
• Object representation

Example: If class MyClass: def __repr__(self): return 'repr'; obj = MyClass(); repr(obj), then repr(obj) returns 'repr' because __repr__ defines the official string representation for repr().
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __str__(self): return 'str'; def __repr__(self): return 'repr'; obj = MyClass(); print(obj)?`, 
    o: ["str", "repr", "Error", "None"], 
    c: 0, 
    e: "print() uses __str__ if available.",
    de: `print() uses __str__ if available, falling back to __repr__ if __str__ is not defined. If class MyClass: def __str__(self): return 'str'; def __repr__(self): return 'repr'; obj = MyClass(); print(obj), then print(obj) outputs str because print() prefers __str__ over __repr__. When both are defined, __str__ is used for user-friendly output, while __repr__ is used for the official representation (e.g., in the REPL or for debugging).

print() uses __str__:
• print(obj) outputs str
• print() prefers __str__ over __repr__
• __str__ is for user-friendly output
• __repr__ is for official representation
• Returns: str (printed)

How it works:
• obj = MyClass() creates instance
• print(obj) calls __str__ method (preferred)
• __str__ executes: return 'str'
• print() outputs the string
• Output: str

Example:
class MyClass:
    def __str__(self):
        return 'str'
    def __repr__(self):
        return 'repr'
obj = MyClass()
print(obj)                   # str (uses __str__)
repr(obj)                    # 'repr' (uses __repr__)

Common uses:
• User-friendly output: print(obj) uses __str__
• Official representation: repr(obj) uses __repr__
• Special methods
• Object representation

Example: If class MyClass: def __str__(self): return 'str'; def __repr__(self): return 'repr'; obj = MyClass(); print(obj), then print(obj) outputs str because print() uses __str__ if available, preferring it over __repr__.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __len__(self): return 5; obj = MyClass(); len(obj)?`, 
    o: ["5", "Error", "None", "0"], 
    c: 0, 
    e: "__len__ defines behavior for len().",
    de: `The __len__ method defines the behavior for len(). If class MyClass: def __len__(self): return 5; obj = MyClass(); len(obj), then len(obj) returns 5 because __len__ is a special method that's called when you use len() on an object. It should return a non-negative integer representing the "length" of the object. This is commonly used for container-like objects (lists, strings, custom collections).

__len__ method:
• len(obj) returns 5
• __len__ defines length behavior
• Called by len()
• Should return non-negative integer
• Returns: 5

How it works:
• obj = MyClass() creates instance
• len(obj) calls __len__ method
• __len__ executes: return 5
• Returns length value
• Returns: 5

Example:
class MyClass:
    def __len__(self):
        return 5
obj = MyClass()
len(obj)                     # 5 (uses __len__)

Common uses:
• Length definition: def __len__(self): return length
• Container-like objects: len(obj) for custom collections
• Special methods
• Object length

Example: If class MyClass: def __len__(self): return 5; obj = MyClass(); len(obj), then len(obj) returns 5 because __len__ defines the behavior for len().
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "__eq__ defines behavior for == operator.",
    de: `The __eq__ method defines the behavior for the == operator. If class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2, then obj1 == obj2 returns True because __eq__ is a special method that's called when you use == to compare objects. By default (without __eq__), == compares object identity (same as is), but __eq__ allows you to define custom equality logic.

__eq__ method:
• obj1 == obj2 returns True
• __eq__ defines == behavior
• Called by == operator
• Can define custom equality logic
• Returns: True

How it works:
• obj1 == obj2 uses == operator
• Python calls obj1.__eq__(obj2)
• __eq__ executes: return True
• Returns comparison result
• Returns: True

Example:
class MyClass:
    def __eq__(self, other):
        return True  # Always equal
obj1 = MyClass(); obj2 = MyClass()
obj1 == obj2                # True (uses __eq__)

Common uses:
• Custom equality: def __eq__(self, other): return self.value == other.value
• Value comparison: == compares values, not identity
• Special methods
• Operator overloading

Example: If class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2, then obj1 == obj2 returns True because __eq__ defines the behavior for the == operator.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __lt__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 < obj2?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "__lt__ defines behavior for < operator.",
    de: `The __lt__ method defines the behavior for the < (less than) operator. If class MyClass: def __lt__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 < obj2, then obj1 < obj2 returns True because __lt__ is a special method that's called when you use < to compare objects. This is used for ordering and sorting. Python can automatically provide other comparison operators (>, <=, >=) if you define __lt__ and __eq__, or you can define them explicitly.

__lt__ method:
• obj1 < obj2 returns True
• __lt__ defines < behavior
• Called by < operator
• Used for ordering/sorting
• Returns: True

How it works:
• obj1 < obj2 uses < operator
• Python calls obj1.__lt__(obj2)
• __lt__ executes: return True
• Returns comparison result
• Returns: True

Example:
class MyClass:
    def __lt__(self, other):
        return True  # Always less than
obj1 = MyClass(); obj2 = MyClass()
obj1 < obj2                 # True (uses __lt__)

Common uses:
• Custom ordering: def __lt__(self, other): return self.value < other.value
• Sorting: objects can be sorted using <
• Special methods
• Operator overloading

Example: If class MyClass: def __lt__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 < obj2, then obj1 < obj2 returns True because __lt__ defines the behavior for the < operator.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __add__(self, other): return 10; obj1 = MyClass(); obj2 = MyClass(); obj1 + obj2?`, 
    o: ["10", "Error", "None", "0"], 
    c: 0, 
    e: "__add__ defines behavior for + operator.",
    de: `The __add__ method defines the behavior for the + operator. If class MyClass: def __add__(self, other): return 10; obj1 = MyClass(); obj2 = MyClass(); obj1 + obj2, then obj1 + obj2 returns 10 because __add__ is a special method that's called when you use + to add objects. This allows you to define custom addition behavior for your objects, making them work with the + operator.

__add__ method:
• obj1 + obj2 returns 10
• __add__ defines + behavior
• Called by + operator
• Can define custom addition
• Returns: 10

How it works:
• obj1 + obj2 uses + operator
• Python calls obj1.__add__(obj2)
• __add__ executes: return 10
• Returns addition result
• Returns: 10

Example:
class MyClass:
    def __add__(self, other):
        return 10  # Custom addition
obj1 = MyClass(); obj2 = MyClass()
obj1 + obj2                # 10 (uses __add__)

Common uses:
• Custom addition: def __add__(self, other): return self.value + other.value
• Operator overloading: objects work with + operator
• Special methods
• Arithmetic operations

Example: If class MyClass: def __add__(self, other): return 10; obj1 = MyClass(); obj2 = MyClass(); obj1 + obj2, then obj1 + obj2 returns 10 because __add__ defines the behavior for the + operator.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __getitem__(self, key): return key * 2; obj = MyClass(); obj[5]?`, 
    o: ["10", "5", "Error", "None"], 
    c: 0, 
    e: "__getitem__ defines behavior for [] indexing.",
    de: `The __getitem__ method defines the behavior for [] indexing. If class MyClass: def __getitem__(self, key): return key * 2; obj = MyClass(); obj[5], then obj[5] returns 10 because __getitem__ is a special method that's called when you use [] to access elements. This allows you to make your objects work like sequences or mappings (like lists or dictionaries). The key parameter can be an index, a slice, or any other value depending on your use case.

__getitem__ method:
• obj[5] returns 10
• __getitem__ defines [] indexing behavior
• Called by [] operator
• key parameter is the index/key
• Returns: key * 2 = 5 * 2 = 10

How it works:
• obj[5] uses [] indexing
• Python calls obj.__getitem__(5)
• __getitem__ executes: return key * 2
• Evaluates: 5 * 2 = 10
• Returns: 10

Example:
class MyClass:
    def __getitem__(self, key):
        return key * 2
obj = MyClass()
obj[5]                      # 10 (uses __getitem__)

Common uses:
• Indexing: def __getitem__(self, key): return self.data[key]
• Sequence-like objects: make objects work like lists
• Special methods
• Operator overloading

Example: If class MyClass: def __getitem__(self, key): return key * 2; obj = MyClass(); obj[5], then obj[5] returns 10 because __getitem__ defines the behavior for [] indexing, and key * 2 = 5 * 2 = 10.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __setitem__(self, key, value): self.data = {key: value}; obj = MyClass(); obj[5] = 10; obj.data?`, 
    o: ["{5: 10}", "Error", "None", "{}"], 
    c: 0, 
    e: "__setitem__ defines behavior for [] assignment.",
    de: `The __setitem__ method defines the behavior for [] assignment. If class MyClass: def __setitem__(self, key, value): self.data = {key: value}; obj = MyClass(); obj[5] = 10; obj.data, then obj.data returns {5: 10} because __setitem__ is a special method that's called when you use [] to assign values. This allows you to make your objects work like mutable sequences or mappings. The key parameter is the index/key, and value is the value being assigned.

__setitem__ method:
• obj[5] = 10 calls __setitem__
• __setitem__ defines [] assignment behavior
• Called by [] = assignment
• key = 5, value = 10
• Sets self.data = {5: 10}
• Returns: {5: 10}

How it works:
• obj[5] = 10 uses [] assignment
• Python calls obj.__setitem__(5, 10)
• __setitem__ executes: self.data = {key: value}
• Sets self.data = {5: 10}
• obj.data returns {5: 10}

Example:
class MyClass:
    def __setitem__(self, key, value):
        self.data = {key: value}
obj = MyClass()
obj[5] = 10                 # Calls __setitem__(5, 10)
obj.data                    # {5: 10}

Common uses:
• Assignment: def __setitem__(self, key, value): self.data[key] = value
• Mutable objects: make objects work like dictionaries
• Special methods
• Operator overloading

Example: If class MyClass: def __setitem__(self, key, value): self.data = {key: value}; obj = MyClass(); obj[5] = 10; obj.data, then obj.data returns {5: 10} because __setitem__ defines the behavior for [] assignment, and it sets self.data = {5: 10}.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __call__(self): return 'called'; obj = MyClass(); obj()?`, 
    o: ["'called'", "Error", "None", "'MyClass'"], 
    c: 0, 
    e: "__call__ makes instance callable.",
    de: `The __call__ method makes an instance callable (like a function). If class MyClass: def __call__(self): return 'called'; obj = MyClass(); obj(), then obj() returns 'called' because __call__ is a special method that's called when you use () to call an instance. This allows you to make objects that behave like functions - you can call them with parentheses. This is useful for callable objects, function-like classes, or implementing the callable pattern.

__call__ method:
• obj() returns 'called'
• __call__ makes instance callable
• Called by () operator
• Instance can be called like function
• Returns: 'called'

How it works:
• obj() calls instance like function
• Python calls obj.__call__()
• __call__ executes: return 'called'
• Returns call result
• Returns: 'called'

Example:
class MyClass:
    def __call__(self):
        return 'called'
obj = MyClass()
obj()                        # 'called' (instance is callable)

Common uses:
• Callable objects: def __call__(self, *args): return result
• Function-like classes: make classes work like functions
• Special methods
• Operator overloading

Example: If class MyClass: def __call__(self): return 'called'; obj = MyClass(); obj(), then obj() returns 'called' because __call__ makes an instance callable, allowing you to call it like a function.
`
  }),
  
  // 61-70: Property Decorator
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return 1; obj = MyClass(); obj.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "@property makes method accessible as attribute.",
    de: `The @property decorator makes a method accessible as an attribute. If class MyClass: @property; def x(self): return 1; obj = MyClass(); obj.x, then obj.x returns 1 because @property converts the method x() into a property, allowing you to access it like an attribute (without parentheses). This provides a clean interface for computed properties or attributes with getters/setters.

@property decorator:
• obj.x returns 1
• @property makes method accessible as attribute
• No parentheses needed: obj.x (not obj.x())
• Method is called automatically
• Returns: 1

How it works:
• @property decorator modifies method
• Method becomes property (accessible as attribute)
• obj.x accesses property (calls method automatically)
• Method executes: return 1
• Returns: 1

Example:
class MyClass:
    @property
    def x(self):
        return 1
obj = MyClass()
obj.x                        # 1 (accessed as attribute, not method)

Common uses:
• Computed properties: @property def area(self): return self.width * self.height
• Clean interface: obj.attr instead of obj.get_attr()
• Properties
• Attribute-like access

Example: If class MyClass: @property; def x(self): return 1; obj = MyClass(); obj.x, then obj.x returns 1 because @property makes the method accessible as an attribute, so you can access it without parentheses.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return 1; obj = MyClass(); obj.x = 2?`, 
    o: ["AttributeError", "2", "Error", "None"], 
    c: 0, 
    e: "Property without setter is read-only.",
    de: `A property without a setter is read-only - you cannot assign to it. If class MyClass: @property; def x(self): return 1; obj = MyClass(); obj.x = 2, then obj.x = 2 raises an AttributeError because the property only has a getter (defined by @property), but no setter. To make a property writable, you need to define a setter using @x.setter. Without a setter, the property is read-only.

Property without setter:
• obj.x = 2 raises AttributeError
• Property only has getter (no setter)
• Cannot assign to read-only property
• Raises AttributeError: can't set attribute
• Error: AttributeError

How it works:
• obj.x = 2 attempts to assign to property
• Property has no setter defined
• Python cannot set read-only property
• Raises AttributeError: can't set attribute

Example:
class MyClass:
    @property
    def x(self):
        return 1
obj = MyClass()
obj.x                        # 1 (read works)
obj.x = 2                    # AttributeError (no setter, read-only)

Common uses:
• Read-only properties: @property def value(self): return self._value
• Computed properties: @property def area(self): return self.width * self.height
• Properties
• Attribute protection

Example: If class MyClass: @property; def x(self): return 1; obj = MyClass(); obj.x = 2, then obj.x = 2 raises an AttributeError because a property without a setter is read-only and cannot be assigned to.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return self._x; @x.setter; def x(self, value): self._x = value; obj = MyClass(); obj.x = 5; obj.x?`, 
    o: ["5", "Error", "None", "0"], 
    c: 0, 
    e: "@property with @setter allows read and write.",
    de: `A property with both a getter (@property) and a setter (@x.setter) allows both reading and writing. If class MyClass: @property; def x(self): return self._x; @x.setter; def x(self, value): self._x = value; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 5 because the property has a setter that stores the value in self._x, and the getter retrieves it. This provides controlled access to attributes with validation or transformation if needed.

Property with setter:
• obj.x = 5 assigns value (uses setter)
• obj.x returns 5 (uses getter)
• @property defines getter
• @x.setter defines setter
• Returns: 5

How it works:
• obj.x = 5 calls setter: @x.setter def x(self, value)
• Setter executes: self._x = value (stores 5)
• obj.x calls getter: @property def x(self)
• Getter executes: return self._x (returns 5)
• Returns: 5

Example:
class MyClass:
    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
obj = MyClass()
obj.x = 5                    # Uses setter
obj.x                        # 5 (uses getter)

Common uses:
• Read-write properties: @property with @setter
• Controlled access: validation in setter
• Properties
• Attribute access control

Example: If class MyClass: @property; def x(self): return self._x; @x.setter; def x(self, value): self._x = value; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 5 because the property has both a getter and setter, allowing read and write access.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return self._x; @x.setter; def x(self, value): self._x = value * 2; obj = MyClass(); obj.x = 5; obj.x?`, 
    o: ["10", "5", "Error", "None"], 
    c: 0, 
    e: "Setter can transform value before storing.",
    de: `A property setter can transform the value before storing it. If class MyClass: @property; def x(self): return self._x; @x.setter; def x(self, value): self._x = value * 2; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 10 because the setter multiplies the value by 2 before storing it (self._x = value * 2 = 5 * 2 = 10). This allows you to validate, transform, or process values before they're stored.

Setter transforms value:
• obj.x = 5 calls setter with value = 5
• Setter executes: self._x = value * 2 = 5 * 2 = 10
• obj.x calls getter: return self._x
• Returns stored value: 10
• Returns: 10

How it works:
• obj.x = 5 calls setter: @x.setter def x(self, value)
• Setter transforms: self._x = value * 2
• Evaluates: 5 * 2 = 10
• Stores: self._x = 10
• obj.x returns: 10

Example:
class MyClass:
    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, value):
        self._x = value * 2  # Transforms value
obj = MyClass()
obj.x = 5                    # Stores 10 (5 * 2)
obj.x                        # 10 (transformed value)

Common uses:
• Value transformation: @x.setter def x(self, value): self._x = transform(value)
• Validation: @x.setter def x(self, value): if valid: self._x = value
• Properties
• Attribute control

Example: If class MyClass: @property; def x(self): return self._x; @x.setter; def x(self, value): self._x = value * 2; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 10 because the setter transforms the value before storing it (5 * 2 = 10).
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return self._x; @x.deleter; def x(self): del self._x; obj = MyClass(); obj._x = 1; del obj.x; hasattr(obj, '_x')?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "@deleter defines behavior for del statement.",
    de: `The @x.deleter decorator defines the behavior for the del statement. If class MyClass: @property; def x(self): return self._x; @x.deleter; def x(self): del self._x; obj = MyClass(); obj._x = 1; del obj.x; hasattr(obj, '_x'), then hasattr(obj, '_x') returns False because @x.deleter defines what happens when you delete the property, and del obj.x calls the deleter, which deletes self._x. This provides controlled deletion of attributes.

@deleter decorator:
• del obj.x calls deleter
• @x.deleter defines deletion behavior
• Deleter executes: del self._x
• Attribute _x is deleted
• hasattr(obj, '_x') returns False

How it works:
• obj._x = 1 sets attribute
• del obj.x calls deleter: @x.deleter def x(self)
• Deleter executes: del self._x
• Attribute _x is deleted
• hasattr(obj, '_x') checks if attribute exists
• Returns: False

Example:
class MyClass:
    @property
    def x(self):
        return self._x
    @x.deleter
    def x(self):
        del self._x
obj = MyClass()
obj._x = 1
del obj.x                    # Calls deleter
hasattr(obj, '_x')          # False (deleted)

Common uses:
• Controlled deletion: @x.deleter def x(self): cleanup logic
• Property deletion: del obj.property (uses deleter)
• Properties
• Attribute management

Example: If class MyClass: @property; def x(self): return self._x; @x.deleter; def x(self): del self._x; obj = MyClass(); obj._x = 1; del obj.x; hasattr(obj, '_x'), then hasattr(obj, '_x') returns False because @x.deleter defines the behavior for del, and del obj.x calls the deleter, which deletes self._x.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; obj = MyClass(); obj.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Property can access private attribute (convention: _ prefix).",
    de: `Properties can access "private" attributes (convention: single underscore prefix). If class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; obj = MyClass(); obj.x, then obj.x returns 1 because the property getter accesses the private attribute self._x. The single underscore prefix (_x) is a convention indicating that the attribute is intended for internal use, but it's not enforced by Python - it's just a naming convention.

Property accesses private attribute:
• obj.x returns 1
• Property getter accesses self._x
• _x is private attribute (convention)
• Single underscore indicates internal use
• Returns: 1

How it works:
• __init__ sets self._x = 1
• obj.x calls property getter
• Getter executes: return self._x
• Accesses private attribute _x = 1
• Returns: 1

Example:
class MyClass:
    def __init__(self):
        self._x = 1  # Private attribute (convention)
    @property
    def x(self):
        return self._x  # Accesses private attribute
obj = MyClass()
obj.x                        # 1 (property accesses _x)

Common uses:
• Encapsulation: @property def value(self): return self._value
• Private attributes: _attr (convention, not enforced)
• Properties
• Attribute access control

Example: If class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; obj = MyClass(); obj.x, then obj.x returns 1 because properties can access private attributes (convention: _ prefix), and the getter returns self._x.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return 1; obj = MyClass(); MyClass.x?`, 
    o: ["<property object>", "1", "Error", "None"], 
    c: 0, 
    e: "Accessing property via class returns property object.",
    de: `Accessing a property via the class returns the property object itself, not the property value. If class MyClass: @property; def x(self): return 1; obj = MyClass(); MyClass.x, then MyClass.x returns <property object> because accessing a property through the class (not an instance) returns the property descriptor object, not the result of calling the getter. To get the value, you need to access it through an instance: obj.x.

Property via class:
• MyClass.x returns <property object>
• Accessing via class returns property object
• Property object is descriptor
• Not the property value
• Returns: <property object>

How it works:
• MyClass.x accesses property via class
• Property is descriptor object
• Returns property object (not value)
• obj.x would return value (1)
• Returns: <property object>

Example:
class MyClass:
    @property
    def x(self):
        return 1
MyClass.x                    # <property object> (property descriptor)
obj = MyClass()
obj.x                        # 1 (property value)

Common uses:
• Property descriptor: MyClass.attr (property object)
• Descriptors: properties are descriptor objects
• Properties
• Object introspection

Example: If class MyClass: @property; def x(self): return 1; obj = MyClass(); MyClass.x, then MyClass.x returns <property object> because accessing a property via the class returns the property descriptor object, not the property value.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = property(lambda self: 1); obj = MyClass(); obj.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "property() can be created with lambda.",
    de: `The property() function can be created with a lambda function. If class MyClass: x = property(lambda self: 1); obj = MyClass(); obj.x, then obj.x returns 1 because property() can take a function (or lambda) as the getter argument. This is an alternative way to create properties without using the @property decorator. The lambda function receives self as its argument and returns the property value.

property() with lambda:
• obj.x returns 1
• property(lambda self: 1) creates property
• Lambda is getter function
• Receives self, returns 1
• Returns: 1

How it works:
• property(lambda self: 1) creates property
• Lambda is getter: lambda self: 1
• obj.x accesses property
• Calls lambda with self = obj
• Lambda returns: 1
• Returns: 1

Example:
class MyClass:
    x = property(lambda self: 1)  # Property with lambda
obj = MyClass()
obj.x                        # 1 (lambda returns 1)

Common uses:
• Simple properties: x = property(lambda self: value)
• Alternative syntax: property() instead of @property
• Properties
• Property creation

Example: If class MyClass: x = property(lambda self: 1); obj = MyClass(); obj.x, then obj.x returns 1 because property() can be created with a lambda function, and the lambda serves as the getter.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return self._x if hasattr(self, '_x') else 0; obj = MyClass(); obj.x?`, 
    o: ["0", "Error", "None", "1"], 
    c: 0, 
    e: "Property can have default value if attribute doesn't exist.",
    de: `A property can have a default value if the underlying attribute doesn't exist. If class MyClass: @property; def x(self): return self._x if hasattr(self, '_x') else 0; obj = MyClass(); obj.x, then obj.x returns 0 because the property getter checks if self._x exists using hasattr(). If it doesn't exist, it returns the default value 0. This allows properties to work even when the underlying attribute hasn't been set yet.

Property with default:
• obj.x returns 0
• Property checks if _x exists
• hasattr(self, '_x') returns False
• Returns default value: 0
• Returns: 0

How it works:
• obj.x calls property getter
• Getter checks: hasattr(self, '_x')
• _x doesn't exist (not set)
• Returns default: 0
• Returns: 0

Example:
class MyClass:
    @property
    def x(self):
        return self._x if hasattr(self, '_x') else 0
obj = MyClass()
obj.x                        # 0 (default, _x doesn't exist)
obj._x = 5
obj.x                        # 5 (_x exists)

Common uses:
• Default values: @property def x(self): return self._x if hasattr(self, '_x') else default
• Computed defaults: properties with fallback values
• Properties
• Attribute defaults

Example: If class MyClass: @property; def x(self): return self._x if hasattr(self, '_x') else 0; obj = MyClass(); obj.x, then obj.x returns 0 because the property can have a default value if the attribute doesn't exist, and hasattr() checks for existence.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: @property; def x(self): return 1; @x.setter; def x(self, value): pass; obj = MyClass(); obj.x = 5; obj.x?`, 
    o: ["1", "5", "Error", "None"], 
    c: 0, 
    e: "Setter that doesn't store value doesn't change property.",
    de: `A setter that doesn't store the value doesn't change the property. If class MyClass: @property; def x(self): return 1; @x.setter; def x(self, value): pass; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 1 because the setter has pass (does nothing), so it doesn't store the value. The getter still returns 1, and the assignment obj.x = 5 has no effect because the setter doesn't actually store anything. The value 5 is passed to the setter but ignored.

Setter doesn't store:
• obj.x = 5 calls setter
• Setter executes: pass (does nothing)
• Value 5 is ignored (not stored)
• obj.x calls getter: return 1
• Returns: 1 (unchanged)

How it works:
• obj.x = 5 calls setter: @x.setter def x(self, value)
• Setter executes: pass (does nothing)
• Value 5 is not stored
• obj.x calls getter: @property def x(self)
• Getter returns: 1 (unchanged)
• Returns: 1

Example:
class MyClass:
    @property
    def x(self):
        return 1
    @x.setter
    def x(self, value):
        pass  # Doesn't store value
obj = MyClass()
obj.x = 5                    # Calls setter (ignores value)
obj.x                        # 1 (getter unchanged)

Common uses:
• Read-only simulation: setter that ignores values
• Validation-only setters: setter that validates but doesn't store
• Properties
• Attribute control

Example: If class MyClass: @property; def x(self): return 1; @x.setter; def x(self, value): pass; obj = MyClass(); obj.x = 5; obj.x, then obj.x returns 1 because a setter that doesn't store the value doesn't change the property, so the getter still returns 1.
`
  }),
  
  // 71-80: Object Attributes and Methods
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); obj.x = 1; getattr(obj, 'x')?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "getattr() gets attribute value.",
    de: `The getattr() function gets an attribute value from an object. If class MyClass: pass; obj = MyClass(); obj.x = 1; getattr(obj, 'x'), then getattr(obj, 'x') returns 1 because getattr() retrieves the value of the attribute 'x' from obj. It's equivalent to obj.x, but allows you to get attributes dynamically using a string name. This is useful when the attribute name is stored in a variable.

getattr() function:
• getattr(obj, 'x') returns 1
• getattr() gets attribute value
• Equivalent to obj.x
• Attribute name is string: 'x'
• Returns: 1

How it works:
• obj.x = 1 sets attribute x = 1
• getattr(obj, 'x') gets attribute 'x'
• Searches for attribute 'x' on obj
• Finds x = 1
• Returns: 1

Example:
class MyClass: pass
obj = MyClass()
obj.x = 1
getattr(obj, 'x')            # 1 (gets attribute 'x')
obj.x                        # 1 (equivalent)

Common uses:
• Dynamic access: getattr(obj, attr_name) (attr_name is variable)
• Attribute retrieval: getattr(obj, 'method')()
• Object introspection
• Dynamic attribute access

Example: If class MyClass: pass; obj = MyClass(); obj.x = 1; getattr(obj, 'x'), then getattr(obj, 'x') returns 1 because getattr() gets the attribute value from an object, equivalent to obj.x.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); getattr(obj, 'x', 0)?`, 
    o: ["0", "Error", "None", "1"], 
    c: 0, 
    e: "getattr() with default returns default if attribute missing.",
    de: `The getattr() function can take a default value that's returned if the attribute doesn't exist. If class MyClass: pass; obj = MyClass(); getattr(obj, 'x', 0), then getattr(obj, 'x', 0) returns 0 because obj doesn't have an attribute 'x', so getattr() returns the default value 0 instead of raising an AttributeError. This is useful for safely accessing attributes that might not exist.

getattr() with default:
• getattr(obj, 'x', 0) returns 0
• obj doesn't have attribute 'x'
• getattr() returns default value: 0
• No AttributeError raised
• Returns: 0

How it works:
• getattr(obj, 'x', 0) gets attribute 'x'
• obj doesn't have attribute 'x'
• Attribute not found
• Returns default value: 0
• Returns: 0

Example:
class MyClass: pass
obj = MyClass()
getattr(obj, 'x', 0)         # 0 (default, 'x' doesn't exist)
getattr(obj, 'x')            # AttributeError (no default)
obj.x = 1
getattr(obj, 'x', 0)         # 1 (attribute exists)

Common uses:
• Safe access: getattr(obj, 'attr', default) (no error if missing)
• Default values: getattr(obj, 'value', 0)
• Object introspection
• Dynamic attribute access

Example: If class MyClass: pass; obj = MyClass(); getattr(obj, 'x', 0), then getattr(obj, 'x', 0) returns 0 because getattr() with a default returns the default value if the attribute is missing, preventing AttributeError.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); setattr(obj, 'x', 1); obj.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "setattr() sets attribute value.",
    de: `The setattr() function sets an attribute value on an object. If class MyClass: pass; obj = MyClass(); setattr(obj, 'x', 1); obj.x, then obj.x returns 1 because setattr() sets the attribute 'x' to 1 on obj. It's equivalent to obj.x = 1, but allows you to set attributes dynamically using a string name. This is useful when the attribute name is stored in a variable.

setattr() function:
• setattr(obj, 'x', 1) sets attribute
• obj.x returns 1
• Equivalent to obj.x = 1
• Attribute name is string: 'x'
• Returns: 1

How it works:
• setattr(obj, 'x', 1) sets attribute 'x' = 1
• Creates attribute on obj
• obj.x accesses attribute
• Returns: 1

Example:
class MyClass: pass
obj = MyClass()
setattr(obj, 'x', 1)         # Sets obj.x = 1
obj.x                        # 1 (attribute set)

Common uses:
• Dynamic assignment: setattr(obj, attr_name, value) (attr_name is variable)
• Attribute setting: setattr(obj, 'value', 5)
• Object introspection
• Dynamic attribute assignment

Example: If class MyClass: pass; obj = MyClass(); setattr(obj, 'x', 1); obj.x, then obj.x returns 1 because setattr() sets the attribute value on an object, equivalent to obj.x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); obj.x = 1; delattr(obj, 'x'); hasattr(obj, 'x')?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "delattr() deletes attribute.",
    de: `The delattr() function deletes an attribute from an object. If class MyClass: pass; obj = MyClass(); obj.x = 1; delattr(obj, 'x'); hasattr(obj, 'x'), then hasattr(obj, 'x') returns False because delattr() deletes the attribute 'x' from obj. It's equivalent to del obj.x, but allows you to delete attributes dynamically using a string name. After deletion, the attribute no longer exists.

delattr() function:
• delattr(obj, 'x') deletes attribute
• hasattr(obj, 'x') returns False
• Equivalent to del obj.x
• Attribute name is string: 'x'
• Returns: False

How it works:
• obj.x = 1 sets attribute x = 1
• delattr(obj, 'x') deletes attribute 'x'
• Attribute removed from obj
• hasattr(obj, 'x') checks if 'x' exists
• Returns: False

Example:
class MyClass: pass
obj = MyClass()
obj.x = 1
delattr(obj, 'x')            # Deletes obj.x
hasattr(obj, 'x')            # False (attribute deleted)

Common uses:
• Dynamic deletion: delattr(obj, attr_name) (attr_name is variable)
• Attribute removal: delattr(obj, 'value')
• Object introspection
• Dynamic attribute deletion

Example: If class MyClass: pass; obj = MyClass(); obj.x = 1; delattr(obj, 'x'); hasattr(obj, 'x'), then hasattr(obj, 'x') returns False because delattr() deletes the attribute from an object, equivalent to del obj.x.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); dir(obj)?`, 
    o: ["List of attribute names", "Error", "None", "()"], 
    c: 0, 
    e: "dir() returns list of object's attributes.",
    de: `The dir() function returns a list of attribute names for an object. If class MyClass: pass; obj = MyClass(); dir(obj), then dir(obj) returns a list of attribute names because dir() lists all attributes (methods, properties, instance attributes, class attributes) that are accessible on the object. This includes attributes from the object's class and its base classes. It's useful for introspection and discovering what attributes an object has.

dir() function:
• dir(obj) returns list of attribute names
• Lists all accessible attributes
• Includes methods, properties, attributes
• Includes class and base class attributes
• Returns: list

How it works:
• dir(obj) lists attributes on obj
• Searches instance attributes
• Searches class attributes
• Searches base class attributes
• Returns list of attribute names

Example:
class MyClass: pass
obj = MyClass()
dir(obj)                     # ['__class__', '__dict__', ...] (list of attributes)

Common uses:
• Introspection: dir(obj) (see all attributes)
• Discovery: find available methods/attributes
• Object inspection
• Attribute listing

Example: If class MyClass: pass; obj = MyClass(); dir(obj), then dir(obj) returns a list of attribute names because dir() lists all accessible attributes on an object, including methods, properties, and attributes from the class and base classes.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; obj = MyClass(); 'x' in dir(obj)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "dir() includes class attributes.",
    de: `The dir() function includes class attributes in its list. If class MyClass: x = 1; obj = MyClass(); 'x' in dir(obj), then 'x' in dir(obj) returns True because dir() includes class attributes (like x = 1) in addition to instance attributes. When you access dir(obj), it shows attributes from both the instance and the class, so class attributes are visible.

dir() includes class attributes:
• 'x' in dir(obj) returns True
• dir(obj) includes class attributes
• x = 1 is class attribute
• Visible in dir() output
• Returns: True

How it works:
• dir(obj) lists attributes
• Includes instance attributes
• Includes class attributes (x = 1)
• 'x' is in the list
• Returns: True

Example:
class MyClass: x = 1
obj = MyClass()
'x' in dir(obj)              # True (class attribute included)
dir(obj)                     # [..., 'x', ...] (includes class attribute)

Common uses:
• Attribute checking: 'attr' in dir(obj) (check if attribute exists)
• Introspection: dir(obj) shows class and instance attributes
• Object inspection
• Attribute discovery

Example: If class MyClass: x = 1; obj = MyClass(); 'x' in dir(obj), then 'x' in dir(obj) returns True because dir() includes class attributes in its list, so the class attribute x = 1 is visible.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): pass; obj = MyClass(); 'method' in dir(obj)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "dir() includes methods.",
    de: `The dir() function includes methods in its list. If class MyClass: def method(self): pass; obj = MyClass(); 'method' in dir(obj), then 'method' in dir(obj) returns True because dir() includes methods (like method()) in addition to attributes. Methods are attributes of the class, so they appear in dir() when called on an instance.

dir() includes methods:
• 'method' in dir(obj) returns True
• dir(obj) includes methods
• method() is class method
• Visible in dir() output
• Returns: True

How it works:
• dir(obj) lists attributes
• Includes instance attributes
• Includes class methods (method())
• 'method' is in the list
• Returns: True

Example:
class MyClass:
    def method(self): pass
obj = MyClass()
'method' in dir(obj)         # True (method included)
dir(obj)                     # [..., 'method', ...] (includes method)

Common uses:
• Method checking: 'method' in dir(obj) (check if method exists)
• Introspection: dir(obj) shows methods and attributes
• Object inspection
• Method discovery

Example: If class MyClass: def method(self): pass; obj = MyClass(); 'method' in dir(obj), then 'method' in dir(obj) returns True because dir() includes methods in its list, so the method() is visible.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); vars(obj)?`, 
    o: ["{}", "Error", "None", "()"], 
    c: 0, 
    e: "vars() returns __dict__ (instance attributes).",
    de: `The vars() function returns the __dict__ attribute, which contains instance attributes. If class MyClass: pass; obj = MyClass(); vars(obj), then vars(obj) returns {} because vars() returns obj.__dict__, which is a dictionary containing the instance's attributes. For a newly created instance with no attributes, __dict__ is empty, so vars() returns an empty dictionary.

vars() function:
• vars(obj) returns {}
• vars() returns __dict__
• __dict__ contains instance attributes
• Empty instance has empty __dict__
• Returns: {}

How it works:
• vars(obj) returns obj.__dict__
• __dict__ is dictionary of instance attributes
• obj has no instance attributes
• __dict__ is empty: {}
• Returns: {}

Example:
class MyClass: pass
obj = MyClass()
vars(obj)                    # {} (empty, no instance attributes)
obj.x = 1
vars(obj)                    # {'x': 1} (instance attributes)

Common uses:
• Instance attributes: vars(obj) (get __dict__)
• Attribute dictionary: vars(obj) shows instance attributes
• Object inspection
• Attribute access

Example: If class MyClass: pass; obj = MyClass(); vars(obj), then vars(obj) returns {} because vars() returns __dict__, which contains instance attributes, and an empty instance has an empty dictionary.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); vars(obj)?`, 
    o: ["{'x': 5}", "{}", "Error", "None"], 
    c: 0, 
    e: "vars() returns dictionary of instance attributes.",
    de: `The vars() function returns a dictionary of instance attributes. If class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); vars(obj), then vars(obj) returns {'x': 5} because vars() returns obj.__dict__, which is a dictionary containing all instance attributes. When __init__ sets self.x = 5, it creates an instance attribute x = 5, which is stored in __dict__.

vars() returns instance attributes:
• vars(obj) returns {'x': 5}
• vars() returns __dict__
• __dict__ contains instance attributes
• self.x = 5 creates instance attribute
• Returns: {'x': 5}

How it works:
• MyClass(5) calls __init__(self, 5)
• __init__ sets self.x = 5 (instance attribute)
• Instance attribute stored in obj.__dict__
• vars(obj) returns obj.__dict__
• Returns: {'x': 5}

Example:
class MyClass:
    def __init__(self, x):
        self.x = x
obj = MyClass(5)
vars(obj)                    # {'x': 5} (instance attributes)

Common uses:
• Instance attributes: vars(obj) (get __dict__)
• Attribute dictionary: vars(obj) shows all instance attributes
• Object inspection
• Attribute access

Example: If class MyClass: def __init__(self, x): self.x = x; obj = MyClass(5); vars(obj), then vars(obj) returns {'x': 5} because vars() returns __dict__, which contains instance attributes, and self.x = 5 creates an instance attribute.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; vars(MyClass)?`, 
    o: ["Dict with class attributes", "Error", "None", "{}"], 
    c: 0, 
    e: "vars() on class returns class __dict__.",
    de: `The vars() function can be called on a class, returning the class's __dict__. If class MyClass: x = 1; vars(MyClass), then vars(MyClass) returns a dictionary with class attributes because vars() returns MyClass.__dict__, which contains class attributes, methods, and other class-level data. This includes x = 1 and other class-level definitions.

vars() on class:
• vars(MyClass) returns dict with class attributes
• vars() returns class __dict__
• __dict__ contains class attributes and methods
• Includes x = 1
• Returns: dict

How it works:
• vars(MyClass) returns MyClass.__dict__
• __dict__ is dictionary of class attributes
• Contains class attributes (x = 1)
• Contains methods and other class data
• Returns: dict

Example:
class MyClass: x = 1
vars(MyClass)                # {...'x': 1, ...} (class __dict__)

Common uses:
• Class attributes: vars(Class) (get class __dict__)
• Class dictionary: vars(Class) shows class attributes and methods
• Object inspection
• Class introspection

Example: If class MyClass: x = 1; vars(MyClass), then vars(MyClass) returns a dictionary with class attributes because vars() on a class returns the class's __dict__, which contains class attributes, methods, and other class-level data.
`
  }),
  
  // 81-90: Object Identity and Comparison
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 is obj2?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Different instances are not identical.",
    de: `The is operator checks object identity (whether two variables refer to the same object). If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 is obj2, then obj1 is obj2 returns False because obj1 and obj2 are different instances - each call to MyClass() creates a new, separate object. The is operator checks if two variables point to the same object in memory, not if they have the same value.

Different instances:
• obj1 is obj2 returns False
• obj1 and obj2 are different instances
• Each MyClass() creates new object
• is checks identity (same object)
• Returns: False

How it works:
• MyClass() creates first instance (obj1)
• MyClass() creates second instance (obj2)
• obj1 and obj2 are different objects
• obj1 is obj2 checks if same object
• Different objects, so returns: False

Example:
class MyClass: pass
obj1 = MyClass()             # Creates first instance
obj2 = MyClass()             # Creates second instance (different)
obj1 is obj2                 # False (different instances)

Common uses:
• Identity check: obj1 is obj2 (check if same object)
• Object comparison: if obj1 is obj2: (identity)
• Object identity
• Reference comparison

Example: If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 is obj2, then obj1 is obj2 returns False because different instances are not identical - each call to MyClass() creates a separate object.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj1 = MyClass(); obj2 = obj1; obj1 is obj2?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Same object reference is identical.",
    de: `When two variables refer to the same object, is returns True. If class MyClass: pass; obj1 = MyClass(); obj2 = obj1; obj1 is obj2, then obj1 is obj2 returns True because obj2 = obj1 assigns the same object reference to obj2, so both variables point to the same object. The is operator checks object identity, and since obj1 and obj2 refer to the same object, they are identical.

Same object reference:
• obj1 is obj2 returns True
• obj2 = obj1 assigns same reference
• Both variables point to same object
• is checks identity (same object)
• Returns: True

How it works:
• MyClass() creates instance (obj1)
• obj2 = obj1 assigns same reference
• obj1 and obj2 point to same object
• obj1 is obj2 checks if same object
• Same object, so returns: True

Example:
class MyClass: pass
obj1 = MyClass()             # Creates instance
obj2 = obj1                  # Assigns same reference
obj1 is obj2                 # True (same object)

Common uses:
• Reference check: obj1 is obj2 (check if same object)
• Object identity: if obj1 is obj2: (same reference)
• Object identity
• Reference comparison

Example: If class MyClass: pass; obj1 = MyClass(); obj2 = obj1; obj1 is obj2, then obj1 is obj2 returns True because the same object reference is identical - both variables point to the same object.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Default == compares identity (same as is).",
    de: `By default, the == operator compares object identity (same as is) if __eq__ is not defined. If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2, then obj1 == obj2 returns False because without a custom __eq__ method, == defaults to comparing object identity, which is the same as is. Since obj1 and obj2 are different instances, they are not equal. To define custom equality, you need to implement __eq__.

Default == behavior:
• obj1 == obj2 returns False
• No __eq__ defined
• == defaults to identity comparison (same as is)
• Different instances are not equal
• Returns: False

How it works:
• obj1 == obj2 uses == operator
• No __eq__ method defined
• Python uses default identity comparison
• Compares obj1 is obj2 (identity)
• Different objects, so returns: False

Example:
class MyClass: pass
obj1 = MyClass(); obj2 = MyClass()
obj1 == obj2                 # False (default: identity comparison)
obj1 is obj2                 # False (same result)

Common uses:
• Default comparison: == compares identity if no __eq__
• Custom equality: define __eq__ for value comparison
• Object comparison
• Equality operators

Example: If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2, then obj1 == obj2 returns False because the default == compares identity (same as is) when __eq__ is not defined, and different instances are not identical.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "__eq__ overrides == behavior.",
    de: `The __eq__ method overrides the default == behavior. If class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2, then obj1 == obj2 returns True because __eq__ is defined to always return True, overriding the default identity comparison. When you define __eq__, Python uses it for == comparisons instead of the default identity check.

__eq__ overrides ==:
• obj1 == obj2 returns True
• __eq__ defines == behavior
• __eq__ always returns True
• Overrides default identity comparison
• Returns: True

How it works:
• obj1 == obj2 uses == operator
• Python calls obj1.__eq__(obj2)
• __eq__ executes: return True
• Returns comparison result
• Returns: True

Example:
class MyClass:
    def __eq__(self, other):
        return True  # Always equal
obj1 = MyClass(); obj2 = MyClass()
obj1 == obj2                # True (uses __eq__)

Common uses:
• Custom equality: def __eq__(self, other): return self.value == other.value
• Value comparison: == compares values, not identity
• Special methods
• Operator overloading

Example: If class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 == obj2, then obj1 == obj2 returns True because __eq__ overrides the default == behavior, and it's defined to return True.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 != obj2?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "__ne__ defaults to not __eq__ if not defined.",
    de: `If __ne__ is not defined, Python automatically provides it as the negation of __eq__. If class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 != obj2, then obj1 != obj2 returns False because __ne__ is not defined, so Python uses not (obj1 == obj2), which is not True = False. This ensures that != is the logical opposite of ==.

__ne__ defaults to not __eq__:
• obj1 != obj2 returns False
• __ne__ not defined
• Python uses not (obj1 == obj2)
• obj1 == obj2 returns True (from __eq__)
• not True = False
• Returns: False

How it works:
• obj1 != obj2 uses != operator
• __ne__ not defined
• Python uses not (obj1 == obj2)
• obj1 == obj2 returns True (from __eq__)
• not True = False
• Returns: False

Example:
class MyClass:
    def __eq__(self, other):
        return True
obj1 = MyClass(); obj2 = MyClass()
obj1 != obj2                # False (not (obj1 == obj2) = not True)

Common uses:
• Automatic __ne__: Python provides not __eq__ if __ne__ not defined
• Logical consistency: != is opposite of ==
• Special methods
• Operator overloading

Example: If class MyClass: def __eq__(self, other): return True; obj1 = MyClass(); obj2 = MyClass(); obj1 != obj2, then obj1 != obj2 returns False because __ne__ defaults to not __eq__ if not defined, so not True = False.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __hash__(self): return 1; hash(MyClass())?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "__hash__ defines hash value.",
    de: `The __hash__ method defines the hash value for an object. If class MyClass: def __hash__(self): return 1; hash(MyClass()), then hash(MyClass()) returns 1 because __hash__ is a special method that's called when you use hash() on an object. The hash value is used for dictionary keys and set membership. Objects with __hash__ defined can be used as dictionary keys or added to sets.

__hash__ method:
• hash(MyClass()) returns 1
• __hash__ defines hash value
• Called by hash() function
• Returns hash value: 1
• Returns: 1

How it works:
• hash(MyClass()) calls hash() function
• Python calls instance.__hash__()
• __hash__ executes: return 1
• Returns hash value
• Returns: 1

Example:
class MyClass:
    def __hash__(self):
        return 1
hash(MyClass())              # 1 (uses __hash__)

Common uses:
• Hashable objects: def __hash__(self): return hash(self.value)
• Dictionary keys: objects with __hash__ can be dict keys
• Special methods
• Object hashing

Example: If class MyClass: def __hash__(self): return 1; hash(MyClass()), then hash(MyClass()) returns 1 because __hash__ defines the hash value for an object, used by hash().
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __eq__(self, other): return True; hash(MyClass())?`, 
    o: ["TypeError (unhashable)", "1", "Error", "None"], 
    c: 0, 
    e: "Defining __eq__ without __hash__ makes object unhashable.",
    de: `Defining __eq__ without __hash__ makes an object unhashable. If class MyClass: def __eq__(self, other): return True; hash(MyClass()), then hash(MyClass()) raises a TypeError because when you define __eq__ without __hash__, Python sets __hash__ to None, making the object unhashable. This prevents objects from being used as dictionary keys or added to sets. To make an object hashable, you must define both __eq__ and __hash__, or define neither.

__eq__ without __hash__:
• hash(MyClass()) raises TypeError
• __eq__ defined, __hash__ not defined
• Python sets __hash__ = None
• Object becomes unhashable
• Raises TypeError

How it works:
• hash(MyClass()) calls hash() function
• __eq__ is defined, __hash__ is not
• Python sets __hash__ = None (unhashable)
• hash() cannot hash unhashable object
• Raises TypeError: unhashable type

Example:
class MyClass:
    def __eq__(self, other):
        return True
hash(MyClass())              # TypeError (unhashable)

Common uses:
• Understanding hashability: __eq__ without __hash__ makes unhashable
• Hashable objects: define both __eq__ and __hash__
• Special methods
• Object hashing

Example: If class MyClass: def __eq__(self, other): return True; hash(MyClass()), then hash(MyClass()) raises a TypeError because defining __eq__ without __hash__ makes the object unhashable (Python sets __hash__ = None).
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __eq__(self, other): return True; def __hash__(self): return 1; {MyClass(): 1}?`, 
    o: ["{MyClass instance: 1}", "Error", "None", "{}"], 
    c: 0, 
    e: "Object with __hash__ can be dict key.",
    de: `Objects with __hash__ defined can be used as dictionary keys. If class MyClass: def __eq__(self, other): return True; def __hash__(self): return 1; {MyClass(): 1}, then {MyClass(): 1} creates a dictionary with a MyClass instance as a key because the object has both __eq__ and __hash__ defined, making it hashable. Hashable objects can be used as dictionary keys and added to sets.

Object with __hash__ as dict key:
• {MyClass(): 1} creates dictionary
• MyClass instance is hashable (has __hash__)
• Can be used as dictionary key
• Creates dict: {MyClass instance: 1}
• Returns: dict

How it works:
• MyClass() creates instance
• Instance has __eq__ and __hash__ (hashable)
• {MyClass(): 1} uses instance as key
• Dictionary created successfully
• Returns: {MyClass instance: 1}

Example:
class MyClass:
    def __eq__(self, other):
        return True
    def __hash__(self):
        return 1
{MyClass(): 1}               # {MyClass instance: 1} (hashable, can be key)

Common uses:
• Dictionary keys: {obj: value} (obj must be hashable)
• Sets: {obj} (obj must be hashable)
• Hashable objects
• Object hashing

Example: If class MyClass: def __eq__(self, other): return True; def __hash__(self): return 1; {MyClass(): 1}, then {MyClass(): 1} creates a dictionary because objects with __hash__ defined can be used as dictionary keys.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; id(MyClass())?`, 
    o: ["Unique integer id", "Error", "None", "0"], 
    c: 0, 
    e: "id() returns unique identifier for object.",
    de: `The id() function returns a unique integer identifier for an object. If class MyClass: pass; id(MyClass()), then id(MyClass()) returns a unique integer id because id() returns the memory address (or a unique identifier) of the object. Each object has a unique id, and the id remains constant for the object's lifetime. The id is used internally by Python for object identity checks (is operator uses id()).

id() function:
• id(MyClass()) returns unique integer id
• id() returns object identifier
• Unique for each object
• Represents memory address/identifier
• Returns: integer

How it works:
• MyClass() creates instance
• id(instance) gets object identifier
• Returns unique integer
• Used for identity checks
• Returns: unique integer id

Example:
class MyClass: pass
id(MyClass())                # 140234567890 (unique integer id)
obj = MyClass()
id(obj)                      # 140234567891 (different id)

Common uses:
• Object identity: id(obj1) == id(obj2) (same as obj1 is obj2)
• Unique identifier: id(obj) (object's unique id)
• Object identity
• Memory address

Example: If class MyClass: pass; id(MyClass()), then id(MyClass()) returns a unique integer id because id() returns a unique identifier for an object, representing its memory address or identifier.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); id(obj1) == id(obj2)?`, 
    o: ["False", "True", "Error", "None"], 
    c: 0, 
    e: "Different objects have different ids.",
    de: `Different objects have different ids. If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); id(obj1) == id(obj2), then id(obj1) == id(obj2) returns False because obj1 and obj2 are different instances, so they have different ids. Each object has a unique id that distinguishes it from all other objects. The id() function returns a unique identifier for each object, and different objects always have different ids.

Different objects, different ids:
• id(obj1) == id(obj2) returns False
• obj1 and obj2 are different instances
• Each object has unique id
• Different objects have different ids
• Returns: False

How it works:
• MyClass() creates first instance (obj1)
• MyClass() creates second instance (obj2)
• id(obj1) gets obj1's unique id
• id(obj2) gets obj2's unique id
• Different objects, different ids
• Returns: False

Example:
class MyClass: pass
obj1 = MyClass()             # id(obj1) = 140234567890
obj2 = MyClass()             # id(obj2) = 140234567891 (different)
id(obj1) == id(obj2)         # False (different ids)

Common uses:
• Identity check: id(obj1) == id(obj2) (same as obj1 is obj2)
• Unique identifiers: different objects have different ids
• Object identity
• Memory addresses

Example: If class MyClass: pass; obj1 = MyClass(); obj2 = MyClass(); id(obj1) == id(obj2), then id(obj1) == id(obj2) returns False because different objects have different ids - each object has a unique identifier.
`
  }),
  
  // 91-100: Advanced Class Features
  (_i: number) => ({ 
    q: `What is class MyClass: __slots__ = ['x', 'y']; obj = MyClass(); obj.x = 1; obj.z = 2?`, 
    o: ["AttributeError", "Works fine", "Error", "None"], 
    c: 0, 
    e: "__slots__ restricts allowed attributes.",
    de: `The __slots__ attribute restricts which attributes can be set on instances. If class MyClass: __slots__ = ['x', 'y']; obj = MyClass(); obj.x = 1; obj.z = 2, then obj.z = 2 raises an AttributeError because __slots__ only allows 'x' and 'y' as instance attributes. Any attempt to set an attribute not in __slots__ raises an AttributeError. This saves memory by preventing the creation of __dict__ for instances.

__slots__ restriction:
• obj.z = 2 raises AttributeError
• __slots__ = ['x', 'y'] restricts allowed attributes
• Only 'x' and 'y' allowed
• 'z' not in __slots__
• Raises AttributeError

How it works:
• obj.x = 1 works (x in __slots__)
• obj.z = 2 attempts to set 'z'
• 'z' not in __slots__ = ['x', 'y']
• Attribute not allowed
• Raises AttributeError: 'MyClass' object has no attribute 'z'

Example:
class MyClass:
    __slots__ = ['x', 'y']
obj = MyClass()
obj.x = 1                    # Works (x in __slots__)
obj.z = 2                    # AttributeError (z not in __slots__)

Common uses:
• Memory optimization: __slots__ = ['attr1', 'attr2'] (saves memory)
• Attribute restriction: prevent dynamic attributes
• Class optimization
• Memory efficiency

Example: If class MyClass: __slots__ = ['x', 'y']; obj = MyClass(); obj.x = 1; obj.z = 2, then obj.z = 2 raises an AttributeError because __slots__ restricts allowed attributes to only those listed, and 'z' is not in __slots__.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: __slots__ = ['x']; obj = MyClass(); obj.x = 1; vars(obj)?`, 
    o: ["AttributeError (no __dict__)", "{}", "Error", "None"], 
    c: 0, 
    e: "__slots__ removes __dict__ (saves memory).",
    de: `Using __slots__ removes the __dict__ attribute from instances, saving memory. If class MyClass: __slots__ = ['x']; obj = MyClass(); obj.x = 1; vars(obj), then vars(obj) raises an AttributeError because __slots__ prevents the creation of __dict__ for instances. vars() returns __dict__, but instances with __slots__ don't have __dict__, so it raises an error. This is the memory-saving benefit of __slots__ - instances don't need a dictionary to store attributes.

__slots__ removes __dict__:
• vars(obj) raises AttributeError
• __slots__ prevents __dict__ creation
• Instances don't have __dict__
• vars() requires __dict__
• Raises AttributeError

How it works:
• obj.x = 1 sets attribute (stored in slots, not __dict__)
• vars(obj) tries to access __dict__
• Instance has no __dict__ (__slots__ prevents it)
• vars() cannot access non-existent __dict__
• Raises AttributeError: 'MyClass' object has no attribute '__dict__'

Example:
class MyClass:
    __slots__ = ['x']
obj = MyClass()
obj.x = 1
vars(obj)                    # AttributeError (no __dict__)

Common uses:
• Memory optimization: __slots__ removes __dict__ (saves memory)
• Fixed attributes: __slots__ = ['attr1', 'attr2'] (no dynamic attributes)
• Class optimization
• Memory efficiency

Example: If class MyClass: __slots__ = ['x']; obj = MyClass(); obj.x = 1; vars(obj), then vars(obj) raises an AttributeError because __slots__ removes __dict__ from instances, and vars() requires __dict__.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def __init__(self): self.x = 1; obj = MyClass(); obj.__dict__?`, 
    o: ["{'x': 1}", "{}", "Error", "None"], 
    c: 0, 
    e: "__dict__ contains instance attributes.",
    de: `The __dict__ attribute contains a dictionary of instance attributes. If class MyClass: def __init__(self): self.x = 1; obj = MyClass(); obj.__dict__, then obj.__dict__ returns {'x': 1} because __dict__ is a dictionary that stores all instance attributes. When __init__ sets self.x = 1, it creates an instance attribute that's stored in obj.__dict__. This is how Python stores instance attributes internally.

__dict__ contains instance attributes:
• obj.__dict__ returns {'x': 1}
• __dict__ is dictionary of instance attributes
• self.x = 1 creates instance attribute
• Stored in obj.__dict__
• Returns: {'x': 1}

How it works:
• MyClass() calls __init__(self)
• __init__ sets self.x = 1 (instance attribute)
• Instance attribute stored in obj.__dict__
• obj.__dict__ contains {'x': 1}
• Returns: {'x': 1}

Example:
class MyClass:
    def __init__(self):
        self.x = 1
obj = MyClass()
obj.__dict__                 # {'x': 1} (instance attributes)

Common uses:
• Instance attributes: obj.__dict__ (get all instance attributes)
• Attribute dictionary: obj.__dict__ shows instance data
• Object inspection
• Attribute access

Example: If class MyClass: def __init__(self): self.x = 1; obj = MyClass(); obj.__dict__, then obj.__dict__ returns {'x': 1} because __dict__ contains instance attributes, and self.x = 1 creates an instance attribute stored in __dict__.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: x = 1; MyClass.__dict__?`, 
    o: ["Dict with class attributes and methods", "{}", "Error", "None"], 
    c: 0, 
    e: "__dict__ on class contains class attributes.",
    de: `The __dict__ attribute on a class contains class attributes and methods. If class MyClass: x = 1; MyClass.__dict__, then MyClass.__dict__ returns a dictionary with class attributes and methods because __dict__ on a class stores all class-level data, including class attributes (like x = 1), methods, and other class metadata. This is the namespace dictionary for the class.

Class __dict__:
• MyClass.__dict__ returns dict with class attributes
• __dict__ contains class-level data
• Includes class attributes (x = 1)
• Includes methods and metadata
• Returns: dict

How it works:
• class MyClass: x = 1 creates class
• Class attributes stored in MyClass.__dict__
• __dict__ contains 'x': 1 and other class data
• Returns dictionary of class attributes
• Returns: dict

Example:
class MyClass: x = 1
MyClass.__dict__             # {...'x': 1, ...} (class attributes and methods)

Common uses:
• Class attributes: MyClass.__dict__ (get all class attributes)
• Class dictionary: MyClass.__dict__ shows class data
• Object inspection
• Class introspection

Example: If class MyClass: x = 1; MyClass.__dict__, then MyClass.__dict__ returns a dictionary with class attributes because __dict__ on a class contains class attributes, methods, and other class-level data.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: def method(self): pass; 'method' in MyClass.__dict__?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Methods are in class __dict__.",
    de: `Methods are stored in the class __dict__. If class MyClass: def method(self): pass; 'method' in MyClass.__dict__, then 'method' in MyClass.__dict__ returns True because methods are class attributes, so they're stored in the class's __dict__. When you define a method in a class, it becomes an attribute of the class, stored in MyClass.__dict__.

Methods in class __dict__:
• 'method' in MyClass.__dict__ returns True
• Methods are class attributes
• Stored in class __dict__
• 'method' is in the dictionary
• Returns: True

How it works:
• def method(self): pass defines method
• Method becomes class attribute
• Stored in MyClass.__dict__
• 'method' in MyClass.__dict__ checks if key exists
• Returns: True

Example:
class MyClass:
    def method(self): pass
'method' in MyClass.__dict__  # True (method in class __dict__)

Common uses:
• Method checking: 'method' in MyClass.__dict__ (check if method exists)
• Class introspection: MyClass.__dict__ shows methods
• Object inspection
• Method discovery

Example: If class MyClass: def method(self): pass; 'method' in MyClass.__dict__, then 'method' in MyClass.__dict__ returns True because methods are stored in the class __dict__ as class attributes.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; obj = MyClass(); type(obj)?`, 
    o: ["<class '__main__.MyClass'>", "<class 'type'>", "Error", "None"], 
    c: 0, 
    e: "type() returns class of instance.",
    de: `The type() function returns the class of an instance. If class MyClass: pass; obj = MyClass(); type(obj), then type(obj) returns <class '__main__.MyClass'> because type() returns the class that an instance belongs to. For an instance of MyClass, type() returns the MyClass class object. This is useful for type checking and introspection.

type() on instance:
• type(obj) returns <class '__main__.MyClass'>
• type() returns class of instance
• obj is instance of MyClass
• Returns class object
• Returns: <class '__main__.MyClass'>

How it works:
• obj = MyClass() creates instance
• type(obj) gets class of instance
• Instance belongs to MyClass class
• Returns class object
• Returns: <class '__main__.MyClass'>

Example:
class MyClass: pass
obj = MyClass()
type(obj)                    # <class '__main__.MyClass'> (class of instance)

Common uses:
• Type checking: if type(obj) == MyClass: ...
• Type inspection: print(type(instance))
• Object type
• Type identification

Example: If class MyClass: pass; obj = MyClass(); type(obj), then type(obj) returns <class '__main__.MyClass'> because type() returns the class that an instance belongs to.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; type(MyClass)?`, 
    o: ["<class 'type'>", "<class '__main__.MyClass'>", "Error", "None"], 
    c: 0, 
    e: "Classes are instances of type (metaclass).",
    de: `Classes are instances of type (the metaclass). If class MyClass: pass; type(MyClass), then type(MyClass) returns <class 'type'> because classes themselves are objects, and they are instances of the type class (the metaclass). In Python, everything is an object - classes are objects too, and they are instances of type. This is the foundation of Python's metaclass system.

Classes are instances of type:
• type(MyClass) returns <class 'type'>
• Classes are objects
• Classes are instances of type (metaclass)
• type is the class of classes
• Returns: <class 'type'>

How it works:
• class MyClass: pass creates class object
• MyClass is an object (instance of type)
• type(MyClass) gets class of MyClass
• MyClass is instance of type
• Returns: <class 'type'>

Example:
class MyClass: pass
type(MyClass)                # <class 'type'> (classes are instances of type)

Common uses:
• Metaclass understanding: classes are instances of type
• Type system: type is the class of classes
• Metaclasses
• Type system

Example: If class MyClass: pass; type(MyClass), then type(MyClass) returns <class 'type'> because classes are instances of type (the metaclass) - classes themselves are objects.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; issubclass(MyClass, object)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "All classes inherit from object by default.",
    de: `All classes in Python inherit from object by default. If class MyClass: pass; issubclass(MyClass, object), then issubclass(MyClass, object) returns True because even if you don't explicitly specify a parent class, Python automatically makes object the base class. This is why all classes have access to methods like __str__, __repr__, etc. - they inherit from object.

All classes inherit from object:
• issubclass(MyClass, object) returns True
• MyClass inherits from object (default)
• Even without explicit parent
• object is base class
• Returns: True

How it works:
• class MyClass: pass creates class
• No explicit parent class specified
• Python automatically makes object the base class
• issubclass(MyClass, object) checks inheritance
• Returns: True

Example:
class MyClass: pass
issubclass(MyClass, object)  # True (all classes inherit from object)

Common uses:
• Inheritance check: issubclass(Class, object) (always True)
• Base class: object is base of all classes
• Object-oriented programming
• Inheritance hierarchy

Example: If class MyClass: pass; issubclass(MyClass, object), then issubclass(MyClass, object) returns True because all classes inherit from object by default, even if not explicitly specified.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; isinstance(MyClass, type)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "Classes are instances of type.",
    de: `Classes are instances of type. If class MyClass: pass; isinstance(MyClass, type), then isinstance(MyClass, type) returns True because classes are objects, and they are instances of the type class. In Python, classes are created by the type metaclass, so every class is an instance of type. This is the foundation of Python's metaclass system - classes are objects created by type.

Classes are instances of type:
• isinstance(MyClass, type) returns True
• Classes are objects
• Classes are instances of type
• type is the class of classes
• Returns: True

How it works:
• class MyClass: pass creates class object
• MyClass is an object (instance of type)
• isinstance(MyClass, type) checks if MyClass is instance of type
• MyClass is instance of type
• Returns: True

Example:
class MyClass: pass
isinstance(MyClass, type)    # True (classes are instances of type)

Common uses:
• Metaclass understanding: classes are instances of type
• Type checking: isinstance(Class, type) (always True for classes)
• Metaclasses
• Type system

Example: If class MyClass: pass; isinstance(MyClass, type), then isinstance(MyClass, type) returns True because classes are instances of type - classes are objects created by the type metaclass.
`
  }),
  (_i: number) => ({ 
    q: `What is class MyClass: pass; MyClass.mro()?`, 
    o: ["Method Resolution Order list", "Error", "None", "[]"], 
    c: 0, 
    e: "mro() returns method resolution order (inheritance chain).",
    de: `The mro() method returns the Method Resolution Order (MRO) - the inheritance chain showing how Python searches for attributes and methods. If class MyClass: pass; MyClass.mro(), then MyClass.mro() returns a list showing the method resolution order because mro() returns the linearization of the inheritance hierarchy. For a simple class with no explicit parents, it shows [MyClass, object] - the class itself and its base class (object).

mro() method:
• MyClass.mro() returns Method Resolution Order list
• mro() returns inheritance chain
• Shows order Python searches for attributes
• [MyClass, object] for simple class
• Returns: list

How it works:
• MyClass.mro() calls mro() method
• mro() computes method resolution order
• Shows inheritance chain: [MyClass, object]
• Python searches in this order for attributes
• Returns: [MyClass, object]

Example:
class MyClass: pass
MyClass.mro()                # [<class '__main__.MyClass'>, <class 'object'>]

Common uses:
• Inheritance chain: MyClass.mro() (see inheritance order)
• Method resolution: understand how Python finds attributes
• Object-oriented programming
• Inheritance hierarchy

Example: If class MyClass: pass; MyClass.mro(), then MyClass.mro() returns a Method Resolution Order list because mro() returns the inheritance chain showing how Python searches for attributes and methods, typically [MyClass, object] for a simple class.
`
  }),
];

// --- LEVEL 9: WHALE (Inheritance, Polymorphism, Encapsulation) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level9Patterns = [
  // 1-10: Basic Inheritance
  (_i: number) => ({ 
    q: `What is inheritance?`, 
    o: ["Child class gets parent features", "Parent class gets child features", "Error", "Classes are independent"], 
    c: 0, 
    e: "Inheritance allows child to use parent features.",
    de: `Inheritance is a mechanism that allows a child class (subclass) to inherit features from a parent class (superclass). When you define class Child(Parent), the child class automatically gets access to the parent class's attributes and methods. This enables code reuse and creates an "is-a" relationship - a Child is a type of Parent. The child can use parent features as-is, or override them to provide different behavior. Inheritance is one of the core principles of object-oriented programming.

Inheritance concept:
• Child class gets parent features
• class Child(Parent): inherits from Parent
• Child can access parent attributes and methods
• Child can override parent methods
• Enables code reuse and "is-a" relationships

How it works:
• class Parent: defines parent class
• class Child(Parent): defines child class inheriting from Parent
• Child automatically gets Parent's attributes and methods
• Child can use parent features directly
• Child can override parent methods if needed

Example:
class Parent:
    x = 1
    def method(self):
        return 1
class Child(Parent):  # Inherits from Parent
    pass
Child.x                # 1 (inherits parent attribute)
Child().method()       # 1 (inherits parent method)

Common uses:
• Code reuse: class Child(Parent): (inherits parent features)
• "Is-a" relationships: class Dog(Animal): (Dog is an Animal)
• Inheritance hierarchy
• Object-oriented programming

Example: Inheritance is a mechanism that allows a child class to inherit features from a parent class, enabling the child to use parent attributes and methods while also allowing overrides for different behavior.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: x = 1; class Child(Parent): pass; Child.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Child class inherits parent class attributes.",
    de: `A child class inherits parent class attributes. If class Parent: x = 1; class Child(Parent): pass; Child.x, then Child.x returns 1 because inheritance allows the child class to access the parent class's attributes. When you define class Child(Parent), Child automatically gets access to Parent's class attributes, including x = 1. You can access parent class attributes through the child class directly.

Child inherits parent attributes:
• Child.x returns 1
• class Child(Parent): inherits from Parent
• Parent has class attribute x = 1
• Child inherits this attribute
• Returns: 1

How it works:
• class Parent: x = 1 creates class with class attribute
• class Child(Parent): pass creates child inheriting from Parent
• Child inherits Parent's class attributes
• Child.x accesses inherited attribute
• Returns: 1

Example:
class Parent: x = 1
class Child(Parent): pass
Child.x                        # 1 (inherits parent class attribute)
Parent.x                       # 1 (parent still has it)

Common uses:
• Inheriting attributes: class Child(Parent): (inherits parent attributes)
• Class attributes: child can access parent class attributes
• Inheritance
• Code reuse

Example: If class Parent: x = 1; class Child(Parent): pass; Child.x, then Child.x returns 1 because the child class inherits parent class attributes, so it can access Parent's class attribute x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): pass; Child().method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Child class inherits parent methods.",
    de: `A child class inherits parent methods. If class Parent: def method(self): return 1; class Child(Parent): pass; Child().method(), then Child().method() returns 1 because inheritance allows the child class to use the parent class's methods. When you create an instance of Child and call method(), Python looks for method in Child, doesn't find it, then looks in Parent and finds it. This is how method resolution works in inheritance.

Child inherits parent methods:
• Child().method() returns 1
• class Child(Parent): inherits from Parent
• Parent has method()
• Child inherits this method
• Returns: 1

How it works:
• Child().method() calls method on Child instance
• Python searches for method in Child (not found)
• Python searches for method in Parent (found)
• Calls Parent.method() with Child instance as self
• Returns: 1

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent): pass
Child().method()              # 1 (inherits parent method)

Common uses:
• Inheriting methods: class Child(Parent): (inherits parent methods)
• Method reuse: child can use parent methods directly
• Inheritance
• Code reuse

Example: If class Parent: def method(self): return 1; class Child(Parent): pass; Child().method(), then Child().method() returns 1 because the child class inherits parent methods, so instances of Child can call Parent's methods.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: pass; class Child(Parent): pass; issubclass(Child, Parent)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "issubclass() checks if class is subclass.",
    de: `The issubclass() function checks if a class is a subclass of another class. If class Parent: pass; class Child(Parent): pass; issubclass(Child, Parent), then issubclass(Child, Parent) returns True because Child inherits from Parent, making Child a subclass of Parent. issubclass() checks the inheritance relationship between classes, returning True if the first class inherits from (or is the same as) the second class.

issubclass() function:
• issubclass(Child, Parent) returns True
• issubclass() checks if Child is subclass of Parent
• Child inherits from Parent
• Child is subclass of Parent
• Returns: True

How it works:
• class Child(Parent): creates child inheriting from Parent
• issubclass(Child, Parent) checks inheritance
• Child is indeed a subclass of Parent
• Returns: True

Example:
class Parent: pass
class Child(Parent): pass
issubclass(Child, Parent)     # True (Child is subclass of Parent)

Common uses:
• Inheritance check: issubclass(Child, Parent) (check if subclass)
• Type checking: if issubclass(cls, Parent): ...
• Inheritance
• Type system

Example: If class Parent: pass; class Child(Parent): pass; issubclass(Child, Parent), then issubclass(Child, Parent) returns True because issubclass() checks if a class is a subclass of another class, and Child inherits from Parent.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: pass; class Child(Parent): pass; isinstance(Child(), Parent)?`, 
    o: ["True", "False", "Error", "None"], 
    c: 0, 
    e: "isinstance() checks if instance is of class (including parent).",
    de: `The isinstance() function checks if an instance is of a class (including parent classes). If class Parent: pass; class Child(Parent): pass; isinstance(Child(), Parent), then isinstance(Child(), Parent) returns True because isinstance() checks the entire inheritance chain. Since Child inherits from Parent, an instance of Child is also considered an instance of Parent. isinstance() is more flexible than type() == because it returns True for parent classes too.

isinstance() with inheritance:
• isinstance(Child(), Parent) returns True
• isinstance() checks inheritance chain
• Child() is instance of Child
• Child inherits from Parent
• Child() is also instance of Parent
• Returns: True

How it works:
• Child() creates instance of Child
• isinstance(instance, Parent) checks if instance is of Parent
• Child inherits from Parent
• Instance of Child is also instance of Parent
• Returns: True

Example:
class Parent: pass
class Child(Parent): pass
isinstance(Child(), Parent)   # True (Child inherits from Parent)
isinstance(Child(), Child)    # True (Child() is instance of Child)

Common uses:
• Type checking: if isinstance(obj, Parent): ... (works with inheritance)
• Polymorphism: isinstance(obj, BaseClass) (checks base classes)
• Inheritance
• Type system

Example: If class Parent: pass; class Child(Parent): pass; isinstance(Child(), Parent), then isinstance(Child(), Parent) returns True because isinstance() checks if an instance is of a class (including parent classes), and since Child inherits from Parent, an instance of Child is also an instance of Parent.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: pass; class Child(Parent): pass; Child.__bases__?`, 
    o: ["(<class '__main__.Parent'>,)", "()", "Error", "None"], 
    c: 0, 
    e: "__bases__ contains tuple of parent classes.",
    de: `The __bases__ attribute contains a tuple of parent classes. If class Parent: pass; class Child(Parent): pass; Child.__bases__, then Child.__bases__ returns (<class '__main__.Parent'>,) because __bases__ stores the parent classes that a class inherits from. For a class with a single parent, it returns a tuple with one element. For multiple inheritance, it contains all parent classes. This is useful for introspection to see what classes a class inherits from.

__bases__ attribute:
• Child.__bases__ returns (<class '__main__.Parent'>,)
• __bases__ contains tuple of parent classes
• Child inherits from Parent
• Returns tuple with Parent
• Returns: (<class '__main__.Parent'>,)

How it works:
• class Child(Parent): creates child inheriting from Parent
• Python stores parent classes in Child.__bases__
• __bases__ is tuple of parent classes
• Contains: (Parent,)
• Returns: (<class '__main__.Parent'>,)

Example:
class Parent: pass
class Child(Parent): pass
Child.__bases__               # (<class '__main__.Parent'>,) (parent classes)

Common uses:
• Inheritance inspection: Child.__bases__ (see parent classes)
• Introspection: check what a class inherits from
• Inheritance
• Type system

Example: If class Parent: pass; class Child(Parent): pass; Child.__bases__, then Child.__bases__ returns (<class '__main__.Parent'>,) because __bases__ contains a tuple of parent classes, and Child inherits from Parent.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: x = 1; class Child(Parent): pass; obj = Child(); obj.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Instance of child can access parent class attribute.",
    de: `An instance of a child class can access parent class attributes. If class Parent: x = 1; class Child(Parent): pass; obj = Child(); obj.x, then obj.x returns 1 because when you access an attribute on an instance, Python searches the inheritance chain. Since obj is an instance of Child and Child inherits from Parent, Python can access Parent's class attribute x = 1 through the child instance.

Instance accesses parent attribute:
• obj.x returns 1
• obj is instance of Child
• Child inherits from Parent
• Parent has class attribute x = 1
• obj.x accesses inherited attribute
• Returns: 1

How it works:
• obj = Child() creates instance of Child
• obj.x looks for attribute x
• Python searches: obj.__dict__ (not found) → Child.__dict__ (not found) → Parent.__dict__ (finds x = 1)
• Returns: 1

Example:
class Parent: x = 1
class Child(Parent): pass
obj = Child()
obj.x                        # 1 (accesses parent class attribute)

Common uses:
• Inherited attributes: obj.attr (accesses parent class attribute)
• Instance access: instances can access parent class attributes
• Inheritance
• Attribute access

Example: If class Parent: x = 1; class Child(Parent): pass; obj = Child(); obj.x, then obj.x returns 1 because an instance of a child class can access parent class attributes through the inheritance chain.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def __init__(self): self.x = 1; class Child(Parent): pass; Child().x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Child inherits parent __init__ if not overridden.",
    de: `A child class inherits the parent's __init__ method if it doesn't override it. If class Parent: def __init__(self): self.x = 1; class Child(Parent): pass; Child().x, then Child().x returns 1 because when you create an instance of Child, Python looks for __init__ in Child (doesn't find it), then looks in Parent and finds it. Parent.__init__ is called, setting self.x = 1 on the Child instance. This allows the child to use the parent's initialization logic.

Child inherits parent __init__:
• Child().x returns 1
• Child doesn't define __init__
• Python uses Parent.__init__
• Parent.__init__ sets self.x = 1
• Returns: 1

How it works:
• Child() creates instance and looks for __init__
• Child doesn't have __init__
• Python searches Parent, finds __init__
• Calls Parent.__init__(self) with Child instance
• Sets self.x = 1 on Child instance
• Returns: 1

Example:
class Parent:
    def __init__(self):
        self.x = 1
class Child(Parent): pass  # No __init__ defined
Child().x                  # 1 (inherits parent __init__)

Common uses:
• Inherited initialization: class Child(Parent): pass (uses parent __init__)
• Constructor inheritance: child can use parent __init__
• Inheritance
• Object initialization

Example: If class Parent: def __init__(self): self.x = 1; class Child(Parent): pass; Child().x, then Child().x returns 1 because the child inherits the parent's __init__ if not overridden, so Parent.__init__ is called when creating a Child instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: pass; class Child(Parent): pass; Parent.__subclasses__()?`, 
    o: ["[<class '__main__.Child'>]", "[]", "Error", "None"], 
    c: 0, 
    e: "__subclasses__() returns list of direct subclasses.",
    de: `The __subclasses__() method returns a list of direct subclasses of a class. If class Parent: pass; class Child(Parent): pass; Parent.__subclasses__(), then Parent.__subclasses__() returns [<class '__main__.Child'>] because __subclasses__() lists all classes that directly inherit from Parent. It only shows direct children, not grandchildren or deeper descendants. This is useful for introspection to see what classes inherit from a given class.

__subclasses__() method:
• Parent.__subclasses__() returns [<class '__main__.Child'>]
• __subclasses__() returns list of direct subclasses
• Child directly inherits from Parent
• Returns list with Child
• Returns: [<class '__main__.Child'>]

How it works:
• class Child(Parent): creates child inheriting from Parent
• Python tracks subclasses in Parent.__subclasses__
• __subclasses__() returns list of direct children
• Contains: [Child]
• Returns: [<class '__main__.Child'>]

Example:
class Parent: pass
class Child(Parent): pass
Parent.__subclasses__()      # [<class '__main__.Child'>] (direct subclasses)

Common uses:
• Subclass inspection: Parent.__subclasses__() (see direct children)
• Introspection: check what classes inherit from a class
• Inheritance
• Type system

Example: If class Parent: pass; class Child(Parent): pass; Parent.__subclasses__(), then Parent.__subclasses__() returns [<class '__main__.Child'>] because __subclasses__() returns a list of direct subclasses, and Child directly inherits from Parent.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: x = 1; class Child(Parent): x = 2; Child.x?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Child class attribute overrides parent attribute.",
    de: `A child class attribute overrides (hides) the parent class attribute. If class Parent: x = 1; class Child(Parent): x = 2; Child.x, then Child.x returns 2 because when a child class defines an attribute with the same name as a parent attribute, the child's attribute takes precedence. The child attribute shadows the parent attribute, so accessing Child.x returns the child's value (2), not the parent's value (1).

Child overrides parent attribute:
• Child.x returns 2
• Child defines class attribute x = 2
• Parent has class attribute x = 1
• Child's attribute shadows parent's
• Returns: 2

How it works:
• class Child(Parent): x = 2 defines child attribute
• Child has its own class attribute x = 2
• Child.x looks for attribute x
• Python finds x in Child.__dict__ first
• Returns: 2 (child's attribute, not parent's)

Example:
class Parent: x = 1
class Child(Parent): x = 2  # Overrides parent attribute
Child.x                     # 2 (child's attribute, not parent's)
Parent.x                    # 1 (parent's attribute unchanged)

Common uses:
• Attribute override: class Child(Parent): attr = value (overrides parent)
• Customization: child can override parent attributes
• Inheritance
• Attribute shadowing

Example: If class Parent: x = 1; class Child(Parent): x = 2; Child.x, then Child.x returns 2 because the child class attribute overrides the parent attribute, so the child's value (2) takes precedence over the parent's value (1).
`
  }),
  
  // 11-20: Method Overriding
  (_i: number) => ({ 
    q: `What is method overriding?`, 
    o: ["Child redefines parent method", "Parent redefines child method", "Error", "Methods cannot be redefined"], 
    c: 0, 
    e: "Overriding redefines parent method in child.",
    de: `Method overriding is when a child class redefines a method that already exists in the parent class. When a child class defines a method with the same name as a parent method, the child's method overrides (replaces) the parent's method. This allows the child to provide different behavior while keeping the same method name. When you call the method on a child instance, Python uses the child's version, not the parent's. This is a key feature of polymorphism - the same method name can have different implementations in different classes.

Method overriding:
• Child redefines parent method
• Same method name in parent and child
• Child's method takes precedence
• Provides different behavior
• Key feature of polymorphism

How it works:
• Parent defines method()
• Child defines method() with same name
• Child's method overrides parent's method
• Calling method() on Child instance uses Child's version
• Parent's method is hidden (but can be accessed via super())

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent):
    def method(self):
        return 2  # Overrides parent method
Child().method()  # 2 (uses child's version, not parent's)

Common uses:
• Customization: class Child(Parent): def method(self): return custom_behavior
• Polymorphism: same method name, different implementations
• Method overriding
• Object-oriented programming

Example: Method overriding is when a child class redefines a method that already exists in the parent class, allowing the child to provide different behavior while keeping the same method name.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): def method(self): return 2; Child().method()?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Child method overrides parent method.",
    de: `A child method overrides the parent method when it has the same name. If class Parent: def method(self): return 1; class Child(Parent): def method(self): return 2; Child().method(), then Child().method() returns 2 because the child's method overrides the parent's method. When Python looks for method() on a Child instance, it finds method() in Child first and uses that, never reaching the parent's method. The child's version takes precedence.

Child overrides parent method:
• Child().method() returns 2
• Child defines method() with same name
• Child's method overrides parent's method
• Child's version takes precedence
• Returns: 2

How it works:
• Child().method() calls method on Child instance
• Python searches for method in Child (found)
• Uses Child.method() (doesn't check Parent)
• Method executes: return 2
• Returns: 2

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent):
    def method(self):
        return 2  # Overrides parent
Child().method()              # 2 (uses child's method)
Parent().method()             # 1 (uses parent's method)

Common uses:
• Method override: class Child(Parent): def method(self): return new_value
• Customization: child provides different behavior
• Method overriding
• Polymorphism

Example: If class Parent: def method(self): return 1; class Child(Parent): def method(self): return 2; Child().method(), then Child().method() returns 2 because the child method overrides the parent method, so the child's version takes precedence.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Child().method()?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "super() calls parent method from child.",
    de: `The super() function allows a child method to call the parent method. If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Child().method(), then Child().method() returns 1 because super().method() calls the parent's method() even though the child has overridden it. super() provides a way to access parent class methods and attributes from within an overridden child method, allowing you to extend parent behavior rather than completely replace it.

super() calls parent method:
• Child().method() returns 1
• Child's method calls super().method()
• super() accesses parent class
• Calls Parent.method() from within child
• Returns: 1

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super().method()
• super() gets parent class (Parent)
• Calls Parent.method() with Child instance as self
• Parent.method() returns 1
• Returns: 1

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent):
    def method(self):
        return super().method()  # Calls parent method
Child().method()              # 1 (calls parent via super())

Common uses:
• Extending methods: def method(self): result = super().method(); return modified(result)
• Parent access: super().method() (call parent from child)
• Method overriding
• Inheritance

Example: If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Child().method(), then Child().method() returns 1 because super() calls the parent method from the child, allowing access to the parent's implementation.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method() + 1; Child().method()?`, 
    o: ["2", "1", "Error", "None"], c: 0, 
    e: "Child can call parent method and modify result.",
    de: `A child method can call the parent method and modify its result. If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method() + 1; Child().method(), then Child().method() returns 2 because super().method() calls the parent method (returns 1), and then the child adds 1 to it (1 + 1 = 2). This allows the child to extend or modify the parent's behavior rather than completely replace it - a common pattern for extending functionality.

Child modifies parent result:
• Child().method() returns 2
• Child's method calls super().method()
• Parent method returns 1
• Child adds 1: 1 + 1 = 2
• Returns: 2

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super().method() + 1
• super().method() calls Parent.method(), returns 1
• Child adds 1: 1 + 1 = 2
• Returns: 2

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent):
    def method(self):
        return super().method() + 1  # Extends parent
Child().method()              # 2 (parent's 1 + 1)

Common uses:
• Extending methods: def method(self): return super().method() + modification
• Behavior extension: child extends parent behavior
• Method overriding
• Inheritance

Example: If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method() + 1; Child().method(), then Child().method() returns 2 because the child can call the parent method and modify the result (1 + 1 = 2).
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def __init__(self): self.x = 1; class Child(Parent): def __init__(self): self.y = 2; Child().x?`, 
    o: ["AttributeError", "1", "Error", "None"], 
    c: 0, 
    e: "Overriding __init__ doesn't call parent __init__ automatically.",
    de: `Overriding __init__ doesn't automatically call the parent __init__. If class Parent: def __init__(self): self.x = 1; class Child(Parent): def __init__(self): self.y = 2; Child().x, then Child().x raises an AttributeError because when Child defines its own __init__, it completely replaces the parent's __init__ - the parent's __init__ is not called automatically. Only the child's __init__ runs, which sets self.y = 2 but doesn't set self.x = 1. To call the parent's __init__, you must explicitly call super().__init__().

Overriding __init__ doesn't auto-call parent:
• Child().x raises AttributeError
• Child's __init__ overrides parent's __init__
• Parent's __init__ not called automatically
• Only Child.__init__ runs (sets self.y = 2)
• self.x is not set
• Raises AttributeError

How it works:
• Child() creates instance and calls __init__
• Child has its own __init__ (overrides parent)
• Python calls Child.__init__ (only)
• Child.__init__ sets self.y = 2 (doesn't set self.x)
• Parent.__init__ is not called
• Child().x raises AttributeError

Example:
class Parent:
    def __init__(self):
        self.x = 1
class Child(Parent):
    def __init__(self):
        self.y = 2  # Overrides, doesn't call parent
Child().x                    # AttributeError (parent __init__ not called)

Common uses:
• Understanding initialization: overriding __init__ doesn't auto-call parent
• Explicit parent call: super().__init__() (must call manually)
• Method overriding
• Object initialization

Example: If class Parent: def __init__(self): self.x = 1; class Child(Parent): def __init__(self): self.y = 2; Child().x, then Child().x raises an AttributeError because overriding __init__ doesn't call the parent __init__ automatically - you must call super().__init__() explicitly.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def __init__(self): self.x = 1; class Child(Parent): def __init__(self): super().__init__(); self.y = 2; obj = Child(); obj.x?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "super().__init__() calls parent __init__.",
    de: `super().__init__() explicitly calls the parent's __init__ method. If class Parent: def __init__(self): self.x = 1; class Child(Parent): def __init__(self): super().__init__(); self.y = 2; obj = Child(); obj.x, then obj.x returns 1 because super().__init__() calls the parent's __init__, which sets self.x = 1. This is the correct way to ensure parent initialization happens when you override __init__ in a child class. The child can then set its own attributes after calling the parent's initialization.

super().__init__() calls parent:
• obj.x returns 1
• Child.__init__ calls super().__init__()
• Parent.__init__ sets self.x = 1
• Child.__init__ sets self.y = 2
• Returns: 1

How it works:
• Child() creates instance and calls __init__
• Child.__init__ executes: super().__init__()
• super().__init__() calls Parent.__init__()
• Parent.__init__ sets self.x = 1
• Child.__init__ sets self.y = 2
• obj.x returns 1

Example:
class Parent:
    def __init__(self):
        self.x = 1
class Child(Parent):
    def __init__(self):
        super().__init__()  # Calls parent __init__
        self.y = 2
obj = Child()
obj.x                        # 1 (parent __init__ called)
obj.y                        # 2 (child __init__ sets)

Common uses:
• Parent initialization: def __init__(self): super().__init__(); self.child_attr = value
• Constructor chaining: ensure parent initialization happens
• Method overriding
• Object initialization

Example: If class Parent: def __init__(self): self.x = 1; class Child(Parent): def __init__(self): super().__init__(); self.y = 2; obj = Child(); obj.x, then obj.x returns 1 because super().__init__() calls the parent's __init__, ensuring parent initialization happens.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 'parent'; class Child(Parent): pass; Child().method()?`, 
    o: ["'parent'", "Error", "None", "'child'"], 
    c: 0, 
    e: "Child without method uses parent method.",
    de: `A child class without its own method uses the parent's method. If class Parent: def method(self): return 'parent'; class Child(Parent): pass; Child().method(), then Child().method() returns 'parent' because Child doesn't define its own method(), so when you call method() on a Child instance, Python searches for method in Child (not found), then searches in Parent (found), and uses Parent.method(). Inheritance allows the child to use parent methods when they're not overridden.

Child uses parent method:
• Child().method() returns 'parent'
• Child doesn't define method()
• Python searches inheritance chain
• Finds method() in Parent
• Uses Parent.method()
• Returns: 'parent'

How it works:
• Child().method() calls method on Child instance
• Python searches for method in Child (not found)
• Python searches for method in Parent (found)
• Calls Parent.method() with Child instance as self
• Method executes: return 'parent'
• Returns: 'parent'

Example:
class Parent:
    def method(self):
        return 'parent'
class Child(Parent): pass  # No method defined
Child().method()           # 'parent' (uses parent method)

Common uses:
• Inherited methods: class Child(Parent): pass (uses parent methods)
• Method reuse: child can use parent methods without defining them
• Inheritance
• Code reuse

Example: If class Parent: def method(self): return 'parent'; class Child(Parent): pass; Child().method(), then Child().method() returns 'parent' because the child without a method uses the parent method through inheritance.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Parent().method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "Parent instance uses parent method (no override).",
    de: `A parent instance uses the parent's method, not the child's override. If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Parent().method(), then Parent().method() returns 1 because Parent().method() calls method on a Parent instance, which uses Parent.method() directly. The child's override doesn't affect parent instances - method overriding only affects instances of the child class. Each class has its own method implementation.

Parent uses parent method:
• Parent().method() returns 1
• Parent instance uses Parent.method()
• Child's override doesn't affect parent instances
• Parent.method() returns 1
• Returns: 1

How it works:
• Parent().method() calls method on Parent instance
• Python searches for method in Parent (found)
• Uses Parent.method() (doesn't check Child)
• Method executes: return 1
• Returns: 1

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent):
    def method(self):
        return super().method()  # Overrides parent
Parent().method()              # 1 (uses parent method, not child's)
Child().method()               # 1 (uses child method, calls parent)

Common uses:
• Independent methods: parent and child have separate method implementations
• Method overriding: affects child instances only
• Inheritance
• Method resolution

Example: If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Parent().method(), then Parent().method() returns 1 because a parent instance uses the parent method - the child's override doesn't affect parent instances.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: @classmethod; def method(cls): return 1; class Child(Parent): @classmethod; def method(cls): return 2; Child.method()?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Class methods can be overridden.",
    de: `Class methods can be overridden in child classes, just like instance methods. If class Parent: @classmethod; def method(cls): return 1; class Child(Parent): @classmethod; def method(cls): return 2; Child.method(), then Child.method() returns 2 because the child class defines its own class method with the same name, which overrides the parent's class method. When you call Child.method(), Python uses the child's version, not the parent's. Class methods follow the same overriding rules as instance methods.

Class methods can be overridden:
• Child.method() returns 2
• Child defines @classmethod method()
• Child's class method overrides parent's
• Child's version takes precedence
• Returns: 2

How it works:
• Child.method() calls class method on Child class
• Python finds method in Child (found)
• Uses Child.method() (doesn't check Parent)
• Method executes: return 2
• Returns: 2

Example:
class Parent:
    @classmethod
    def method(cls):
        return 1
class Child(Parent):
    @classmethod
    def method(cls):
        return 2  # Overrides parent class method
Child.method()              # 2 (uses child's class method)
Parent.method()             # 1 (uses parent's class method)

Common uses:
• Class method override: @classmethod def method(cls): return value (overrides parent)
• Customization: child provides different class method behavior
• Method overriding
• Class methods

Example: If class Parent: @classmethod; def method(cls): return 1; class Child(Parent): @classmethod; def method(cls): return 2; Child.method(), then Child.method() returns 2 because class methods can be overridden, and the child's class method takes precedence.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: @staticmethod; def method(): return 1; class Child(Parent): @staticmethod; def method(): return 2; Child.method()?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Static methods can be overridden.",
    de: `Static methods can be overridden in child classes, just like instance methods and class methods. If class Parent: @staticmethod; def method(): return 1; class Child(Parent): @staticmethod; def method(): return 2; Child.method(), then Child.method() returns 2 because the child class defines its own static method with the same name, which overrides the parent's static method. When you call Child.method(), Python uses the child's version. Static methods follow the same overriding rules as other methods - they can be overridden in child classes.

Static methods can be overridden:
• Child.method() returns 2
• Child defines @staticmethod method()
• Child's static method overrides parent's
• Child's version takes precedence
• Returns: 2

How it works:
• Child.method() calls static method on Child class
• Python finds method in Child (found)
• Uses Child.method() (doesn't check Parent)
• Method executes: return 2
• Returns: 2

Example:
class Parent:
    @staticmethod
    def method():
        return 1
class Child(Parent):
    @staticmethod
    def method():
        return 2  # Overrides parent static method
Child.method()              # 2 (uses child's static method)
Parent.method()             # 1 (uses parent's static method)

Common uses:
• Static method override: @staticmethod def method(): return value (overrides parent)
• Customization: child provides different static method behavior
• Method overriding
• Static methods

Example: If class Parent: @staticmethod; def method(): return 1; class Child(Parent): @staticmethod; def method(): return 2; Child.method(), then Child.method() returns 2 because static methods can be overridden, and the child's static method takes precedence.
`
  }),
  
  // 21-30: super() Function
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Child().method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "super() without arguments in method gets parent.",
    de: `The super() function without arguments automatically gets the parent class when called from within a method. If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Child().method(), then Child().method() returns 1 because super() without arguments in a method automatically determines the parent class from the current class and instance. When called from Child.method(), super() automatically refers to Parent, so super().method() calls Parent.method().

super() without arguments:
• Child().method() returns 1
• super() in method automatically gets parent
• super() refers to Parent (from Child)
• super().method() calls Parent.method()
• Returns: 1

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super().method()
• super() automatically gets Parent (from Child)
• super().method() calls Parent.method()
• Parent.method() returns 1
• Returns: 1

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent):
    def method(self):
        return super().method()  # super() gets Parent automatically
Child().method()              # 1 (calls Parent.method())

Common uses:
• Parent access: super().method() (automatically gets parent)
• Method extension: def method(self): return super().method() + extension
• super() function
• Inheritance

Example: If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super().method(); Child().method(), then Child().method() returns 1 because super() without arguments in a method automatically gets the parent class.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): def method(self): return super(Child, self).method(); Child().method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "super(Child, self) explicitly specifies class and instance.",
    de: `The super() function can be called with explicit arguments: super(Child, self) specifies the class (Child) and instance (self) explicitly. If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super(Child, self).method(); Child().method(), then Child().method() returns 1 because super(Child, self) explicitly tells Python to look for the parent of Child (which is Parent) and use self as the instance. This is the explicit form of super(), equivalent to super() without arguments in Python 3, but more explicit about which class to look for the parent of.

super() with explicit arguments:
• Child().method() returns 1
• super(Child, self) explicitly specifies class and instance
• Child is the class, self is the instance
• super() looks for parent of Child (Parent)
• super().method() calls Parent.method()
• Returns: 1

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super(Child, self).method()
• super(Child, self) gets parent of Child (Parent), uses self as instance
• super().method() calls Parent.method() with self as instance
• Parent.method() returns 1
• Returns: 1

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent):
    def method(self):
        return super(Child, self).method()  # Explicit super()
Child().method()              # 1 (calls Parent.method())

Common uses:
• Explicit super: super(Class, self).method() (Python 2 style, works in Python 3)
• Clarity: explicitly specify class and instance
• super() function
• Inheritance

Example: If class Parent: def method(self): return 1; class Child(Parent): def method(self): return super(Child, self).method(); Child().method(), then Child().method() returns 1 because super(Child, self) explicitly specifies the class and instance, telling Python to look for the parent of Child and use self as the instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: x = 1; class Child(Parent): def method(self): return super().x; Child().method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "super() can access parent class attributes.",
    de: `The super() function can access parent class attributes. If class Parent: x = 1; class Child(Parent): def method(self): return super().x; Child().method(), then Child().method() returns 1 because super() returns a proxy object that gives access to the parent class, and super().x accesses the parent's class attribute x = 1. This allows you to access parent class attributes even if the child has overridden them with its own attribute.

super() accesses parent attributes:
• Child().method() returns 1
• super() returns parent proxy
• super().x accesses parent class attribute
• Parent has x = 1
• Returns: 1

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super().x
• super() gets parent class (Parent)
• super().x accesses Parent.x
• Parent.x = 1
• Returns: 1

Example:
class Parent: x = 1
class Child(Parent):
    def method(self):
        return super().x  # Accesses parent class attribute
Child().method()          # 1 (accesses Parent.x)

Common uses:
• Parent attribute access: super().attr (accesses parent class attribute)
• Override bypass: super().x (accesses parent even if child overrides)
• super() function
• Inheritance

Example: If class Parent: x = 1; class Child(Parent): def method(self): return super().x; Child().method(), then Child().method() returns 1 because super() can access parent class attributes, and super().x accesses Parent.x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def __init__(self, x): self.x = x; class Child(Parent): def __init__(self, x, y): super().__init__(x); self.y = y; obj = Child(1, 2); obj.x?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "super().__init__() passes arguments to parent.",
    de: `super().__init__() can pass arguments to the parent's __init__ method. If class Parent: def __init__(self, x): self.x = x; class Child(Parent): def __init__(self, x, y): super().__init__(x); self.y = y; obj = Child(1, 2); obj.x, then obj.x returns 1 because Child.__init__ receives arguments (1, 2), calls super().__init__(x) which passes x = 1 to Parent.__init__, setting self.x = 1. Then Child.__init__ sets self.y = 2. This allows the child to initialize parent attributes with specific values.

super().__init__() with arguments:
• obj.x returns 1
• Child(1, 2) calls Child.__init__(1, 2)
• Child.__init__ calls super().__init__(1) (passes x)
• Parent.__init__ sets self.x = 1
• Child.__init__ sets self.y = 2
• Returns: 1

How it works:
• Child(1, 2) calls Child.__init__(1, 2)
• Child.__init__ executes: super().__init__(1)
• super().__init__(1) calls Parent.__init__(1)
• Parent.__init__ sets self.x = 1
• Child.__init__ sets self.y = 2
• obj.x returns 1

Example:
class Parent:
    def __init__(self, x):
        self.x = x
class Child(Parent):
    def __init__(self, x, y):
        super().__init__(x)  # Passes x to parent
        self.y = y
obj = Child(1, 2)
obj.x                        # 1 (parent __init__ sets with x=1)
obj.y                        # 2 (child __init__ sets)

Common uses:
• Parent initialization: def __init__(self, x, y): super().__init__(x); self.y = y
• Constructor chaining: pass arguments to parent __init__
• Method overriding
• Object initialization

Example: If class Parent: def __init__(self, x): self.x = x; class Child(Parent): def __init__(self, x, y): super().__init__(x); self.y = y; obj = Child(1, 2); obj.x, then obj.x returns 1 because super().__init__() passes arguments to the parent, so x = 1 is passed to Parent.__init__, setting obj.x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: @classmethod; def method(cls): return 1; class Child(Parent): @classmethod; def method(cls): return super().method(); Child.method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "super() works in class methods.",
    de: `The super() function works in class methods. If class Parent: @classmethod; def method(cls): return 1; class Child(Parent): @classmethod; def method(cls): return super().method(); Child.method(), then Child.method() returns 1 because super() can be used in class methods to access the parent's class method. When called from within a class method, super() automatically gets the parent class, and super().method() calls the parent's class method. The cls parameter is automatically handled by super() in class methods.

super() in class methods:
• Child.method() returns 1
• super() works in class methods
• super() automatically gets parent class
• super().method() calls Parent.method()
• Returns: 1

How it works:
• Child.method() calls class method on Child class
• Child.method() executes: return super().method()
• super() automatically gets Parent (from Child)
• super().method() calls Parent.method()
• Parent.method() returns 1
• Returns: 1

Example:
class Parent:
    @classmethod
    def method(cls):
        return 1
class Child(Parent):
    @classmethod
    def method(cls):
        return super().method()  # Works in class method
Child.method()              # 1 (calls Parent.method())

Common uses:
• Class method inheritance: @classmethod def method(cls): return super().method()
• Parent class methods: super() works in class methods
• super() function
• Class methods

Example: If class Parent: @classmethod; def method(cls): return 1; class Child(Parent): @classmethod; def method(cls): return super().method(); Child.method(), then Child.method() returns 1 because super() works in class methods, automatically getting the parent class and calling the parent's class method.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: @staticmethod; def method(): return 1; class Child(Parent): @staticmethod; def method(): return super().method(); Child.method()?`, 
    o: ["AttributeError", "1", "Error", "None"], 
    c: 0, 
    e: "super() doesn't work in static methods (no cls/self).",
    de: `The super() function doesn't work in static methods because static methods don't have self or cls parameters. If class Parent: @staticmethod; def method(): return 1; class Child(Parent): @staticmethod; def method(): return super().method(); Child.method(), then Child.method() raises an AttributeError because super() requires either self (for instance methods) or cls (for class methods) to determine the class context, but static methods have neither. Without self or cls, super() cannot determine which class to look for the parent of.

super() in static methods:
• Child.method() raises AttributeError
• super() doesn't work in static methods
• Static methods have no self or cls
• super() needs self/cls to determine context
• Raises AttributeError

How it works:
• Child.method() calls static method on Child class
• Child.method() executes: return super().method()
• super() needs self or cls to determine class context
• Static method has no self or cls
• super() cannot determine which class (no context)
• Raises AttributeError

Example:
class Parent:
    @staticmethod
    def method():
        return 1
class Child(Parent):
    @staticmethod
    def method():
        return super().method()  # AttributeError (no self/cls)
Child.method()              # AttributeError (super() doesn't work)

Common uses:
• Understanding limitations: super() doesn't work in static methods
• Static methods: no self/cls, so no super()
• super() function
• Static methods

Example: If class Parent: @staticmethod; def method(): return 1; class Child(Parent): @staticmethod; def method(): return super().method(); Child.method(), then Child.method() raises an AttributeError because super() doesn't work in static methods - static methods have no self or cls, so super() cannot determine the class context.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 'parent'; class Child(Parent): def method(self): return super().method() + ' child'; Child().method()?`, 
    o: ["'parent child'", "'parent'", "Error", "None"], 
    c: 0, 
    e: "super() can be used to extend parent method behavior.",
    de: `The super() function can be used to extend parent method behavior rather than completely replace it. If class Parent: def method(self): return 'parent'; class Child(Parent): def method(self): return super().method() + ' child'; Child().method(), then Child().method() returns 'parent child' because the child calls the parent's method via super().method() (which returns 'parent'), then extends it by concatenating ' child'. This pattern allows the child to enhance the parent's behavior while preserving it, creating behavior extension rather than replacement.

super() extends parent behavior:
• Child().method() returns 'parent child'
• Child calls super().method() (returns 'parent')
• Child extends result: 'parent' + ' child'
• Returns extended behavior
• Returns: 'parent child'

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super().method() + ' child'
• super().method() calls Parent.method(), returns 'parent'
• Child concatenates: 'parent' + ' child'
• Returns: 'parent child'

Example:
class Parent:
    def method(self):
        return 'parent'
class Child(Parent):
    def method(self):
        return super().method() + ' child'  # Extends parent
Child().method()              # 'parent child' (extends parent behavior)

Common uses:
• Behavior extension: def method(self): return super().method() + extension
• Preserving parent: call parent, then add child behavior
• super() function
• Method overriding

Example: If class Parent: def method(self): return 'parent'; class Child(Parent): def method(self): return super().method() + ' child'; Child().method(), then Child().method() returns 'parent child' because super() can be used to extend parent method behavior, calling the parent and then adding child-specific behavior.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Child(Parent): pass; super(Child, Child()).method()?`, 
    o: ["1", "Error", "None", "0"], 
    c: 0, 
    e: "super() can be called outside method with explicit args.",
    de: `The super() function can be called outside of a method by explicitly providing the class and instance arguments. If class Parent: def method(self): return 1; class Child(Parent): pass; super(Child, Child()).method(), then super(Child, Child()).method() returns 1 because super(Child, Child()) explicitly specifies Child as the class and Child() as the instance, allowing you to call super() from outside the class. This allows you to access parent methods even when not inside a method definition, useful for testing or advanced use cases.

super() outside method:
• super(Child, Child()).method() returns 1
• super(Child, Child()) explicitly specifies class and instance
• Child is the class, Child() is the instance
• super() gets parent of Child (Parent)
• super().method() calls Parent.method()
• Returns: 1

How it works:
• super(Child, Child()) creates super proxy
• Child is the class (to find parent of)
• Child() is the instance (to pass as self)
• super() gets parent of Child (Parent)
• super().method() calls Parent.method() with Child() instance
• Parent.method() returns 1
• Returns: 1

Example:
class Parent:
    def method(self):
        return 1
class Child(Parent): pass
super(Child, Child()).method()  # 1 (explicit super() outside method)

Common uses:
• External super: super(Class, instance).method() (outside method)
• Testing: call parent methods from outside class
• super() function
• Advanced usage

Example: If class Parent: def method(self): return 1; class Child(Parent): pass; super(Child, Child()).method(), then super(Child, Child()).method() returns 1 because super() can be called outside a method with explicit arguments, specifying the class and instance.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: x = 1; class Child(Parent): x = 2; def method(self): return super().x; Child().method()?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "super() accesses parent attribute even if child overrides.",
    de: `The super() function accesses parent attributes even if the child has overridden them. If class Parent: x = 1; class Child(Parent): x = 2; def method(self): return super().x; Child().method(), then Child().method() returns 1 because super() bypasses the child's override and accesses the parent's class attribute. When you use super().x, Python looks in the parent class (Parent) for x, finding Parent.x = 1, not Child.x = 2. This allows you to access parent attributes that have been shadowed by child attributes.

super() bypasses child override:
• Child().method() returns 1
• Child has x = 2 (overrides parent)
• super().x accesses parent attribute
• super() bypasses child's x = 2
• Accesses Parent.x = 1
• Returns: 1

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super().x
• super() gets parent class (Parent)
• super().x accesses Parent.x (not Child.x)
• Parent.x = 1
• Returns: 1 (parent's value, not child's)

Example:
class Parent: x = 1
class Child(Parent):
    x = 2  # Overrides parent
    def method(self):
        return super().x  # Accesses parent, not child
Child().method()          # 1 (parent's x, not child's x = 2)

Common uses:
• Parent access: super().attr (accesses parent even if child overrides)
• Override bypass: super() accesses parent attributes
• super() function
• Inheritance

Example: If class Parent: x = 1; class Child(Parent): x = 2; def method(self): return super().x; Child().method(), then Child().method() returns 1 because super() accesses the parent attribute even if the child overrides it, bypassing the child's x = 2 and accessing Parent.x = 1.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 1; class Middle(Parent): def method(self): return 2; class Child(Middle): def method(self): return super().method(); Child().method()?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "super() follows MRO, calls immediate parent (Middle).",
    de: `The super() function follows the Method Resolution Order (MRO) and calls the immediate parent in the inheritance chain, not the ultimate ancestor. If class Parent: def method(self): return 1; class Middle(Parent): def method(self): return 2; class Child(Middle): def method(self): return super().method(); Child().method(), then Child().method() returns 2 because super() in Child follows the MRO (Method Resolution Order), which is [Child, Middle, Parent, object]. super() in Child calls the next class in the MRO, which is Middle, not Parent. So super().method() calls Middle.method(), which returns 2.

super() follows MRO:
• Child().method() returns 2
• super() follows Method Resolution Order
• MRO: Child -> Middle -> Parent
• super() in Child calls next in MRO: Middle
• Middle.method() returns 2
• Returns: 2

How it works:
• Child().method() calls method on Child instance
• Child.method() executes: return super().method()
• super() follows MRO: [Child, Middle, Parent, object]
• super() in Child calls next in MRO: Middle.method()
• Middle.method() returns 2
• Returns: 2 (Middle's method, not Parent's)

Example:
class Parent:
    def method(self):
        return 1
class Middle(Parent):
    def method(self):
        return 2
class Child(Middle):
    def method(self):
        return super().method()  # Calls Middle, not Parent
Child().method()              # 2 (calls Middle.method(), not Parent.method())

Common uses:
• MRO understanding: super() follows Method Resolution Order
• Immediate parent: super() calls next in MRO, not ultimate ancestor
• super() function
• Method Resolution Order

Example: If class Parent: def method(self): return 1; class Middle(Parent): def method(self): return 2; class Child(Middle): def method(self): return super().method(); Child().method(), then Child().method() returns 2 because super() follows the MRO and calls the immediate parent (Middle), not the ultimate ancestor (Parent).
`
  }),
  
  // 31-40: Multiple Inheritance
  (_i: number) => ({ 
    q: `What is class A: x = 1; class B: x = 2; class C(A, B): pass; C.x?`, 
    o: ["1", "2", "Error", "None"], 
    c: 0, 
    e: "Multiple inheritance: first parent takes precedence.",
    de: `In multiple inheritance, the first parent in the inheritance tuple takes precedence. If class A: x = 1; class B: x = 2; class C(A, B): pass; C.x, then C.x returns 1 because when a class inherits from multiple parents, Python follows the Method Resolution Order (MRO), which prioritizes the leftmost parent. Since A comes before B in class C(A, B), A's attribute x = 1 is found first and used.

Multiple inheritance order:
• C.x returns 1
• class C(A, B): inherits from A and B
• A is first parent, B is second parent
• First parent (A) takes precedence
• A.x = 1 is found first
• Returns: 1

How it works:
• class C(A, B): creates child with multiple parents
• Python follows MRO: [C, A, B, object]
• C.x looks for attribute x
• Python searches: C.__dict__ (not found) → A.__dict__ (finds x = 1)
• Returns: 1 (A's attribute, not B's)

Example:
class A: x = 1
class B: x = 2
class C(A, B): pass
C.x                        # 1 (first parent A takes precedence)

Common uses:
• Multiple inheritance: class C(A, B): (inherits from multiple parents)
• Order matters: first parent in tuple takes precedence
• Multiple inheritance
• Method Resolution Order

Example: If class A: x = 1; class B: x = 2; class C(A, B): pass; C.x, then C.x returns 1 because in multiple inheritance, the first parent in the tuple takes precedence, so A's x = 1 is found first.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: x = 1; class B: x = 2; class C(B, A): pass; C.x?`, 
    o: ["2", "1", "Error", "None"], 
    c: 0, 
    e: "Order matters: first parent in tuple wins.",
    de: `The order of parents in multiple inheritance matters - the first parent in the tuple takes precedence. If class A: x = 1; class B: x = 2; class C(B, A): pass; C.x, then C.x returns 2 because when you change the order to class C(B, A), B comes before A, so B's attribute x = 2 is found first and used. The leftmost parent in the inheritance tuple always takes precedence over the rightmost parent.

Order matters in multiple inheritance:
• C.x returns 2
• class C(B, A): inherits from B and A
• B is first parent, A is second parent
• First parent (B) takes precedence
• B.x = 2 is found first
• Returns: 2

How it works:
• class C(B, A): creates child with B first, A second
• Python follows MRO: [C, B, A, object]
• C.x looks for attribute x
• Python searches: C.__dict__ (not found) → B.__dict__ (finds x = 2)
• Returns: 2 (B's attribute, not A's)

Example:
class A: x = 1
class B: x = 2
class C(B, A): pass  # B first
C.x                        # 2 (first parent B takes precedence)

Common uses:
• Multiple inheritance order: class C(Parent1, Parent2): (order matters)
• Precedence: first parent in tuple takes precedence
• Multiple inheritance
• Method Resolution Order

Example: If class A: x = 1; class B: x = 2; class C(B, A): pass; C.x, then C.x returns 2 because the order matters in multiple inheritance - the first parent in the tuple (B) takes precedence, so B.x = 2 is found first.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): pass; C().method()?`, 
    o: ["'A'", "'B'", "Error", "None"], 
    c: 0, 
    e: "Method resolution follows inheritance order.",
    de: `Method resolution in multiple inheritance follows the inheritance order (MRO). If class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): pass; C().method(), then C().method() returns 'A' because when Python searches for method(), it follows the Method Resolution Order (MRO), which is [C, A, B, object]. It searches in order: C (not found) → A (found, returns 'A'). The first parent (A) in the inheritance tuple is searched first.

Method resolution follows order:
• C().method() returns 'A'
• Python follows MRO: [C, A, B, object]
• Searches for method() in order
• Finds method() in A first
• Uses A.method() which returns 'A'
• Returns: 'A'

How it works:
• C().method() calls method on C instance
• Python follows MRO: [C, A, B, object]
• Searches for method: C (not found) → A (found)
• Uses A.method() with C instance as self
• Method executes: return 'A'
• Returns: 'A'

Example:
class A:
    def method(self):
        return 'A'
class B:
    def method(self):
        return 'B'
class C(A, B): pass  # A first
C().method()              # 'A' (MRO finds A.method() first)

Common uses:
• Method resolution: MRO determines which parent's method is used
• Multiple inheritance: order determines method resolution
• Method Resolution Order
• Multiple inheritance

Example: If class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): pass; C().method(), then C().method() returns 'A' because method resolution follows the inheritance order (MRO), and A comes before B, so A.method() is found first.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): def method(self): return super().method(); C().method()?`, 
    o: ["'A'", "'B'", "Error", "None"], c: 0, 
    e: "super() in multiple inheritance follows MRO.",
    de: `The super() function in multiple inheritance follows the Method Resolution Order (MRO). If class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): def method(self): return super().method(); C().method(), then C().method() returns 'A' because super() follows the MRO ([C, A, B, object]). When super() is called in C.method(), it calls the next class in the MRO after C, which is A. So super().method() calls A.method(), which returns 'A'.

super() follows MRO in multiple inheritance:
• C().method() returns 'A'
• super() follows MRO: [C, A, B, object]
• super() in C calls next in MRO: A
• super().method() calls A.method()
• A.method() returns 'A'
• Returns: 'A'

How it works:
• C().method() calls method on C instance
• C.method() executes: return super().method()
• super() follows MRO: [C, A, B, object]
• super() in C calls next in MRO: A.method()
• A.method() returns 'A'
• Returns: 'A'

Example:
class A:
    def method(self):
        return 'A'
class B:
    def method(self):
        return 'B'
class C(A, B):
    def method(self):
        return super().method()  # Follows MRO: calls A.method()
C().method()              # 'A' (super() calls next in MRO: A)

Common uses:
• MRO understanding: super() follows Method Resolution Order
• Multiple inheritance: super() calls next in MRO
• super() function
• Method Resolution Order

Example: If class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): def method(self): return super().method(); C().method(), then C().method() returns 'A' because super() in multiple inheritance follows the MRO, and the next class after C is A.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: pass; class B: pass; class C(A, B): pass; C.__bases__?`, 
    o: ["(<class '__main__.A'>, <class '__main__.B'>)", "()", "Error", "None"], 
    c: 0, 
    e: "__bases__ contains all parent classes.",
    de: `The __bases__ attribute contains all parent classes in multiple inheritance. If class A: pass; class B: pass; class C(A, B): pass; C.__bases__, then C.__bases__ returns (<class '__main__.A'>, <class '__main__.B'>) because __bases__ stores a tuple of all parent classes that a class inherits from. For multiple inheritance, it contains all parents in the order they appear in the inheritance tuple.

__bases__ with multiple parents:
• C.__bases__ returns (<class '__main__.A'>, <class '__main__.B'>)
• __bases__ contains tuple of all parent classes
• C inherits from A and B
• Returns tuple with both parents
• Returns: (<class '__main__.A'>, <class '__main__.B'>)

How it works:
• class C(A, B): creates child with multiple parents
• Python stores all parent classes in C.__bases__
• __bases__ is tuple of parent classes
• Contains: (A, B) in order
• Returns: (<class '__main__.A'>, <class '__main__.B'>)

Example:
class A: pass
class B: pass
class C(A, B): pass
C.__bases__               # (<class '__main__.A'>, <class '__main__.B'>) (all parents)

Common uses:
• Inheritance inspection: C.__bases__ (see all parent classes)
• Introspection: check what classes a class inherits from
• Multiple inheritance
• Type system

Example: If class A: pass; class B: pass; class C(A, B): pass; C.__bases__, then C.__bases__ returns (<class '__main__.A'>, <class '__main__.B'>) because __bases__ contains all parent classes in multiple inheritance.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: pass; class B(A): pass; class C(A): pass; class D(B, C): pass; D.mro()?`, 
    o: ["[D, B, C, A, object]", "[D, A, B, C, object]", "Error", "None"], 
    c: 0, 
    e: "MRO follows C3 linearization (depth-first, left-to-right).",
    de: `The Method Resolution Order (MRO) follows C3 linearization, which uses depth-first, left-to-right traversal. If class A: pass; class B(A): pass; class C(A): pass; class D(B, C): pass; D.mro(), then D.mro() returns [D, B, C, A, object] because C3 linearization processes the inheritance hierarchy: first D (the class itself), then B (leftmost parent), then C (rightmost parent), then A (common ancestor of B and C), then object (base of all classes). This ensures a consistent, predictable order.

C3 linearization MRO:
• D.mro() returns [D, B, C, A, object]
• MRO follows C3 linearization algorithm
• Depth-first, left-to-right traversal
• D -> B -> C -> A -> object
• Returns: [D, B, C, A, object]

How it works:
• C3 linearization computes MRO
• D inherits from B and C (left-to-right: B first, C second)
• B and C both inherit from A (common ancestor)
• MRO: D -> B -> C -> A -> object
• Ensures consistent, predictable order
• Returns: [D, B, C, A, object]

Example:
class A: pass
class B(A): pass
class C(A): pass
class D(B, C): pass
D.mro()                     # [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

Common uses:
• MRO inspection: Class.mro() (see method resolution order)
• Understanding inheritance: how Python searches for methods
• Method Resolution Order
• C3 linearization

Example: If class A: pass; class B(A): pass; class C(A): pass; class D(B, C): pass; D.mro(), then D.mro() returns [D, B, C, A, object] because MRO follows C3 linearization, which uses depth-first, left-to-right traversal to create a consistent order.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def method(self): return 'A'; class B(A): def method(self): return 'B'; class C(A): def method(self): return 'C'; class D(B, C): pass; D().method()?`, 
    o: ["'B'", "'A'", "'C'", "Error"], 
    c: 0, 
    e: "MRO: D -> B -> C -> A, B.method() found first.",
    de: `The Method Resolution Order determines which method is called. If class A: def method(self): return 'A'; class B(A): def method(self): return 'B'; class C(A): def method(self): return 'C'; class D(B, C): pass; D().method(), then D().method() returns 'B' because the MRO is [D, B, C, A, object]. Python searches for method() in order: D (not found) → B (found, returns 'B'). Since B comes before C in the MRO, B.method() is found first and used, even though C also has method().

MRO determines method:
• D().method() returns 'B'
• MRO: [D, B, C, A, object]
• Searches for method() in order
• Finds method() in B first
• Uses B.method() which returns 'B'
• Returns: 'B'

How it works:
• D().method() calls method on D instance
• Python follows MRO: [D, B, C, A, object]
• Searches for method: D (not found) → B (found)
• Uses B.method() with D instance as self
• Method executes: return 'B'
• Returns: 'B'

Example:
class A:
    def method(self):
        return 'A'
class B(A):
    def method(self):
        return 'B'
class C(A):
    def method(self):
        return 'C'
class D(B, C): pass  # B first in MRO
D().method()              # 'B' (MRO finds B.method() first)

Common uses:
• Method resolution: MRO determines which parent's method is used
• Multiple inheritance: order determines method resolution
• Method Resolution Order
• Multiple inheritance

Example: If class A: def method(self): return 'A'; class B(A): def method(self): return 'B'; class C(A): def method(self): return 'C'; class D(B, C): pass; D().method(), then D().method() returns 'B' because the MRO is [D, B, C, A, object], and B.method() is found first.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def method(self): return 'A'; class B(A): pass; class C(A): def method(self): return 'C'; class D(B, C): pass; D().method()?`, 
    o: ["'C'", "'A'", "'B'", "Error"], 
    c: 0, 
    e: "MRO: D -> B -> C -> A, C.method() found (B doesn't have it).",
    de: `The Method Resolution Order searches through all parents until it finds a method. If class A: def method(self): return 'A'; class B(A): pass; class C(A): def method(self): return 'C'; class D(B, C): pass; D().method(), then D().method() returns 'C' because the MRO is [D, B, C, A, object]. Python searches for method() in order: D (not found) → B (not found, B doesn't define method) → C (found, returns 'C'). Since B doesn't have method(), Python continues searching and finds it in C.

MRO continues searching:
• D().method() returns 'C'
• MRO: [D, B, C, A, object]
• Searches for method() in order
• D (not found) → B (not found) → C (found)
• Uses C.method() which returns 'C'
• Returns: 'C'

How it works:
• D().method() calls method on D instance
• Python follows MRO: [D, B, C, A, object]
• Searches for method: D (not found) → B (not found, no method) → C (found)
• Uses C.method() with D instance as self
• Method executes: return 'C'
• Returns: 'C'

Example:
class A:
    def method(self):
        return 'A'
class B(A): pass  # No method defined
class C(A):
    def method(self):
        return 'C'
class D(B, C): pass
D().method()              # 'C' (MRO finds C.method() after B doesn't have it)

Common uses:
• Method resolution: MRO searches all parents until method found
• Multiple inheritance: method resolution continues through all parents
• Method Resolution Order
• Multiple inheritance

Example: If class A: def method(self): return 'A'; class B(A): pass; class C(A): def method(self): return 'C'; class D(B, C): pass; D().method(), then D().method() returns 'C' because the MRO continues searching through all parents, and C.method() is found after B doesn't have it.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: x = 1; class B: x = 2; class C(A, B): x = 3; C.x?`, 
    o: ["3", "1", "2", "Error"], 
    c: 0, 
    e: "Child class attribute overrides all parent attributes.",
    de: `A child class attribute overrides all parent attributes in multiple inheritance. If class A: x = 1; class B: x = 2; class C(A, B): x = 3; C.x, then C.x returns 3 because when a child class defines an attribute with the same name as parent attributes, the child's attribute takes precedence over all parent attributes. The child attribute is in C.__dict__, so it's found first when searching C.x, before checking any parents.

Child overrides all parents:
• C.x returns 3
• C defines class attribute x = 3
• A has x = 1, B has x = 2
• Child's attribute shadows all parent attributes
• Returns: 3

How it works:
• class C(A, B): x = 3 defines child attribute
• C has its own class attribute x = 3
• C.x looks for attribute x
• Python finds x in C.__dict__ first
• Returns: 3 (child's attribute, not parents')

Example:
class A: x = 1
class B: x = 2
class C(A, B):
    x = 3  # Overrides all parent attributes
C.x                     # 3 (child's attribute, not A.x=1 or B.x=2)

Common uses:
• Attribute override: class Child(Parent1, Parent2): attr = value (overrides all parents)
• Customization: child can override parent attributes
• Multiple inheritance
• Attribute shadowing

Example: If class A: x = 1; class B: x = 2; class C(A, B): x = 3; C.x, then C.x returns 3 because the child class attribute overrides all parent attributes, so the child's value (3) takes precedence over all parents' values.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): def method(self): return super().method(); C().method()?`, 
    o: ["'A'", "'B'", "Error", "None"], 
    c: 0, 
    e: "super() in multiple inheritance calls next in MRO.",
    de: `The super() function in multiple inheritance calls the next class in the Method Resolution Order (MRO). If class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): def method(self): return super().method(); C().method(), then C().method() returns 'A' because super() follows the MRO ([C, A, B, object]). When super() is called in C.method(), it calls the next class in the MRO after C, which is A. So super().method() calls A.method(), which returns 'A', not B.method().

super() calls next in MRO:
• C().method() returns 'A'
• super() follows MRO: [C, A, B, object]
• super() in C calls next in MRO: A
• super().method() calls A.method()
• A.method() returns 'A'
• Returns: 'A'

How it works:
• C().method() calls method on C instance
• C.method() executes: return super().method()
• super() follows MRO: [C, A, B, object]
• super() in C calls next in MRO: A.method()
• A.method() returns 'A'
• Returns: 'A'

Example:
class A:
    def method(self):
        return 'A'
class B:
    def method(self):
        return 'B'
class C(A, B):
    def method(self):
        return super().method()  # Calls next in MRO: A
C().method()              # 'A' (super() calls A, not B)

Common uses:
• MRO understanding: super() calls next in Method Resolution Order
• Multiple inheritance: super() follows MRO, not just first parent
• super() function
• Method Resolution Order

Example: If class A: def method(self): return 'A'; class B: def method(self): return 'B'; class C(A, B): def method(self): return super().method(); C().method(), then C().method() returns 'A' because super() in multiple inheritance calls the next class in the MRO after C, which is A.
`
  }),
  
  // 41-50: Polymorphism
  (_i: number) => ({ 
    q: `What is polymorphism?`, 
    o: ["Same interface, different behavior", "Same behavior, different interface", "Error", "No interface"], 
    c: 0, 
    e: "Polymorphism allows same interface for different types.",
    de: `Polymorphism is a principle where different types can be used through the same interface, but each type provides its own implementation. The same method name can be called on different objects, and each object responds appropriately based on its type. This allows code to work with multiple types without knowing the specific type - "same interface, different behavior." In Python, polymorphism is achieved through method overriding (different classes define the same method with different implementations) and duck typing (if it quacks like a duck, treat it like a duck).

Polymorphism concept:
• Same interface, different behavior
• Same method name, different implementations
• Different types respond appropriately
• Code works with multiple types
• "If it walks like a duck and quacks like a duck, it's a duck"

How it works:
• Different classes define same method name
• Each class provides its own implementation
• Same method call works on different types
• Each type responds with its own behavior
• Enables code reuse and flexibility

Example:
class Animal:
    def speak(self):
        return 'sound'
class Dog(Animal):
    def speak(self):
        return 'bark'  # Different implementation
class Cat(Animal):
    def speak(self):
        return 'meow'  # Different implementation
# Same interface (speak()), different behavior (bark, meow)

Common uses:
• Polymorphism: same interface, different behavior
• Code reuse: function works with multiple types
• Method overriding: different classes, same method name
• Object-oriented programming

Example: Polymorphism is a principle where different types can be used through the same interface, but each type provides its own implementation - "same interface, different behavior."
`
  }),
  (_i: number) => ({ 
    q: `What is class Animal: def speak(self): return 'sound'; class Dog(Animal): def speak(self): return 'bark'; class Cat(Animal): def speak(self): return 'meow'; [Dog().speak(), Cat().speak()]?`, 
    o: ["['bark', 'meow']", "['sound', 'sound']", "Error", "None"], 
    c: 0, 
    e: "Different classes implement same method differently (polymorphism).",
    de: `Different classes can implement the same method with different behavior, demonstrating polymorphism. If class Animal: def speak(self): return 'sound'; class Dog(Animal): def speak(self): return 'bark'; class Cat(Animal): def speak(self): return 'meow'; [Dog().speak(), Cat().speak()], then [Dog().speak(), Cat().speak()] returns ['bark', 'meow'] because Dog and Cat both define speak() with different implementations. Each class provides its own behavior for the same method name - Dog.speak() returns 'bark', Cat.speak() returns 'meow'. This is polymorphism in action: same interface (speak()), different behavior (bark vs meow).

Different implementations, same interface:
• [Dog().speak(), Cat().speak()] returns ['bark', 'meow']
• Both classes have speak() method
• Dog.speak() returns 'bark'
• Cat.speak() returns 'meow'
• Same interface, different behavior
• Returns: ['bark', 'meow']

How it works:
• Dog().speak() calls speak() on Dog instance
• Python uses Dog.speak() (returns 'bark')
• Cat().speak() calls speak() on Cat instance
• Python uses Cat.speak() (returns 'meow')
• Both use same method name, different implementations
• Returns: ['bark', 'meow']

Example:
class Animal:
    def speak(self):
        return 'sound'
class Dog(Animal):
    def speak(self):
        return 'bark'  # Overrides parent
class Cat(Animal):
    def speak(self):
        return 'meow'  # Overrides parent
[Dog().speak(), Cat().speak()]  # ['bark', 'meow'] (polymorphism)

Common uses:
• Polymorphism: different classes, same method, different behavior
• Method overriding: each class provides its own implementation
• Code flexibility: same interface works with multiple types
• Object-oriented programming

Example: If class Animal: def speak(self): return 'sound'; class Dog(Animal): def speak(self): return 'bark'; class Cat(Animal): def speak(self): return 'meow'; [Dog().speak(), Cat().speak()], then [Dog().speak(), Cat().speak()] returns ['bark', 'meow'] because different classes implement the same method differently, demonstrating polymorphism.
`
  }),
  (_i: number) => ({ 
    q: `What is class Shape: def area(self): return 0; class Circle(Shape): def area(self): return 3.14; class Square(Shape): def area(self): return 1; [Circle().area(), Square().area()]?`, 
    o: ["[3.14, 1]", "[0, 0]", "Error", "None"], 
    c: 0, 
    e: "Polymorphism: same method name, different implementations.",
    de: `Polymorphism allows the same method name with different implementations in different classes. If class Shape: def area(self): return 0; class Circle(Shape): def area(self): return 3.14; class Square(Shape): def area(self): return 1; [Circle().area(), Square().area()], then [Circle().area(), Square().area()] returns [3.14, 1] because Circle and Square both define area() with their own implementations - Circle.area() returns 3.14, Square.area() returns 1. Each class provides its own behavior for calculating area, but they all use the same method name (area()). This is polymorphism: same interface (area()), different behavior (3.14 vs 1).

Same method name, different implementations:
• [Circle().area(), Square().area()] returns [3.14, 1]
• Both classes have area() method
• Circle.area() returns 3.14
• Square.area() returns 1
• Same method name, different implementations
• Returns: [3.14, 1]

How it works:
• Circle().area() calls area() on Circle instance
• Python uses Circle.area() (returns 3.14)
• Square().area() calls area() on Square instance
• Python uses Square.area() (returns 1)
• Both use same method name, different implementations
• Returns: [3.14, 1]

Example:
class Shape:
    def area(self):
        return 0  # Default
class Circle(Shape):
    def area(self):
        return 3.14  # Circle-specific
class Square(Shape):
    def area(self):
        return 1  # Square-specific
[Circle().area(), Square().area()]  # [3.14, 1] (polymorphism)

Common uses:
• Polymorphism: same method name, different implementations
• Method overriding: each class provides its own behavior
• Code flexibility: same interface, different behavior
• Object-oriented programming

Example: If class Shape: def area(self): return 0; class Circle(Shape): def area(self): return 3.14; class Square(Shape): def area(self): return 1; [Circle().area(), Square().area()], then [Circle().area(), Square().area()] returns [3.14, 1] because polymorphism allows the same method name with different implementations - Circle.area() returns 3.14, Square.area() returns 1.
`
  }),
  (_i: number) => ({ 
    q: `What is def process(obj): return obj.method(); class A: def method(self): return 1; class B: def method(self): return 2; [process(A()), process(B())]?`, 
    o: ["[1, 2]", "[1, 1]", "Error", "None"], 
    c: 0, 
    e: "Function works with different types (duck typing polymorphism).",
    de: `Functions can work with different types through duck typing polymorphism. If def process(obj): return obj.method(); class A: def method(self): return 1; class B: def method(self): return 2; [process(A()), process(B())], then [process(A()), process(B())] returns [1, 2] because the process() function doesn't care about the specific type - it only cares that the object has a method() method. This is duck typing: "if it walks like a duck and quacks like a duck, it's a duck." As long as both A and B have method(), process() can work with both, and each responds with its own implementation (A returns 1, B returns 2).

Duck typing polymorphism:
• [process(A()), process(B())] returns [1, 2]
• process() doesn't care about specific type
• Only cares that object has method()
• A.method() returns 1
• B.method() returns 2
• Same interface, different behavior
• Returns: [1, 2]

How it works:
• process(A()) calls process() with A instance
• process() executes: return obj.method()
• A.method() returns 1
• process(B()) calls process() with B instance
• process() executes: return obj.method()
• B.method() returns 2
• Returns: [1, 2]

Example:
def process(obj):
    return obj.method()  # Duck typing: just needs method()
class A:
    def method(self):
        return 1
class B:
    def method(self):
        return 2
[process(A()), process(B())]  # [1, 2] (works with different types)

Common uses:
• Duck typing: function works with any type that has required method
• Polymorphism: same interface, different types
• Code flexibility: function works with multiple types
• Object-oriented programming

Example: If def process(obj): return obj.method(); class A: def method(self): return 1; class B: def method(self): return 2; [process(A()), process(B())], then [process(A()), process(B())] returns [1, 2] because functions can work with different types through duck typing polymorphism - the function only cares that objects have the required method, not their specific type.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 'parent'; class Child(Parent): def method(self): return 'child'; obj = Parent(); obj = Child(); obj.method()?`, 
    o: ["'child'", "'parent'", "Error", "None"], 
    c: 0, 
    e: "Variable can hold different types, method call uses actual type.",
    de: `A variable can hold different types, and method calls use the actual type of the object. If class Parent: def method(self): return 'parent'; class Child(Parent): def method(self): return 'child'; obj = Parent(); obj = Child(); obj.method(), then obj.method() returns 'child' because when you reassign obj = Child(), the variable obj now points to a Child instance. When you call obj.method(), Python uses the actual type of the object (Child), not the variable's original type (Parent). So Child.method() is called, which returns 'child'. This demonstrates polymorphism - the same variable can hold different types, and method calls are resolved based on the actual object type.

Variable holds different types:
• obj.method() returns 'child'
• obj is reassigned to Child instance
• obj.method() uses actual type: Child
• Child.method() returns 'child'
• Returns: 'child'

How it works:
• obj = Parent() creates Parent instance
• obj = Child() reassigns obj to Child instance
• obj.method() calls method on current object
• Current object is Child instance
• Python uses Child.method() (returns 'child')
• Returns: 'child'

Example:
class Parent:
    def method(self):
        return 'parent'
class Child(Parent):
    def method(self):
        return 'child'
obj = Parent()              # obj points to Parent
obj = Child()               # obj now points to Child
obj.method()                # 'child' (uses actual type: Child)

Common uses:
• Polymorphism: variable can hold different types
• Dynamic typing: method call uses actual object type
• Runtime behavior: method resolution at runtime
• Object-oriented programming

Example: If class Parent: def method(self): return 'parent'; class Child(Parent): def method(self): return 'child'; obj = Parent(); obj = Child(); obj.method(), then obj.method() returns 'child' because a variable can hold different types, and method calls use the actual type of the object (Child), not the variable's original assignment.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def __add__(self, other): return 'A'; class B: def __add__(self, other): return 'B'; A() + B()?`, 
    o: ["'A'", "'B'", "Error", "None"], 
    c: 0, 
    e: "Operator overloading enables polymorphic operations.",
    de: `Operator overloading enables polymorphic operations - the same operator can behave differently for different types. If class A: def __add__(self, other): return 'A'; class B: def __add__(self, other): return 'B'; A() + B(), then A() + B() returns 'A' because when you use the + operator, Python calls A().__add__(B()). Since A defines __add__ to return 'A', it returns 'A'. The + operator behaves differently for A and B (A returns 'A', B would return 'B'), demonstrating polymorphism - the same operator interface, but different behavior based on the left operand's type.

Operator overloading polymorphism:
• A() + B() returns 'A'
• + operator calls A().__add__(B())
• A.__add__() returns 'A'
• Operator behavior depends on left operand
• Same operator, different behavior
• Returns: 'A'

How it works:
• A() + B() uses + operator
• Python calls A().__add__(B())
• A.__add__() executes: return 'A'
• Returns: 'A'

Example:
class A:
    def __add__(self, other):
        return 'A'  # A's behavior
class B:
    def __add__(self, other):
        return 'B'  # B's behavior
A() + B()                # 'A' (calls A.__add__)
B() + A()                # 'B' (calls B.__add__)

Common uses:
• Operator overloading: __add__, __sub__, etc. (polymorphic operators)
• Custom operators: define how operators work for your types
• Polymorphism
• Special methods

Example: If class A: def __add__(self, other): return 'A'; class B: def __add__(self, other): return 'B'; A() + B(), then A() + B() returns 'A' because operator overloading enables polymorphic operations - the same operator behaves differently for different types, and A.__add__() is called.
`
  }),
  (_i: number) => ({ 
    q: `What is class Animal: def speak(self): pass; class Dog(Animal): def speak(self): return 'bark'; def make_sound(animal): return animal.speak(); make_sound(Dog())?`, 
    o: ["'bark'", "None", "Error", "'sound'"], 
    c: 0, 
    e: "Polymorphism: function accepts any Animal, calls appropriate speak().",
    de: `Polymorphism allows a function to accept any object of a base type and call the appropriate method implementation. If class Animal: def speak(self): pass; class Dog(Animal): def speak(self): return 'bark'; def make_sound(animal): return animal.speak(); make_sound(Dog()), then make_sound(Dog()) returns 'bark' because make_sound() accepts any Animal (or subclass), and when you pass a Dog instance, it calls Dog.speak(), which returns 'bark'. The function doesn't need to know the specific type - it just calls speak(), and Python uses the actual type's implementation (Dog.speak(), not Animal.speak()). This is polymorphism in action.

Polymorphic function:
• make_sound(Dog()) returns 'bark'
• make_sound() accepts any Animal
• Calls animal.speak()
• Actual type is Dog
• Python uses Dog.speak() (returns 'bark')
• Returns: 'bark'

How it works:
• make_sound(Dog()) calls function with Dog instance
• make_sound() executes: return animal.speak()
• animal is Dog instance
• Python calls Dog.speak() (not Animal.speak())
• Dog.speak() returns 'bark'
• Returns: 'bark'

Example:
class Animal:
    def speak(self):
        pass
class Dog(Animal):
    def speak(self):
        return 'bark'  # Override
def make_sound(animal):
    return animal.speak()  # Works with any Animal
make_sound(Dog())          # 'bark' (calls Dog.speak())

Common uses:
• Polymorphic functions: function works with base type, calls actual type's method
• Method overriding: different subclasses, same method name
• Code flexibility: function works with multiple types
• Object-oriented programming

Example: If class Animal: def speak(self): pass; class Dog(Animal): def speak(self): return 'bark'; def make_sound(animal): return animal.speak(); make_sound(Dog()), then make_sound(Dog()) returns 'bark' because polymorphism allows a function to accept any Animal and call the appropriate speak() implementation - in this case, Dog.speak().
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def method(self): return 1; class B(A): def method(self): return 2; class C(B): def method(self): return 3; [A().method(), B().method(), C().method()]?`, 
    o: ["[1, 2, 3]", "[1, 1, 1]", "Error", "None"], 
    c: 0, 
    e: "Each class in hierarchy can override method (polymorphism).",
    de: `Each class in an inheritance hierarchy can override a method, providing its own implementation. If class A: def method(self): return 1; class B(A): def method(self): return 2; class C(B): def method(self): return 3; [A().method(), B().method(), C().method()], then [A().method(), B().method(), C().method()] returns [1, 2, 3] because each class defines its own method() with its own implementation - A.method() returns 1, B.method() returns 2, C.method() returns 3. This is polymorphism: same method name (method()), but each class in the hierarchy provides its own behavior. When you call method() on an instance, Python uses that instance's class's implementation.

Each class overrides method:
• [A().method(), B().method(), C().method()] returns [1, 2, 3]
• A.method() returns 1
• B.method() returns 2
• C.method() returns 3
• Each class provides its own implementation
• Returns: [1, 2, 3]

How it works:
• A().method() calls method on A instance
• Python uses A.method() (returns 1)
• B().method() calls method on B instance
• Python uses B.method() (returns 2)
• C().method() calls method on C instance
• Python uses C.method() (returns 3)
• Returns: [1, 2, 3]

Example:
class A:
    def method(self):
        return 1
class B(A):
    def method(self):
        return 2  # Overrides A
class C(B):
    def method(self):
        return 3  # Overrides B
[A().method(), B().method(), C().method()]  # [1, 2, 3] (polymorphism)

Common uses:
• Method overriding: each class in hierarchy can override method
• Polymorphism: same method name, different implementations
• Inheritance hierarchy
• Object-oriented programming

Example: If class A: def method(self): return 1; class B(A): def method(self): return 2; class C(B): def method(self): return 3; [A().method(), B().method(), C().method()], then [A().method(), B().method(), C().method()] returns [1, 2, 3] because each class in the hierarchy can override the method, providing its own implementation.
`
  }),
  (_i: number) => ({ 
    q: `What is class Parent: def method(self): return 'parent'; class Child(Parent): pass; [Parent().method(), Child().method()]?`, 
    o: ["['parent', 'parent']", "['parent', 'child']", "Error", "None"], 
    c: 0, 
    e: "Child without override uses parent method (still polymorphic).",
    de: `A child class without its own method override uses the parent's method, but this is still polymorphic behavior. If class Parent: def method(self): return 'parent'; class Child(Parent): pass; [Parent().method(), Child().method()], then [Parent().method(), Child().method()] returns ['parent', 'parent'] because Child doesn't define its own method(), so when you call Child().method(), Python searches for method() in Child (not found), then finds it in Parent and uses Parent.method(). Both Parent and Child use the same method implementation, demonstrating polymorphism - the same method call works on both types, even though Child doesn't override it. The behavior is the same, but the mechanism is polymorphic.

Child uses parent method:
• [Parent().method(), Child().method()] returns ['parent', 'parent']
• Parent.method() returns 'parent'
• Child doesn't define method()
• Child uses Parent.method() (returns 'parent')
• Still polymorphic: same method call works on both
• Returns: ['parent', 'parent']

How it works:
• Parent().method() calls method on Parent instance
• Python uses Parent.method() (returns 'parent')
• Child().method() calls method on Child instance
• Python searches: Child (not found) → Parent (found)
• Uses Parent.method() (returns 'parent')
• Returns: ['parent', 'parent']

Example:
class Parent:
    def method(self):
        return 'parent'
class Child(Parent): pass  # No override
[Parent().method(), Child().method()]  # ['parent', 'parent'] (still polymorphic)

Common uses:
• Inherited methods: child uses parent method if not overridden
• Polymorphism: same method call works on multiple types
• Method reuse: child inherits parent behavior
• Object-oriented programming

Example: If class Parent: def method(self): return 'parent'; class Child(Parent): pass; [Parent().method(), Child().method()], then [Parent().method(), Child().method()] returns ['parent', 'parent'] because a child without an override uses the parent method, but this is still polymorphic - the same method call works on both types.
`
  }),
  (_i: number) => ({ 
    q: `What is class A: def __str__(self): return 'A'; class B: def __str__(self): return 'B'; [str(A()), str(B())]?`, 
    o: ["['A', 'B']", "['A', 'A']", "Error", "None"], 
    c: 0, 
    e: "Special methods enable polymorphic behavior with built-ins.",
    de: `Special methods (magic methods) enable polymorphic behavior with built-in functions. If class A: def __str__(self): return 'A'; class B: def __str__(self): return 'B'; [str(A()), str(B())], then [str(A()), str(B())] returns ['A', 'B'] because str() calls the __str__() method, and each class defines its own __str__() with its own implementation - A.__str__() returns 'A', B.__str__() returns 'B'. This demonstrates polymorphism with built-in functions - the same built-in function (str()) works with different types, and each type responds with its own implementation through its special method. Special methods like __str__, __len__, __add__, etc. enable polymorphic behavior with Python's built-in functions and operators.

Special methods enable polymorphism:
• [str(A()), str(B())] returns ['A', 'B']
• str() calls __str__() method
• A.__str__() returns 'A'
• B.__str__() returns 'B'
• Same built-in function, different behavior
• Returns: ['A', 'B']

How it works:
• str(A()) calls str() on A instance
• str() calls A.__str__() (returns 'A')
• str(B()) calls str() on B instance
• str() calls B.__str__() (returns 'B')
• Both use same built-in function, different implementations
• Returns: ['A', 'B']

Example:
class A:
    def __str__(self):
        return 'A'
class B:
    def __str__(self):
        return 'B'
[str(A()), str(B())]  # ['A', 'B'] (polymorphism with built-ins)

Common uses:
• Special methods: __str__, __len__, __add__, etc. (polymorphic with built-ins)
• Operator overloading: define how operators work for your types
• Polymorphism
• Built-in functions

Example: If class A: def __str__(self): return 'A'; class B: def __str__(self): return 'B'; [str(A()), str(B())], then [str(A()), str(B())] returns ['A', 'B'] because special methods enable polymorphic behavior with built-in functions - each class defines its own __str__(), so str() calls the appropriate implementation.
`
  }),
  
  // 51-60: Encapsulation - Private Attributes
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.__x = 1; obj = MyClass(); obj.__x?`, o: ["AttributeError", "1", "Error", "None"], c: 0, e: "Double underscore prefix triggers name mangling (private)." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.__x = 1; obj = MyClass(); obj._MyClass__x?`, o: ["1", "Error", "None", "0"], c: 0, e: "Name mangling: __x becomes _MyClass__x (can still access)." }),
  (_i: number) => ({ q: `What is class MyClass: __x = 1; MyClass.__x?`, o: ["1", "Error", "None", "0"], c: 0, e: "Class attribute with __ prefix doesn't mangle (no self)." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; obj = MyClass(); obj._x?`, o: ["1", "Error", "None", "0"], c: 0, e: "Single underscore is convention (protected), not enforced." }),
  (_i: number) => ({ q: `What is class Parent: def __init__(self): self.__x = 1; class Child(Parent): def method(self): return self.__x; Child().method()?`, o: ["AttributeError", "1", "Error", "None"], c: 0, e: "Name mangling: Child can't access Parent.__x (becomes _Parent__x)." }),
  (_i: number) => ({ q: `What is class Parent: def __init__(self): self.__x = 1; class Child(Parent): def method(self): return self._Parent__x; Child().method()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Can access mangled name with _ClassName prefix." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.__x__ = 1; obj = MyClass(); obj.__x__?`, o: ["1", "Error", "None", "0"], c: 0, e: "Double underscore on both sides doesn't mangle (special methods)." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; def get_x(self): return self._x; obj = MyClass(); obj.get_x()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Getter method provides controlled access to protected attribute." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.__x = 1; def get_x(self): return self.__x; obj = MyClass(); obj.get_x()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Getter method can access mangled name from within class." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.__x = 1; def set_x(self, val): self.__x = val; obj = MyClass(); obj.set_x(2); obj.get_x() if hasattr(obj, 'get_x') else obj._MyClass__x?`, o: ["2", "1", "Error", "None"], c: 0, e: "Setter method can modify mangled attribute." }),
  
  // 61-70: Encapsulation - Properties and Access Control
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; obj = MyClass(); obj.x?`, o: ["1", "Error", "None", "0"], c: 0, e: "Property provides controlled read access." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; @x.setter; def x(self, val): self._x = val * 2; obj = MyClass(); obj.x = 5; obj.x?`, o: ["10", "5", "Error", "None"], c: 0, e: "Property setter can validate/transform before storing." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.__x = 1; @property; def x(self): return self.__x; obj = MyClass(); obj.x?`, o: ["1", "Error", "None", "0"], c: 0, e: "Property can access mangled attribute." }),
  (_i: number) => ({ q: `What is class MyClass: @property; def x(self): return 1; @x.setter; def x(self, val): pass; obj = MyClass(); obj.x = 5; obj.x?`, o: ["1", "5", "Error", "None"], c: 0, e: "Setter that doesn't store doesn't change property." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; def get_x(self): return self._x; def set_x(self, val): self._x = val; x = property(get_x, set_x); obj = MyClass(); obj.x = 5; obj.x?`, o: ["5", "1", "Error", "None"], c: 0, e: "property() can be created with getter and setter functions." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; @x.deleter; def x(self): del self._x; obj = MyClass(); del obj.x; hasattr(obj, '_x')?`, o: ["False", "True", "Error", "None"], c: 0, e: "Property deleter provides controlled deletion." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; obj = MyClass(); obj.x = 2?`, o: ["AttributeError", "2", "Error", "None"], c: 0, e: "Property without setter is read-only." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x if self._x > 0 else 0; obj = MyClass(); obj._x = -1; obj.x?`, o: ["0", "-1", "Error", "None"], c: 0, e: "Property getter can validate/transform on access." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; @property; def x(self): return self._x; @x.setter; def x(self, val): if val < 0: raise ValueError; self._x = val; obj = MyClass(); obj.x = -1?`, o: ["ValueError", "-1", "Error", "None"], c: 0, e: "Property setter can validate and raise errors." }),
  (_i: number) => ({ q: `What is class MyClass: _x = 1; @classmethod; @property; def x(cls): return cls._x?`, o: ["TypeError", "1", "Error", "None"], c: 0, e: "Can't combine @classmethod and @property (property is for instances)." }),
  
  // 71-80: Abstract Base Classes
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class MyClass(ABC): @abstractmethod; def method(self): pass; MyClass()?`, o: ["TypeError", "Creates instance", "Error", "None"], c: 0, e: "Abstract class with abstractmethod can't be instantiated." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class Parent(ABC): @abstractmethod; def method(self): pass; class Child(Parent): pass; Child()?`, o: ["TypeError", "Creates instance", "Error", "None"], c: 0, e: "Child must implement abstract method or be abstract." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class Parent(ABC): @abstractmethod; def method(self): pass; class Child(Parent): def method(self): return 1; Child().method()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Child implementing abstract method can be instantiated." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class Parent(ABC): @abstractmethod; def method(self): pass; class Child(Parent): @abstractmethod; def method(self): pass; Child()?`, o: ["TypeError", "Creates instance", "Error", "None"], c: 0, e: "Child keeping method abstract still can't be instantiated." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class MyClass(ABC): @abstractmethod; def method(self): pass; MyClass.__abstractmethods__?`, o: ["frozenset({'method'})", "set()", "Error", "None"], c: 0, e: "__abstractmethods__ contains set of abstract method names." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class Parent(ABC): @abstractmethod; def method(self): pass; class Child(Parent): def method(self): return 1; Child.__abstractmethods__?`, o: ["frozenset()", "frozenset({'method'})", "Error", "None"], c: 0, e: "Child implementing abstract method has no abstract methods." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class MyClass(ABC): @abstractmethod; @classmethod; def method(cls): pass; MyClass()?`, o: ["TypeError", "Creates instance", "Error", "None"], c: 0, e: "Abstract classmethod prevents instantiation." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class MyClass(ABC): @abstractmethod; @staticmethod; def method(): pass; MyClass()?`, o: ["TypeError", "Creates instance", "Error", "None"], c: 0, e: "Abstract staticmethod prevents instantiation." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class Parent(ABC): @abstractmethod; def method(self): pass; class Child(Parent): pass; issubclass(Child, Parent)?`, o: ["True", "False", "Error", "None"], c: 0, e: "Child is still subclass even if abstract." }),
  (_i: number) => ({ q: `What is from abc import ABC, abstractmethod; class MyClass(ABC): @abstractmethod; def method(self): pass; isinstance(MyClass(), MyClass)?`, o: ["TypeError (can't instantiate)", "True", "False", "Error"], c: 0, e: "Can't create instance to test isinstance." }),
  
  // 81-90: isinstance and issubclass
  (_i: number) => ({ q: `What is class Parent: pass; class Child(Parent): pass; isinstance(Child(), Parent)?`, o: ["True", "False", "Error", "None"], c: 0, e: "isinstance() returns True for parent class." }),
  (_i: number) => ({ q: `What is class Parent: pass; class Child(Parent): pass; isinstance(Child(), Child)?`, o: ["True", "False", "Error", "None"], c: 0, e: "isinstance() returns True for own class." }),
  (_i: number) => ({ q: `What is class Parent: pass; class Child(Parent): pass; isinstance(Child(), (Parent, str))?`, o: ["True", "False", "Error", "None"], c: 0, e: "isinstance() can check multiple types (tuple)." }),
  (_i: number) => ({ q: `What is class Parent: pass; class Child(Parent): pass; isinstance(Parent(), Child)?`, o: ["False", "True", "Error", "None"], c: 0, e: "isinstance() doesn't work backwards (parent not instance of child)." }),
  (_i: number) => ({ q: `What is class Parent: pass; class Child(Parent): pass; issubclass(Child, Parent)?`, o: ["True", "False", "Error", "None"], c: 0, e: "issubclass() checks if first is subclass of second." }),
  (_i: number) => ({ q: `What is class Parent: pass; class Child(Parent): pass; issubclass(Parent, Child)?`, o: ["False", "True", "Error", "None"], c: 0, e: "issubclass() doesn't work backwards." }),
  (_i: number) => ({ q: `What is class Parent: pass; class Child(Parent): pass; issubclass(Child, (Parent, str))?`, o: ["True", "False", "Error", "None"], c: 0, e: "issubclass() can check multiple base classes (tuple)." }),
  (_i: number) => ({ q: `What is class A: pass; class B(A): pass; class C(B): pass; issubclass(C, A)?`, o: ["True", "False", "Error", "None"], c: 0, e: "issubclass() checks entire inheritance chain." }),
  (_i: number) => ({ q: `What is class A: pass; class B(A): pass; class C(B): pass; isinstance(C(), A)?`, o: ["True", "False", "Error", "None"], c: 0, e: "isinstance() checks entire inheritance chain." }),
  (_i: number) => ({ q: `What is class A: pass; class B: pass; class C(A, B): pass; issubclass(C, A) and issubclass(C, B)?`, o: ["True", "False", "Error", "None"], c: 0, e: "Multiple inheritance: child is subclass of all parents." }),
  
  // 91-100: Advanced OOP Concepts
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.x = 1; class Child(MyClass): def __init__(self): super().__init__(); self.y = 2; obj = Child(); [obj.x, obj.y]?`, o: ["[1, 2]", "[1]", "[2]", "Error"], c: 0, e: "super().__init__() initializes parent attributes." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self, x): self.x = x; class Child(MyClass): def __init__(self, x, y): super().__init__(x); self.y = y; Child(1, 2).x?`, o: ["1", "2", "Error", "None"], c: 0, e: "super().__init__() passes arguments to parent." }),
  (_i: number) => ({ q: `What is class MyClass: x = 1; class Child(MyClass): x = 2; class GrandChild(Child): pass; GrandChild.x?`, o: ["2", "1", "Error", "None"], c: 0, e: "Grandchild inherits from immediate parent (Child.x)." }),
  (_i: number) => ({ q: `What is class MyClass: def method(self): return 1; class Child(MyClass): def method(self): return super().method() + 1; Child().method()?`, o: ["2", "1", "Error", "None"], c: 0, e: "Child can extend parent method using super()." }),
  (_i: number) => ({ q: `What is class MyClass: def __str__(self): return 'MyClass'; class Child(MyClass): def __str__(self): return 'Child'; str(Child())?`, o: ["'Child'", "'MyClass'", "Error", "None"], c: 0, e: "Child can override special methods." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self.__x = 1; class Child(MyClass): def method(self): return self.__x; Child().method()?`, o: ["AttributeError", "1", "Error", "None"], c: 0, e: "Name mangling prevents child from accessing parent's __x." }),
  (_i: number) => ({ q: `What is class MyClass: def __init__(self): self._x = 1; class Child(MyClass): def method(self): return self._x; Child().method()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Single underscore (protected) is accessible to child." }),
  (_i: number) => ({ q: `What is class MyClass: @classmethod; def method(cls): return cls; class Child(MyClass): pass; Child.method()?`, o: ["<class '__main__.Child'>", "<class '__main__.MyClass'>", "Error", "None"], c: 0, e: "Class method receives child class when called on child." }),
  (_i: number) => ({ q: `What is class MyClass: @staticmethod; def method(): return 1; class Child(MyClass): pass; Child.method()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Static method inherited unchanged." }),
  (_i: number) => ({ q: `What is class MyClass: @property; def x(self): return 1; class Child(MyClass): pass; Child().x?`, o: ["1", "Error", "None", "0"], c: 0, e: "Property is inherited by child class." }),
];

// --- LEVEL 10: GOD_WHALE (Design Patterns, Architecture, Best Practices) - 100 TRULY UNIQUE QUESTIONS ---
// Each question tests a DIFFERENT concept - NO number/variable variations of the same question
const level10Patterns = [
  // 1-10: Exception Handling - try/except
  (_i: number) => ({
    q: `What is try/except?`,
    o: ["Exception handling", "Loop control", "Error", "Function definition"],
    c: 0,
    e: "try/except handles exceptions.",
    de: `try/except is Python's exception handling mechanism that allows code to gracefully handle errors and unexpected conditions. The try block contains code that might raise an exception, and the except block catches and handles those exceptions. If an exception occurs in the try block, execution immediately jumps to the except block, skipping any remaining code in the try block. This prevents the program from crashing and allows for proper error handling.

try/except syntax:
• try: block_of_code_that_might_fail
• except ExceptionType: handle_the_error
• Execution jumps to except if exception occurs
• Program continues after handling the exception

How it works:
• Code in try block executes normally
• If exception occurs, execution jumps to except block
• Exception is caught and handled
• Program continues after try/except
• Multiple except blocks can handle different exception types

Example:
try:
    result = 10 / 0  # This raises ZeroDivisionError
    print("This won't execute")
except ZeroDivisionError:
    print("Division by zero!")  # This executes instead

Common uses:
• File operations: handle file not found, permission errors
• Network operations: handle connection failures, timeouts
• User input: handle invalid input, conversion errors
• Database operations: handle connection issues, query errors

Example: try/except is exception handling - it allows code to catch and respond to errors gracefully instead of crashing the program.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except: pass?`,
    o: ["Catches all exceptions", "Raises exception", "Error", "None"],
    c: 0,
    e: "Bare except catches all exceptions.",
    de: `A bare except clause (except: without specifying an exception type) catches all exceptions, including system exceptions like KeyboardInterrupt and SystemExit. While convenient for catching any error, bare except clauses are generally discouraged because they can hide important errors and make debugging difficult. The pass statement does nothing, so this code silently ignores any exception that occurs in the try block.

Bare except catches everything:
• except: (no type specified)
• Catches all exception types
• Including KeyboardInterrupt, SystemExit, etc.
• Generally discouraged practice
• Can hide important errors

How it works:
• Any exception in try block is caught
• No matter what type of exception
• Code in except block executes
• pass does nothing (silently ignores error)
• Program continues after try/except

Example:
try:
    result = 1 / 0  # ZeroDivisionError
except:  # Catches ALL exceptions
    pass  # Does nothing, silently ignores

Problems with bare except:
• Hides bugs and unexpected errors
• Makes debugging difficult
• Can catch system signals (Ctrl+C)
• Better to specify exception types

Example: try: 1/0; except: pass catches all exceptions including ZeroDivisionError, KeyboardInterrupt, and others, silently ignoring them with pass.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except ZeroDivisionError: pass?`,
    o: ["Catches ZeroDivisionError", "Raises exception", "Error", "None"],
    c: 0,
    e: "Specific exception type catches only that exception.",
    de: `Specifying an exception type in the except clause catches only that specific type of exception. When you write except ZeroDivisionError, only ZeroDivisionError exceptions are caught - other exceptions will not be caught and will propagate up. This is the recommended way to handle exceptions because it allows specific error handling and doesn't hide unrelated errors.

Specific exception catching:
• except ZeroDivisionError: catches only ZeroDivisionError
• Other exceptions not caught
• Allows targeted error handling
• Doesn't hide unrelated errors
• Recommended practice

How it works:
• Exception occurs in try block
• Python checks exception type
• If ZeroDivisionError, executes except block
• If other exception, not caught, propagates up
• Program can have multiple except blocks

Example:
try:
    result = 1 / 0  # ZeroDivisionError
except ZeroDivisionError:  # Catches only ZeroDivisionError
    print("Division by zero!")
except ValueError:  # Would catch ValueError if it occurred
    print("Value error!")

Benefits:
• Targeted error handling
• Different exceptions handled differently
• Unrelated errors still visible
• Easier debugging

Example: try: 1/0; except ZeroDivisionError: pass catches only ZeroDivisionError, letting other exceptions (like ValueError, TypeError) propagate uncaught.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except ZeroDivisionError as e: type(e)?`,
    o: ["<class 'ZeroDivisionError'>", "Error", "None", "<class 'Exception'>"],
    c: 0,
    e: "Exception object captured in variable.",
    de: `The 'as variable' syntax in except clauses captures the exception object, allowing access to exception details. When you write except ZeroDivisionError as e, the exception object is assigned to variable e, and you can access its attributes and methods. The type(e) returns the class of the exception object, which is ZeroDivisionError in this case.

Exception object capture:
• except ExceptionType as variable: captures exception
• Exception object assigned to variable
• Can access exception attributes
• type(e) returns exception class
• str(e) returns error message

How it works:
• Exception occurs in try block
• Exception object created
• Object assigned to variable 'e'
• Can inspect exception details
• type(e) shows exception type

Example:
try:
    result = 1 / 0
except ZeroDivisionError as e:
    print(type(e))  # <class 'ZeroDivisionError'>
    print(str(e))   # "division by zero"

Exception object attributes:
• __class__: exception type
• args: exception arguments
• __str__(): string representation
• Custom attributes for custom exceptions

Example: try: 1/0; except ZeroDivisionError as e: type(e) returns <class 'ZeroDivisionError'> because the exception object captured in variable e is an instance of ZeroDivisionError.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except (ZeroDivisionError, ValueError): pass?`,
    o: ["Catches multiple exception types", "Raises exception", "Error", "None"],
    c: 0,
    e: "Tuple catches multiple exception types.",
    de: `You can catch multiple exception types in a single except clause by using a tuple of exception types. except (ZeroDivisionError, ValueError) will catch either ZeroDivisionError or ValueError exceptions. This is useful when multiple different exceptions require the same handling logic, avoiding code duplication.

Multiple exception types in tuple:
• except (Type1, Type2, Type3): catches any of these
• Single except block handles multiple exceptions
• Avoids code duplication
• Parentheses required for tuple

How it works:
• Exception occurs in try block
• Python checks if exception type matches any in tuple
• If match, executes except block
• If no match, exception propagates
• All listed types handled the same way

Example:
try:
    # Code that might raise different errors
    result = int(input("Enter number: "))  # ValueError if not number
    result = 10 / result  # ZeroDivisionError if 0
except (ZeroDivisionError, ValueError):  # Catches both
    print("Invalid input or division by zero!")

Benefits:
• Single handler for related exceptions
• Cleaner code than multiple except blocks
• Groups exceptions with same handling
• Reduces duplication

Example: try: 1/0; except (ZeroDivisionError, ValueError): pass catches both ZeroDivisionError and ValueError with a single except clause.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except ZeroDivisionError: pass; except ValueError: pass?`,
    o: ["Multiple except clauses", "SyntaxError", "Error", "None"],
    c: 0,
    e: "Multiple except clauses handle different exceptions.",
    de: `You can have multiple except clauses after a single try block to handle different exception types with different logic. Each except clause is checked in order, and only the first matching one executes. This allows for specific, targeted error handling where different exceptions require different responses.

Multiple except clauses:
• try: code_that_might_fail
• except Type1: handle_type1_error
• except Type2: handle_type2_error
• except Type3: handle_type3_error
• Each except handles different exception

How it works:
• Exception occurs in try block
• Python checks except clauses in order
• First matching exception type executes
• Other except clauses skipped
• Unmatched exceptions propagate up

Example:
try:
    result = 10 / int(input("Enter divisor: "))
except ZeroDivisionError:
    print("Cannot divide by zero!")
except ValueError:
    print("Please enter a valid number!")
except Exception as e:
    print(f"Unexpected error: {e}")

Benefits:
• Specific handling for each exception type
• Different error messages for different errors
• More precise error handling
• Better user experience

Example: Multiple except clauses allow different exception types to be handled with different logic - ZeroDivisionError gets one response, ValueError gets another.`
  }),
  (_i: number) => ({
    q: `What is try: pass; except: pass; else: x = 1; x?`,
    o: ["1", "Error", "None", "0"],
    c: 0,
    e: "else clause runs if no exception occurred.",
    de: `The else clause in try/except blocks executes only if no exception occurred in the try block. It's useful for code that should run only when the try block completes successfully, separating successful execution from error handling. The else clause runs after the try block but before any finally clause.

else clause execution:
• else: runs only if no exception in try block
• Executes after try completes successfully
• Skipped if exception occurs
• Runs before finally (if present)
• Useful for success-only code

How it works:
• Try block executes
• If no exception, else block executes
• If exception, else block skipped, except block runs
• Finally block (if present) always runs last

Example:
try:
    result = 10 / 2  # No exception
    print("Division successful")
except ZeroDivisionError:
    print("Division failed")
else:
    print("No errors occurred")  # This executes
    x = result * 2

Benefits:
• Separates success logic from error handling
• Code runs only on successful execution
• Cleaner organization
• Avoids nesting success code in try

Example: In try: pass; except: pass; else: x = 1; x, the else clause executes because no exception occurred in the try block, so x is set to 1.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except: pass; else: x = 1; x?`,
    o: ["NameError", "1", "Error", "None"],
    c: 0,
    e: "else clause doesn't run if exception occurred.",
    de: `The else clause only executes when no exception occurs in the try block. If an exception happens, the else clause is completely skipped, and execution jumps directly to the except block. This ensures that else code only runs on successful execution.

else clause behavior with exceptions:
• else: skipped if exception occurs
• Exception triggers except block
• else never executes when exception happens
• Separates success path from error path

How it works:
• Exception occurs in try block
• Execution jumps to except block
• else block completely skipped
• finally block (if present) still runs

Example:
try:
    result = 1 / 0  # Exception occurs
    print("This won't print")
except ZeroDivisionError:
    print("Exception caught")
    x = "error"
else:
    x = 1  # This is skipped
    print("No exception")

Result:
• except block executes: x = "error"
• else block skipped: x is not set to 1
• x refers to the variable from except block

Example: In try: 1/0; except: pass; else: x = 1; x, a NameError occurs because the else clause doesn't execute when an exception occurs, so x is never defined.`
  }),
  (_i: number) => ({
    q: `What is try: pass; except: pass; finally: x = 1; x?`,
    o: ["1", "Error", "None", "0"],
    c: 0,
    e: "finally clause always runs.",
    de: `The finally clause always executes, regardless of whether an exception occurred or not. It's used for cleanup code that must run no matter what happens in the try block. finally blocks are commonly used for closing files, releasing resources, or cleaning up connections.

finally clause always executes:
• finally: code_that_always_runs
• Executes after try/except/else complete
• Runs even if exception occurs
• Runs even if return/break/continue in try
• Guaranteed execution (almost always)

How it works:
• try block executes
• If exception: except block runs
• If no exception: else block runs (if present)
• finally block always runs last
• Even if exception not caught

Example:
try:
    print("Try block")
    # No exception
except:
    print("Except block")
else:
    print("Else block")
finally:
    print("Finally block")  # Always executes
    x = 1

Common uses:
• File cleanup: file.close()
• Resource release: connection.close()
• Lock release: lock.release()
• Temporary file removal
• Database transaction cleanup

Example: finally clause executes regardless of exceptions, so in try: pass; except: pass; finally: x = 1; x returns 1 because finally always runs.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except: pass; finally: x = 1; x?`,
    o: ["1", "Error", "None", "0"],
    c: 0,
    e: "finally clause runs even if exception occurred.",
    de: `The finally clause executes unconditionally, even when an exception occurs in the try block. This makes it perfect for cleanup operations that must happen regardless of success or failure. The finally block runs after all try/except/else processing is complete.

finally with exceptions:
• finally: always executes
• Even when exception occurs and is caught
• Even when exception occurs and is not caught
• Executes before exception propagates up
• Perfect for cleanup code

Execution order with exception:
1. Exception occurs in try
2. except block executes (if matches)
3. else block skipped
4. finally block executes
5. Exception may continue propagating

Example:
try:
    result = 1 / 0  # Exception occurs
except ZeroDivisionError:
    print("Exception caught")
finally:
    print("Cleanup code")  # Always executes
    x = 1

Benefits:
• Guaranteed cleanup
• Resources always released
• No matter what happens in try/except
• Prevents resource leaks
• Consistent cleanup behavior

Example: finally executes even with exceptions, so try: 1/0; except: pass; finally: x = 1; x returns 1 because finally always runs, setting x = 1.`
  }),
  
  // 11-20: Exception Handling - Raising and Custom Exceptions
  (_i: number) => ({
    q: `What is raise ValueError('error')?`,
    o: ["Raises ValueError exception", "Returns error", "Error", "None"],
    c: 0,
    e: "raise statement raises exception.",
    de: `The raise statement explicitly raises an exception in Python. raise ValueError('error') creates a ValueError exception with the message 'error' and raises it, causing the program to stop normal execution and jump to the nearest exception handler. This is how you intentionally trigger error conditions.

raise statement syntax:
• raise ExceptionType(message)
• Creates exception object with message
• Immediately stops execution
• Jumps to nearest except block
• Can raise built-in or custom exceptions

How it works:
• Exception object created: ValueError('error')
• Execution stops immediately
• Python looks for except block to handle it
• If no handler, program crashes with traceback
• Stack unwinds until handler found

Example:
def validate_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative")
    return age

validate_age(-5)  # Raises ValueError with message

Common uses:
• Input validation: raise ValueError for invalid input
• Preconditions: raise AssertionError for invalid state
• Custom errors: raise custom exception classes
• Re-raising: raise to re-raise caught exception

Example: raise ValueError('error') creates and raises a ValueError exception with message 'error', stopping execution and jumping to exception handler.`
  }),
  (_i: number) => ({
    q: `What is raise ValueError?`,
    o: ["Raises ValueError without message", "SyntaxError", "Error", "None"],
    c: 0,
    e: "raise can be used without message.",
    de: `You can raise an exception without providing a message by just using the exception class name. raise ValueError creates a ValueError exception with no custom message. The exception will still have a default representation, but no descriptive error message. This is less common than raising with a message.

raise without message:
• raise ExceptionClass (no parentheses for no-arg)
• Creates exception with default state
• No custom error message
• Still raises the exception normally
• Less informative than with message

How it works:
• Exception class instantiated without arguments
• Default exception object created
• str(e) will show class name only
• Still triggers exception handling
• Can be caught same as any ValueError

Example:
raise ValueError      # Creates ValueError()
raise ValueError()    # Same thing, explicit instantiation
raise ValueError('msg')  # With message

Exception without message:
• str(e) returns '' (empty string for ValueError)
• repr(e) shows "ValueError()""
• Less useful for debugging
• Still functionally raises exception

Example: raise ValueError creates a ValueError exception without a custom message, which is still a valid exception that can be caught and handled.`
  }),
  (_i: number) => ({
    q: `What is try: raise ValueError; except ValueError as e: raise?`,
    o: ["Re-raises the exception", "Returns None", "Error", "None"],
    c: 0,
    e: "raise without argument re-raises current exception.",
    de: `raise without any arguments inside an except block re-raises the currently caught exception. This is useful when you want to catch an exception for logging or partial handling, but still want the exception to propagate up to higher-level handlers. The original exception object and traceback are preserved.

Re-raising exceptions:
• raise (no arguments in except block)
• Re-raises the currently caught exception
• Preserves original traceback
• Useful for logging + re-raising
• Allows partial exception handling

How it works:
• Exception caught in except block
• raise with no arguments
• Same exception object re-raised
• Original stack trace preserved
• Higher-level handlers can catch it

Example:
try:
    risky_operation()
except ValueError as e:
    log_error(e)  # Log the error
    raise         # Re-raise the same exception

Benefits:
• Add logging without stopping propagation
• Cleanup before re-raising
• Partial error handling
• Preserve original stack trace

Example: In except block, raise (with no arguments) re-raises the currently caught ValueError, preserving the original exception and traceback.`
  }),
  (_i: number) => ({
    q: `What is class MyError(Exception): pass; raise MyError()?`,
    o: ["Raises custom exception", "SyntaxError", "Error", "None"],
    c: 0,
    e: "Custom exceptions inherit from Exception.",
    de: `You can create custom exception classes by inheriting from the built-in Exception class or its subclasses. class MyError(Exception): pass creates a custom exception type that can be raised and caught like built-in exceptions. Custom exceptions allow for more specific error handling and better error categorization.

Custom exception creation:
• class MyException(Exception): pass
• Inherits from Exception base class
• Can add custom attributes/methods
• Behaves like built-in exceptions
• Can be caught specifically

How it works:
• Define class inheriting from Exception
• Class becomes exception type
• Can instantiate: MyError()
• Can raise: raise MyError()
• Can catch: except MyError

Example:
class ValidationError(Exception):
    def __init__(self, field, value):
        self.field = field
        self.value = value
        super().__init__(f"Invalid {field}: {value}")

raise ValidationError("email", "invalid@email")

Benefits:
• Specific error types for different situations
• Better error categorization
• Custom error messages and data
• More precise exception handling
• Cleaner error handling logic

Example: class MyError(Exception): pass; raise MyError() creates and raises a custom exception instance, which can be caught with except MyError.`
  }),
  (_i: number) => ({
    q: `What is class MyError(Exception): pass; isinstance(MyError(), Exception)?`,
    o: ["True", "False", "Error", "None"],
    c: 0,
    e: "Custom exception is instance of Exception.",
    de: `Custom exceptions that inherit from Exception are instances of the Exception class. isinstance(MyError(), Exception) returns True because MyError inherits from Exception, so instances of MyError are also instances of Exception. This inheritance relationship allows custom exceptions to be caught by except Exception blocks.

Inheritance and isinstance:
• Custom exceptions inherit from Exception
• isinstance(custom_instance, Exception) = True
• isinstance(custom_instance, CustomException) = True
• Can be caught by broader exception handlers
• Maintains Liskov Substitution Principle

How it works:
• class MyError(Exception): inheritance
• MyError() creates instance
• isinstance checks inheritance chain
• Exception is base class for all exceptions
• Custom exceptions are subclasses

Example:
class MyError(Exception): pass
error = MyError()
isinstance(error, MyError)     # True - exact type
isinstance(error, Exception)   # True - base class
isinstance(error, ValueError)  # False - not related

Exception hierarchy:
• BaseException (root)
• Exception (most exceptions inherit from this)
• Custom exceptions inherit from Exception
• Specific built-ins like ValueError, TypeError

Example: isinstance(MyError(), Exception) returns True because custom exceptions inherit from Exception, making them instances of the base Exception class.`
  }),
  (_i: number) => ({
    q: `What is try: raise ValueError('msg'); except ValueError as e: str(e)?`,
    o: ["'msg'", "'ValueError'", "Error", "None"],
    c: 0,
    e: "str(exception) returns exception message.",
    de: `str() on an exception object returns the exception's message (if provided) or a default string representation. For ValueError('msg'), str(e) returns 'msg' - the message passed to the exception constructor. This is useful for displaying user-friendly error messages.

Exception string representation:
• str(exception) returns the error message
• For ValueError('msg'), str(e) = 'msg'
• For exceptions without message, str(e) may be empty
• repr(exception) returns full representation
• str() is for user-friendly display

How it works:
• Exception created with message: ValueError('msg')
• str(e) extracts the message string
• Returns 'msg' for display
• Different from repr(e) which shows "ValueError('msg')"

Example:
try:
    raise ValueError("Invalid input")
except ValueError as e:
    user_message = str(e)  # "Invalid input"
    print(f"Error: {user_message}")

Exception messages:
• ValueError("message") → str(e) = "message"
• TypeError("message") → str(e) = "message"
• Custom exceptions can override __str__

Example: str(ValueError('msg')) returns 'msg' because str() on an exception returns the message passed to the exception constructor.`
  }),
  (_i: number) => ({
    q: `What is try: raise ValueError('msg'); except ValueError as e: repr(e)?`,
    o: ["\"ValueError('msg')\"", "'msg'", "Error", "None"],
    c: 0,
    e: "repr(exception) returns exception representation.",
    de: `repr() on an exception object returns a string that represents the exception object, including its type and message. For ValueError('msg'), repr(e) returns "ValueError('msg')" - a string that could be used to recreate the exception object. This is more detailed than str() and is useful for debugging.

Exception repr vs str:
• repr(e) returns full representation: "ValueError('msg')"
• str(e) returns just message: 'msg'
• repr() for debugging/detailed info
• str() for user-friendly messages
• repr() shows type and constructor args

How it works:
• Exception object: ValueError('msg')
• repr(e) shows how to recreate it
• Includes class name and arguments
• More detailed than str()
• Useful for logging and debugging

Example:
try:
    raise ValueError("Something went wrong")
except ValueError as e:
    debug_info = repr(e)  # "ValueError('Something went wrong')"
    user_info = str(e)    # "Something went wrong"
    print(f"Debug: {debug_info}")
    print(f"User: {user_info}")

Exception representations:
• ValueError('msg') → repr = "ValueError('msg')"
• TypeError('msg') → repr = "TypeError('msg')"
• Custom exceptions show their class name

Example: repr(ValueError('msg')) returns "ValueError('msg')" because repr() shows the full representation of the exception object, including its type and arguments.`
  }),
  (_i: number) => ({
    q: `What is try: 1/0; except Exception as e: type(e).__name__?`,
    o: ["'ZeroDivisionError'", "'Exception'", "Error", "None"],
    c: 0,
    e: "Exception object has __name__ attribute.",
    de: `Exception classes have a __name__ attribute that contains the class name as a string. For ZeroDivisionError, type(e).__name__ returns 'ZeroDivisionError' because that's the name of the exception class. This is useful for programmatic checking of exception types.

Exception class attributes:
• __name__ contains class name string
• type(e).__name__ gets the exception type name
• Useful for conditional error handling
• More reliable than string parsing
• Works with custom exceptions too

How it works:
• Exception caught: ZeroDivisionError
• type(e) returns ZeroDivisionError class
• __name__ attribute accessed
• Returns string: 'ZeroDivisionError'
• Can be used in conditionals

Example:
try:
    risky_operation()
except Exception as e:
    error_type = type(e).__name__
    if error_type == 'ValueError':
        handle_value_error()
    elif error_type == 'ZeroDivisionError':
        handle_division_error()
    else:
        handle_other_error()

Benefits:
• Programmatic exception type checking
• No string parsing needed
• Works with any exception type
• Reliable and clean

Example: type(ZeroDivisionError()).__name__ returns 'ZeroDivisionError' because the exception object's class has __name__ = 'ZeroDivisionError'.`
  }),
  (_i: number) => ({
    q: `What is try: raise ValueError; except Exception: pass?`,
    o: ["Catches ValueError (subclass)", "Raises exception", "Error", "None"],
    c: 0,
    e: "Catching base class catches subclasses.",
    de: `Catching a base exception class like Exception catches all subclasses of that exception. Since ValueError inherits from Exception, except Exception will catch ValueError exceptions. This is the inheritance-based exception handling system in Python.

Exception inheritance hierarchy:
• Exception is base class for most exceptions
• ValueError, TypeError, etc. inherit from Exception
• except Exception catches all Exception subclasses
• Allows broad exception handling
• Can be too broad (catches everything)

How it works:
• Exception hierarchy: BaseException → Exception → ValueError
• ValueError is subclass of Exception
• except Exception catches ValueError
• except BaseException catches everything
• Inheritance determines catchability

Example:
try:
    raise ValueError("Invalid value")
except Exception:  # Catches ValueError because ValueError(Exception)
    print("Some exception occurred")

Exception hierarchy:
• BaseException (catches everything)
• Exception (catches most application errors)
• ArithmeticError, LookupError, etc. (specific categories)
• ValueError, KeyError, etc. (specific exceptions)

Example: except Exception catches ValueError because ValueError inherits from Exception, allowing broad exception handling.`
  }),
  (_i: number) => ({
    q: `What is try: raise ValueError; except (ValueError, TypeError): pass?`,
    o: ["Catches ValueError", "Raises exception", "Error", "None"],
    c: 0,
    e: "Tuple of exceptions catches any matching type.",
    de: `A tuple of exception types in an except clause catches any exception that matches any of the types in the tuple. except (ValueError, TypeError) will catch either ValueError or TypeError exceptions. This allows handling multiple related exception types with the same code.

Multiple exception types in tuple:
• except (Type1, Type2, Type3): catches any of these
• Tuple syntax for multiple types
• Single handler for multiple exceptions
• Cleaner than separate except blocks
• Related exceptions handled together

How it works:
• Exception occurs in try block
• Python checks each type in tuple
• If exception matches any type, handler executes
• Order doesn't matter (unlike multiple except blocks)
• First matching tuple element wins

Example:
try:
    # Code that might raise ValueError or TypeError
    value = int(input("Enter number: "))  # ValueError if not number
    result = 10 / value  # ZeroDivisionError if 0
except (ValueError, TypeError):  # Catches both
    print("Invalid input type")
except ZeroDivisionError:  # Separate handler for different error
    print("Cannot divide by zero")

Benefits:
• Groups related exceptions
• Single handler for similar errors
• Cleaner than multiple except blocks
• More readable code

Example: except (ValueError, TypeError) catches either ValueError or TypeError with a single except clause, grouping related type errors.`
  }),
  
  // 21-30: Context Managers and with Statement
  (_i: number) => ({
    q: `What is with open('file') as f?`,
    o: ["Context manager", "File opening", "Error", "Loop statement"],
    c: 0,
    e: "with statement uses context manager.",
    de: `The with statement provides a clean syntax for working with context managers. with open('file') as f creates a context manager that automatically handles resource management. The open() function returns a file object that is a context manager - it automatically closes the file when the with block exits, even if an exception occurs.

with statement and context managers:
• with expression as variable: context_manager_syntax
• Context managers handle resource management automatically
• Automatic setup and cleanup of resources
• Exception-safe resource handling
• Replaces try/finally patterns

How it works:
• Expression evaluated (open('file'))
• __enter__() method called automatically
• Result assigned to variable (f)
• Code in with block executes normally
• __exit__() always called for cleanup (closes file)

Example:
with open('data.txt', 'r') as f:
    content = f.read()  # File is open here
# File automatically closed here, even if exception occurs

Benefits:
• Automatic resource cleanup (no manual close needed)
• Exception-safe (file closed even if error occurs)
• Cleaner than try/finally blocks
• Prevents resource leaks
• Readable and maintainable code

Example: with open('file') as f uses the file object's context manager to ensure the file is automatically closed after the with block, regardless of how the block exits.`
  }),
  (_i: number) => ({
    q: `What is class MyContext: def __enter__(self): return self; def __exit__(self, *args): pass; with MyContext() as ctx: pass?`,
    o: ["Uses context manager", "Error", "None", "Raises exception"],
    c: 0,
    e: "Context manager needs __enter__ and __exit__ methods.",
    de: `To create a custom context manager, a class must implement both __enter__ and __exit__ methods. __enter__ is called when entering the with block and returns the object to be used. __exit__ is called when exiting the with block and handles cleanup. This is the context manager protocol that makes objects work with the with statement.

Context manager protocol:
• __enter__(self): called on entry, returns context value
• __exit__(self, exc_type, exc_val, exc_tb): called on exit, handles cleanup
• Both methods are required for context manager functionality
• __exit__ receives exception info if any occurred
• Returning True from __exit__ suppresses exceptions

How it works:
• with MyContext() as ctx:
• MyContext() creates instance
• __enter__() called, return value (self) assigned to ctx
• Code in with block executes
• __exit__() called for cleanup (pass does nothing)
• Context manager instance available as ctx

Example:
class MyContext:
    def __enter__(self):
        print("Entering context")
        return self  # Return self for use in with block

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Exiting context")
        return False  # Don't suppress exceptions

with MyContext() as ctx:
    print(f"Context: {ctx}")  # ctx is the MyContext instance

Benefits:
• Custom resource management for any resource
• Automatic cleanup logic
• Exception handling control
• Reusable cleanup patterns
• Clean API for resource management

Example: Custom context manager class must implement __enter__ and __exit__ methods to work with the with statement. The __enter__ method returns self, which is assigned to ctx.`
  }),
  (_i: number) => ({
    q: `What is class MyContext: def __enter__(self): return 1; def __exit__(self, *args): pass; with MyContext() as x: x?`,
    o: ["1", "Error", "None", "0"],
    c: 0,
    e: "__enter__ return value assigned to variable after 'as'.",
    de: `The value returned by __enter__ is assigned to the variable after 'as' in the with statement. If __enter__ returns 1, then x will be assigned the value 1 inside the with block. This allows context managers to provide different objects than themselves for use in the with block.

__enter__ return value assignment:
• with ContextManager() as variable:
• __enter__() return value assigned to variable
• Can return self (common) or different object
• Variable available throughout with block
• Variable goes out of scope after with block

How it works:
• Context manager created: MyContext()
• __enter__() called, returns 1
• Value 1 assigned to variable x
• x = 1 inside with block
• __exit__() called when block exits

Example:
class NumberContext:
    def __enter__(self):
        return 42  # Return number, not self

    def __exit__(self, *args):
        pass

with NumberContext() as x:
    print(x)  # 42 (not the context manager object)

Common patterns:
• Return self: standard resource management (files, connections)
• Return different object: factory pattern, configuration objects
• Return None: when no specific object needed
• Return wrapper: decorator pattern

Example: __enter__ return value (1) is assigned to variable x, so x equals 1 inside the with block. The context manager can return any value it wants.`
  }),
  (_i: number) => ({
    q: `What is class MyContext: def __enter__(self): return self; def __exit__(self, exc_type, exc_val, exc_tb): return True; with MyContext(): 1/0?`,
    o: ["Suppresses exception", "Raises exception", "Error", "None"],
    c: 0,
    e: "__exit__ returning True suppresses exception.",
    de: `__exit__ can control exception handling by returning True to suppress exceptions that occur in the with block. When __exit__ returns True, any exception is caught and suppressed - it doesn't propagate outside the with statement. This is useful for context managers that handle errors internally.

Exception suppression in __exit__:
• __exit__(self, exc_type, exc_val, exc_tb) receives exception info
• Return True: suppress the exception completely
• Return False/None: let exception propagate normally
• Return value controls whether exception bubbles up
• Useful for expected/handled error conditions

How it works:
• Exception occurs in with block (1/0 causes ZeroDivisionError)
• __exit__ called with exception info: (ZeroDivisionError, exception_object, traceback)
• __exit__ returns True
• Exception is suppressed, doesn't propagate
• Program continues after with block

Example:
class SuppressErrors:
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Suppressed: {exc_type.__name__}")
        return True  # Suppress any exception

with SuppressErrors():
    raise ValueError("This won't propagate")

Benefits:
• Handle expected errors gracefully
• Prevent error propagation for known issues
• Cleanup even when errors occur
• Robust error handling in specific contexts
• Prevent crashes from anticipated errors

Example: __exit__ returning True suppresses the ZeroDivisionError from 1/0, preventing it from being raised outside the with block.`
  }),
  (_i: number) => ({
    q: `What is class MyContext: def __enter__(self): return self; def __exit__(self, *args): pass; with MyContext() as ctx: ctx?`,
    o: ["MyContext instance", "Error", "None", "0"],
    c: 0,
    e: "Context manager instance available in with block.",
    de: `The context manager instance is available in the with block through the variable assigned with 'as'. Since __enter__ returns self, ctx refers to the MyContext instance, allowing access to its attributes and methods during the with block.

Context manager instance access:
• with MyContext() as ctx: ctx refers to context manager
• Since __enter__ returns self, ctx is the instance
• Can access attributes and methods in with block
• Useful for resource management with instance state
• Instance persists throughout with block

How it works:
• MyContext() creates instance
• __enter__() returns self (the instance)
• Instance assigned to ctx variable
• ctx available throughout with block
• Can call methods: ctx.method()
• Can access attributes: ctx.attribute

Example:
class DatabaseConnection:
    def __init__(self):
        self.connected = False

    def __enter__(self):
        self.connected = True
        return self  # Return self for access

    def __exit__(self, *args):
        self.connected = False

with DatabaseConnection() as conn:
    print(conn.connected)  # True
    # Can call methods on conn here

Benefits:
• Access to context manager state and methods
• Resource control during with block
• Method calls on managed resource
• State inspection and modification
• Full resource API access

Example: Since __enter__ returns self, ctx is the MyContext instance, so ctx refers to the context manager object inside the with block.`
  }),
  (_i: number) => ({ q: `What is from contextlib import contextmanager; @contextmanager; def my_context(): yield 1; with my_context() as x: x?`, o: ["1", "Error", "None", "0"], c: 0, e: "@contextmanager decorator creates context manager from generator." }),
  (_i: number) => ({ q: `What is with open('file', 'w') as f: f.write('text'); f.closed?`, o: ["True", "False", "Error", "None"], c: 0, e: "File automatically closed after with block." }),
  (_i: number) => ({ q: `What is with open('file', 'w') as f1, open('file2', 'w') as f2: pass?`, o: ["Multiple context managers", "SyntaxError", "Error", "None"], c: 0, e: "Multiple context managers in one with statement." }),
  (_i: number) => ({ q: `What is from contextlib import suppress; with suppress(ValueError): raise ValueError()?`, o: ["Suppresses ValueError", "Raises exception", "Error", "None"], c: 0, e: "suppress() context manager suppresses specified exceptions." }),
  (_i: number) => ({ q: `What is class MyContext: def __enter__(self): return self; def __exit__(self, *args): self.closed = True; ctx = MyContext(); with ctx: pass; ctx.closed?`, o: ["True", "False", "Error", "None"], c: 0, e: "__exit__ called after with block completes." }),
  
  // 31-40: Modules and Imports
  (_i: number) => ({ q: `What is import module?`, o: ["Imports a module", "Exports a module", "Error", "Creates a module"], c: 0, e: "import loads a module." }),
  (_i: number) => ({ q: `What is from module import name?`, o: ["Imports name from module", "Imports entire module", "Error", "None"], c: 0, e: "from...import imports specific name." }),
  (_i: number) => ({ q: `What is from module import name as alias?`, o: ["Imports with alias", "SyntaxError", "Error", "None"], c: 0, e: "as keyword creates alias for import." }),
  (_i: number) => ({ q: `What is import module as alias?`, o: ["Imports module with alias", "SyntaxError", "Error", "None"], c: 0, e: "Module can be imported with alias." }),
  (_i: number) => ({ q: `What is from module import *?`, o: ["Imports all public names", "SyntaxError", "Error", "None"], c: 0, e: "* imports all public names from module." }),
  (_i: number) => ({ q: `What is __name__ == '__main__'?`, o: ["Checks if script is run directly", "Checks if imported", "Error", "None"], c: 0, e: "__name__ is '__main__' when script run directly." }),
  (_i: number) => ({ q: `What is if __name__ == '__main__': pass?`, o: ["Runs code only when script executed", "Runs always", "Error", "None"], c: 0, e: "Common pattern to run code only when script is main." }),
  (_i: number) => ({ q: `What is import sys; sys.path?`, o: ["List of module search paths", "Error", "None", "()"], c: 0, e: "sys.path contains directories Python searches for modules." }),
  (_i: number) => ({ q: `What is __all__ = ['name1', 'name2']?`, o: ["Defines public API", "SyntaxError", "Error", "None"], c: 0, e: "__all__ defines what 'from module import *' imports." }),
  (_i: number) => ({ q: `What is __file__?`, o: ["Path to current module file", "Error", "None", "''"], c: 0, e: "__file__ contains path to current module." }),
  
  // 41-50: Generators and Iterators
  (_i: number) => ({ q: `What is def gen(): yield 1; type(gen())?`, o: ["<class 'generator'>", "<class 'function'>", "Error", "None"], c: 0, e: "Function with yield returns generator." }),
  (_i: number) => ({ q: `What is def gen(): yield 1; next(gen())?`, o: ["1", "Error", "None", "0"], c: 0, e: "next() gets next value from generator." }),
  (_i: number) => ({ q: `What is def gen(): yield 1; yield 2; list(gen())?`, o: ["[1, 2]", "[1]", "Error", "None"], c: 0, e: "Generator yields multiple values." }),
  (_i: number) => ({ q: `What is def gen(): yield 1; return; g = gen(); next(g); next(g)?`, o: ["StopIteration", "1", "Error", "None"], c: 0, e: "Generator raises StopIteration when exhausted." }),
  (_i: number) => ({ q: `What is def gen(): yield 1; return 'done'; g = gen(); next(g); g.send(None)?`, o: ["StopIteration with value 'done'", "1", "Error", "None"], c: 0, e: "return value becomes StopIteration value." }),
  (_i: number) => ({ q: `What is def gen(): x = yield 1; yield x; g = gen(); next(g); g.send(2)?`, o: ["2", "1", "Error", "None"], c: 0, e: "send() sends value to generator, becomes yield expression value." }),
  (_i: number) => ({ q: `What is (x**2 for x in [1, 2, 3])?`, o: ["Generator expression", "List", "Error", "None"], c: 0, e: "Generator expression creates generator." }),
  (_i: number) => ({ q: `What is list(x**2 for x in [1, 2, 3])?`, o: ["[1, 4, 9]", "Generator", "Error", "None"], c: 0, e: "list() consumes generator expression." }),
  (_i: number) => ({ q: `What is def gen(): yield from [1, 2, 3]; list(gen())?`, o: ["[1, 2, 3]", "[1]", "Error", "None"], c: 0, e: "yield from delegates to another iterable." }),
  (_i: number) => ({ q: `What is class MyIter: def __iter__(self): return self; def __next__(self): return 1; type(MyIter())?`, o: ["<class '__main__.MyIter'>", "<class 'generator'>", "Error", "None"], c: 0, e: "Iterator class implements __iter__ and __next__." }),
  
  // 51-60: Decorators
  (_i: number) => ({ q: `What is def decorator(func): return func; @decorator; def func(): pass; type(func)?`, o: ["<class 'function'>", "<class 'decorator'>", "Error", "None"], c: 0, e: "Decorator that returns function unchanged." }),
  (_i: number) => ({ q: `What is def decorator(func): def wrapper(): return func(); return wrapper; @decorator; def func(): return 1; func()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Decorator wraps function in another function." }),
  (_i: number) => ({ q: `What is def decorator(func): def wrapper(*args, **kwargs): return func(*args, **kwargs); return wrapper; @decorator; def add(x, y): return x + y; add(1, 2)?`, o: ["3", "Error", "None", "0"], c: 0, e: "Decorator wrapper preserves function arguments." }),
  (_i: number) => ({ q: `What is from functools import wraps; def decorator(func): @wraps(func); def wrapper(): return func(); return wrapper; @decorator; def func(): pass; func.__name__?`, o: ["'func'", "'wrapper'", "Error", "None"], c: 0, e: "@wraps preserves original function metadata." }),
  (_i: number) => ({ q: `What is def decorator(arg): return lambda func: func; @decorator(1); def func(): pass?`, o: ["Decorator with argument", "SyntaxError", "Error", "None"], c: 0, e: "Decorator factory: function that returns decorator." }),
  (_i: number) => ({ q: `What is class Decorator: def __init__(self, func): self.func = func; def __call__(self): return self.func(); @Decorator; def func(): return 1; func()?`, o: ["1", "Error", "None", "0"], c: 0, e: "Class-based decorator using __call__." }),
  (_i: number) => ({ q: `What is @staticmethod; def func(): return 1?`, o: ["Static method decorator", "SyntaxError", "Error", "None"], c: 0, e: "@staticmethod is built-in decorator." }),
  (_i: number) => ({ q: `What is @classmethod; def method(cls): return cls?`, o: ["Class method decorator", "SyntaxError", "Error", "None"], c: 0, e: "@classmethod is built-in decorator." }),
  (_i: number) => ({ q: `What is @property; def x(self): return 1?`, o: ["Property decorator", "SyntaxError", "Error", "None"], c: 0, e: "@property is built-in decorator." }),
  (_i: number) => ({ q: `What is def decorator1(func): return func; def decorator2(func): return func; @decorator1; @decorator2; def func(): pass?`, o: ["Multiple decorators", "SyntaxError", "Error", "None"], c: 0, e: "Multiple decorators applied bottom to top." }),
  
  // 61-70: Design Patterns - Singleton, Factory, etc.
  (_i: number) => ({ q: `What is class Singleton: _instance = None; def __new__(cls): if cls._instance is None: cls._instance = super().__new__(cls); return cls._instance; obj1 = Singleton(); obj2 = Singleton(); obj1 is obj2?`, o: ["True", "False", "Error", "None"], c: 0, e: "Singleton pattern: __new__ ensures single instance." }),
  (_i: number) => ({ q: `What is class Factory: @staticmethod; def create(type): return type(); obj = Factory.create(list)?`, o: ["[]", "Error", "None", "Factory"], c: 0, e: "Factory pattern: creates objects without specifying exact class." }),
  (_i: number) => ({ q: `What is class Observer: def __init__(self): self._observers = []; def attach(self, observer): self._observers.append(observer); def notify(self): [o.update() for o in self._observers]?`, o: ["Observer pattern", "Error", "None", "Singleton"], c: 0, e: "Observer pattern: subject notifies observers of changes." }),
  (_i: number) => ({ q: `What is class Strategy: def execute(self): pass; class StrategyA(Strategy): def execute(self): return 'A'; class StrategyB(Strategy): def execute(self): return 'B'?`, o: ["Strategy pattern", "Error", "None", "Factory"], c: 0, e: "Strategy pattern: interchangeable algorithms." }),
  (_i: number) => ({ q: `What is class Adapter: def __init__(self, obj): self.obj = obj; def method(self): return self.obj.other_method()?`, o: ["Adapter pattern", "Error", "None", "Observer"], c: 0, e: "Adapter pattern: adapts interface of one class to another." }),
  (_i: number) => ({ q: `What is class Builder: def __init__(self): self.parts = []; def add(self, part): self.parts.append(part); return self; def build(self): return ''.join(self.parts)?`, o: ["Builder pattern", "Error", "None", "Factory"], c: 0, e: "Builder pattern: constructs complex objects step by step." }),
  (_i: number) => ({ q: `What is class Prototype: def clone(self): return type(self)()?`, o: ["Prototype pattern", "Error", "None", "Singleton"], c: 0, e: "Prototype pattern: creates objects by cloning." }),
  (_i: number) => ({ q: `What is class Facade: def __init__(self): self.subsystem1 = Subsystem1(); self.subsystem2 = Subsystem2(); def operation(self): return self.subsystem1.method() + self.subsystem2.method()?`, o: ["Facade pattern", "Error", "None", "Adapter"], c: 0, e: "Facade pattern: provides simplified interface to complex subsystem." }),
  (_i: number) => ({ q: `What is class Command: def execute(self): pass; class Invoker: def __init__(self): self.command = None; def set_command(self, cmd): self.command = cmd; def execute(self): self.command.execute()?`, o: ["Command pattern", "Error", "None", "Strategy"], c: 0, e: "Command pattern: encapsulates request as object." }),
  (_i: number) => ({ q: `What is class Component: def operation(self): pass; class Composite(Component): def __init__(self): self.children = []; def add(self, child): self.children.append(child); def operation(self): [c.operation() for c in self.children]?`, o: ["Composite pattern", "Error", "None", "Facade"], c: 0, e: "Composite pattern: treats individual and composite objects uniformly." }),
  
  // 71-80: Metaclasses and Advanced Features
  (_i: number) => ({ q: `What is class Meta(type): pass; class MyClass(metaclass=Meta): pass; type(MyClass)?`, o: ["<class '__main__.Meta'>", "<class 'type'>", "Error", "None"], c: 0, e: "metaclass parameter sets class's metaclass." }),
  (_i: number) => ({ q: `What is class Meta(type): def __new__(cls, name, bases, dct): return super().__new__(cls, name, bases, dct); class MyClass(metaclass=Meta): pass?`, o: ["Custom metaclass", "Error", "None", "Regular class"], c: 0, e: "Metaclass __new__ controls class creation." }),
  (_i: number) => ({ q: `What is class Meta(type): def __init__(cls, name, bases, dct): cls.custom_attr = 1; class MyClass(metaclass=Meta): pass; MyClass.custom_attr?`, o: ["1", "Error", "None", "0"], c: 0, e: "Metaclass __init__ can add attributes to class." }),
  (_i: number) => ({ q: `What is class Meta(type): def __call__(cls, *args, **kwargs): return super().__call__(*args, **kwargs); class MyClass(metaclass=Meta): pass; type(MyClass())?`, o: ["<class '__main__.MyClass'>", "<class '__main__.Meta'>", "Error", "None"], c: 0, e: "Metaclass __call__ controls instance creation." }),
  (_i: number) => ({ q: `What is class SingletonMeta(type): _instances = {}; def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super().__call__(*args, **kwargs); return cls._instances[cls]; class MyClass(metaclass=SingletonMeta): pass; MyClass() is MyClass()?`, o: ["True", "False", "Error", "None"], c: 0, e: "Metaclass can implement Singleton pattern." }),
  (_i: number) => ({ q: `What is class MyClass: __slots__ = ['x']; obj = MyClass(); obj.x = 1; obj.y = 2?`, o: ["AttributeError", "Works fine", "Error", "None"], c: 0, e: "__slots__ restricts instance attributes." }),
  (_i: number) => ({ q: `What is class MyClass: __slots__ = ['x']; obj = MyClass(); '__dict__' in dir(obj)?`, o: ["False", "True", "Error", "None"], c: 0, e: "__slots__ removes __dict__ (saves memory)." }),
  (_i: number) => ({ q: `What is class MyClass: def __getattribute__(self, name): return super().__getattribute__(name); obj = MyClass(); obj.x?`, o: ["AttributeError", "None", "Error", "0"], c: 0, e: "__getattribute__ intercepts all attribute access." }),
  (_i: number) => ({ q: `What is class MyClass: def __getattr__(self, name): return f'Missing: {name}'; obj = MyClass(); obj.x?`, o: ["'Missing: x'", "AttributeError", "Error", "None"], c: 0, e: "__getattr__ called only if attribute not found." }),
  (_i: number) => ({ q: `What is class MyClass: def __setattr__(self, name, value): super().__setattr__(name, value * 2); obj = MyClass(); obj.x = 5; obj.x?`, o: ["10", "5", "Error", "None"], c: 0, e: "__setattr__ intercepts all attribute assignment." }),
  
  // 81-90: Best Practices and Code Quality
  (_i: number) => ({ q: `What is PEP 8?`, o: ["Python style guide", "Python version", "Error", "Module"], c: 0, e: "PEP 8 is Python Enhancement Proposal for code style." }),
  (_i: number) => ({ q: `What is def func(x: int) -> int: return x * 2?`, o: ["Type hints", "SyntaxError", "Error", "None"], c: 0, e: "Type hints specify expected types (PEP 484)." }),
  (_i: number) => ({ q: `What is from typing import List, Dict; def func(x: List[int]) -> Dict[str, int]: return {}?`, o: ["Type hints with generics", "SyntaxError", "Error", "None"], c: 0, e: "typing module provides generic types." }),
  (_i: number) => ({ q: `What is def func(x: int = 1) -> int: return x?`, o: ["Type hints with defaults", "SyntaxError", "Error", "None"], c: 0, e: "Type hints work with default parameters." }),
  (_i: number) => ({ q: `What is def func(x: 'MyClass') -> None: pass?`, o: ["Forward reference (string)", "SyntaxError", "Error", "None"], c: 0, e: "String type hints allow forward references." }),
  (_i: number) => ({ q: `What is from typing import Optional; def func(x: Optional[int]) -> int: return x or 0?`, o: ["Optional type hint", "SyntaxError", "Error", "None"], c: 0, e: "Optional[T] means T or None." }),
  (_i: number) => ({ q: `What is from typing import Union; def func(x: Union[int, str]) -> int: return 1?`, o: ["Union type hint", "SyntaxError", "Error", "None"], c: 0, e: "Union[T, U] means T or U." }),
  (_i: number) => ({ q: `What is from typing import Callable; def func(f: Callable[[int], int]) -> int: return f(1)?`, o: ["Callable type hint", "SyntaxError", "Error", "None"], c: 0, e: "Callable[[args], return] hints function types." }),
  (_i: number) => ({ q: `What is from dataclasses import dataclass; @dataclass; class Point: x: int; y: int; Point(1, 2)?`, o: ["Data class instance", "SyntaxError", "Error", "None"], c: 0, e: "@dataclass automatically generates __init__, __repr__, etc." }),
  (_i: number) => ({ q: `What is from enum import Enum; class Color(Enum): RED = 1; GREEN = 2; Color.RED?`, o: ["<Color.RED: 1>", "1", "Error", "None"], c: 0, e: "Enum creates enumeration with named constants." }),
  
  // 91-100: Advanced Topics and Utilities
  (_i: number) => ({ q: `What is import sys; sys.argv?`, o: ["Command line arguments", "Error", "None", "[]"], c: 0, e: "sys.argv contains command line arguments." }),
  (_i: number) => ({ q: `What is import os; os.environ?`, o: ["Environment variables dict", "Error", "None", "{}"], c: 0, e: "os.environ contains environment variables." }),
  (_i: number) => ({ q: `What is import json; json.dumps({'a': 1})?`, o: ["'{\"a\": 1}'", "{'a': 1}", "Error", "None"], c: 0, e: "json.dumps() converts dict to JSON string." }),
  (_i: number) => ({ q: `What is import json; json.loads('{\"a\": 1}')?`, o: ["{'a': 1}", "'{\"a\": 1}'", "Error", "None"], c: 0, e: "json.loads() converts JSON string to dict." }),
  (_i: number) => ({ q: `What is import pickle; pickle.dumps([1, 2, 3])?`, o: ["Bytes object", "[1, 2, 3]", "Error", "None"], c: 0, e: "pickle.dumps() serializes object to bytes." }),
  (_i: number) => ({ q: `What is import pickle; data = pickle.dumps([1, 2, 3]); pickle.loads(data)?`, o: ["[1, 2, 3]", "Bytes object", "Error", "None"], c: 0, e: "pickle.loads() deserializes bytes to object." }),
  (_i: number) => ({ q: `What is from collections import namedtuple; Point = namedtuple('Point', ['x', 'y']); Point(1, 2)?`, o: ["Point(x=1, y=2)", "Error", "None", "(1, 2)"], c: 0, e: "namedtuple creates tuple subclass with named fields." }),
  (_i: number) => ({ q: `What is from collections import defaultdict; d = defaultdict(list); d['key']?`, o: ["[]", "KeyError", "Error", "None"], c: 0, e: "defaultdict returns default value for missing keys." }),
  (_i: number) => ({ q: `What is from collections import Counter; Counter([1, 1, 2, 2, 2])?`, o: ["Counter({2: 3, 1: 2})", "[1, 1, 2, 2, 2]", "Error", "None"], c: 0, e: "Counter counts occurrences of elements." }),
  (_i: number) => ({ q: `What is from functools import lru_cache; @lru_cache(maxsize=128); def fib(n): return n if n < 2 else fib(n-1) + fib(n-2); fib(10)?`, o: ["55", "10", "Error", "None"], c: 0, e: "@lru_cache memoizes function results (caching)." }),
];

// GENERATOR ENGINE
const generateLevel = (level: number, stage: PersonaStage, patterns: ((i: number) => any)[], startId: number) => {
  return Array.from({ length: 100 }, (_, i) => {
    const pattern = patterns[i % patterns.length](i);
    return {
      id: startId + i,
      level,
      persona_stage: stage,
      concept: "logic",
      difficulty: level > 7 ? 3 : (level > 4 ? 2 : 1),
      question: pattern.q,
      options: pattern.o,
      correct_option_index: pattern.c,
      explanation: pattern.e,
      detailedExplanation: pattern.de || undefined
    };
  });
};

export const QUESTIONS_BANK: Question[] = [
  ...generateLevel(1, PersonaStage.PLANKTON, level1Patterns, 1),
  ...generateLevel(2, PersonaStage.SHRIMP, level2Patterns, 101),
  ...generateLevel(3, PersonaStage.CRAB, level3Patterns, 201),
  ...generateLevel(4, PersonaStage.SMALL_FISH, level4Patterns, 301),
  ...generateLevel(5, PersonaStage.OCTOPUS, level5Patterns, 401),
  ...generateLevel(6, PersonaStage.SEAL, level6Patterns, 501),
  ...generateLevel(7, PersonaStage.DOLPHIN, level7Patterns, 601),
  ...generateLevel(8, PersonaStage.SHARK, level8Patterns, 701),
  ...generateLevel(9, PersonaStage.WHALE, level9Patterns, 801),
  ...generateLevel(10, PersonaStage.GOD_WHALE, level10Patterns, 901)
];
